
# Урок 11.

# ОПТИМИЗАЦИЯ ЗАПРОСОВ
- типы таблиц
- подробнее об индексах
- оптимизация запросов
- назначение типа таблице
- Архитектура MYSQL
- файлы таблиц
- список поддерживаемых систем хранения
- назначение и характеристики систем хранения
```
mysql> CREATE TABLE catalogs (
	id SERIAL PRIMARY KEY,
	name VARCHAR(255) COMMENT 'название раздела'
	) COMMENT = 'Разделы интернет-магазина';
```
СУБД mysql поддерживает несколько видов таблиц каждый из которых имеет свои возможности и ограничения задать тип таблицы можно при её создании для этого указываем параметр таблицы ENGINE=InnoDB;
```
mysql> CREATE TABLE catalogs (
	id SERIAL PRIMARY KEY,
	name VARCHAR(255) COMMENT 'название раздела'
	) COMMENT = 'Разделы интернет-магазина' ENGINE=InnoDB;
```
# АРХИТЕКТУРА MySQL
```
            ЯДРО
              |
 InnoDB   MyISAM   Memory   Archive
```
В СУБД mysql подсистемы хранение данных и ядро разделены. Ядро: 
- осуществляет поддержку соединения с клиентами 
- применение правил и логики языка sql
- кэширование запросов
- за хронение данных, 
- индексирование
- выполнение низкоуровневых операций с хронилищем 

отвечает подсистема хронения, которую часто называют движками.

Их давольно много. По умолчанию используется двжок `InnoDB` до текущего момента мы использовали его не явно т.к это движок по умолчанию его не обязательно было указывать при создании таблиц. Если хотим создать таблицу с иной подсистемой хронения её надо указывать явно например можно задействовать таблицу типа `Memory` полностью разместив данные в оперативной памяти или использовать таблицу `Archive`, чтобы сжать данные нужно будет явно указать тип движка в операторе `CREATE TABLE` `ENGINE=Memory , ENGINE=Archive`

# АРХИТЕКТУРА ЯДРА MySQL
```
обработка соединений и потоков
     |                    |
кэш запросов   ->    Анализатор
                          |
Оптимизатор    <-    Препроцессор
```
Кратко остановимся на ядре Mysql оно поддерживает пул соединение с клиентами, обеспечивая каждого из них сессией и обрабатывая его запросы в случае если на сервере включён кэш запросов каждый `SELECT` запрос проверяется сначала в кэше. Если он присутствует там, ответ выдаётся сразу. Если запрос там не обнаружен или запрос в принципе не предназначен для кэширования он идёт в анализатор, который разбивает запрос на ликсемы и строит дерево разборов. Для интерпритации и проверки запросов анализатор использует грамматику языка SQL проверяется, что все лексемы допустимы, следуют в нужном порядке и нет других ошибок например непарных ковычек. Затем получившееся дерево разбора передаётся препроцессору, который контролирует дополнительную симатику не входящую в компетению анализатора к примеру проверяется, что указанные таблицы и столбцы существуют, а ссылки на столбцы не допускают неоднозначного толкования. Далее препроцессор проверяет привелегии пользователя. Теперь когда дерево разбора тщательно проверено наступает очередь оптимизатора который превращает его в план выполнения запроса.

Часто существует множество способов выполнить запрос и все они дают один и тот же результат. Задача оптимизатора выбрать лучший из них. Язык sql является декларативным, мы не объясняем как выполнять запрос, мы запрашиваем что хотим получить поэтому оптимизатор имеет свободу действий по выбору пути выполнения запроса и выбору индексов, которые будут применяться. Более того он привлекает статистику сервера для выбора наиболее оптимального пути. После того как план выполнения запроса выбран происходит его выполнение с использованием апи подсистемы хранения т.е ядро обращается к низкоуровневому вызову движка таблицы

# ФАЙЛЫ ТАБЛИЦ
- MyISAM: catigories.frm, catigories.MYD, catigories.MYI
- InnoDB: catigories.frm, ibdata1
- InnoDB innodb_file_per_table: catigories.frm , catigories.ibd

Устройсство бд - подкаталог в каталоге данных, в подкаталоге каждой из таблиц создаётся файл с расширением .frm и именем совпадающем с именем таблицы в этом файле хронится определение таблицы, список столбцов, их типы и порядок следования файл с опредилением одинаков для всех подсистем хронения т.к его обрабатывает ядро, а вот данные индекса для каждой системы хронения реализуются поразному за их работу отвечают движки таблиц. например для типа таблиц `MyISAM`. Данные сохроняются в одноимённом файле с расширением `.MYD`, а индексы в файле с расширением `.MYI`. В случае движка `InnoDB` данные и индексы всех таблиц во всех БД хронятся в едином табличном постранстве. Впрочем, если в конфигурационном файле `mycnf` включить директиву `innodb_file_per_table` можно перевести mysql в режим, когда для каждой таблицы будет организовываться собственное табличное пространство в файле с расширением `.ibd`

Перейдём в каталог данных и посмотрим его содержимое за это отвечает переменная `datadir`
```
mysql> SHOW VARIABLES LIKE 'datadir';
+---------------+-----------------+
| Variable_name | Value           |
+---------------+-----------------+
| datadir       | /var/lib/mysql/ |
+---------------+-----------------+
1 row in set (0.73 sec)
```
```
mysql> exit

student@Ubuntu-MySQL-VirtualBox:~$> cd /var/lib/mysql/
-->
bash: cd: /var/lib/mysql/: Отказано в доступе
```
зайдём в режиме суперпользователя
```
student@Ubuntu-MySQL-VirtualBox:~$> sudo su - root
root@Ubuntu-MySQL-VirtualBox:~#> cd /var/lib/mysql/
```
посмотрим его содержимое
```
root@Ubuntu-MySQL-VirtualBox:/var/lib/mysql# > ls -la
```
для виндоус команда dir
```
итого 122960
drwx------  7 mysql mysql     4096 ноя  2 10:14 .
drwxr-xr-x 70 root  root      4096 окт  7 11:16 ..
-rw-r-----  1 mysql mysql       56 апр 22  2019 auto.cnf
-rw-------  1 mysql mysql     1680 окт  7 11:23 ca-key.pem
-rw-r--r--  1 mysql mysql     1112 окт  7 11:23 ca.pem
-rw-r--r--  1 mysql mysql     1112 окт  7 11:23 client-cert.pem
-rw-------  1 mysql mysql     1676 окт  7 11:23 client-key.pem
-rw-r--r--  1 mysql mysql        0 окт  7 11:22 debian-5.7.flag
drwxr-x---  2 mysql mysql     4096 окт 11 15:31 example_db
-rw-r-----  1 mysql mysql      679 окт  7 11:23 ib_buffer_pool
-rw-r-----  1 mysql mysql 12582912 ноя  2 10:14 ibdata1
-rw-r-----  1 mysql mysql 50331648 ноя  2 10:14 ib_logfile0
-rw-r-----  1 mysql mysql 50331648 апр 22  2019 ib_logfile1
-rw-r-----  1 mysql mysql 12582912 ноя  2 10:14 ibtmp1
drwxr-x---  2 mysql mysql     4096 окт  7 11:23 mysql
-rw-r--r--  1 root  root         6 окт  7 11:23 mysql_upgrade_info
drwxr-x---  2 mysql mysql     4096 окт  7 11:23 performance_schema
-rw-------  1 mysql mysql     1676 окт  7 11:23 private_key.pem
-rw-r--r--  1 mysql mysql      452 окт  7 11:23 public_key.pem
-rw-r--r--  1 mysql mysql     1112 окт  7 11:23 server-cert.pem
-rw-------  1 mysql mysql     1676 окт  7 11:23 server-key.pem
drwxr-x---  2 mysql mysql     4096 окт 22 11:02 shop
drwxr-x---  2 mysql mysql    12288 окт  7 11:23 sys
```
Мы видим файл с единым табличным пространством `ibdata1`
- `-rw-r-----  1 mysql mysql 12582912 ноя  2 10:14 ibdata1` временные таблицы содержит файл `ibtmp1`
- `-rw-r-----  1 mysql mysql 12582912 ноя  2 10:14 ibtmp1` журналы транзакций `ib_logfile0` и `ib_logfile1`
- `-rw-r-----  1 mysql mysql 50331648 ноя  2 10:14 ib_logfile0`
- `-rw-r-----  1 mysql mysql 50331648 апр 22  2019 ib_logfile1`

перейдём в каталог `shop`

```
root@Ubuntu-MySQL-VirtualBox:/var/lib/mysql# cd shop
```
посмотрим содержимое
```
root@Ubuntu-MySQL-VirtualBox:/var/lib/mysql/shop# ls -la
```
-->
```
итого 1564
drwxr-x--- 2 mysql mysql   4096 окт 22 11:02 .
drwx------ 7 mysql mysql   4096 ноя  2 10:14 ..
-rw-r----- 1 mysql mysql   8716 окт 22 11:02 accounts.frm
-rw-r----- 1 mysql mysql 114688 окт 22 11:51 accounts.ibd
-rw-r----- 1 mysql mysql   8617 окт 15 10:41 catalogs.frm
-rw-r----- 1 mysql mysql 131072 окт 15 10:41 catalogs.ibd
-rw-r----- 1 mysql mysql     62 окт 15 10:39 db.opt
-rw-r----- 1 mysql mysql   8889 окт 15 10:41 discounts.frm
-rw-r----- 1 mysql mysql 147456 окт 15 10:41 discounts.ibd
-rw-r----- 1 mysql mysql   8676 окт 15 10:41 orders.frm
-rw-r----- 1 mysql mysql 131072 окт 15 10:41 orders.ibd
-rw-r----- 1 mysql mysql   8825 окт 15 10:41 orders_products.frm
-rw-r----- 1 mysql mysql 114688 окт 15 10:41 orders_products.ibd
-rw-r----- 1 mysql mysql   8826 окт 19 12:17 products.frm
-rw-r----- 1 mysql mysql 131072 окт 19 12:07 products.ibd
-rw-r----- 1 mysql mysql   8617 окт 15 10:41 rubrics.frm
-rw-r----- 1 mysql mysql 114688 окт 15 10:41 rubrics.ibd
-rw-r----- 1 mysql mysql   8686 окт 15 10:41 storehouses.frm
-rw-r----- 1 mysql mysql 114688 окт 15 10:41 storehouses.ibd
-rw-r----- 1 mysql mysql   8822 окт 15 10:41 storehouses_products.frm
-rw-r----- 1 mysql mysql 114688 окт 15 10:41 storehouses_products.ibd
-rw-r----- 1 mysql mysql   8562 окт 18 18:49 tbl1.frm
-rw-r----- 1 mysql mysql  98304 окт 18 18:51 tbl1.ibd
-rw-r----- 1 mysql mysql   8562 окт 18 18:51 tbl2.frm
-rw-r----- 1 mysql mysql  98304 окт 18 18:52 tbl2.ibd
-rw-r----- 1 mysql mysql   8766 окт 15 10:41 users.frm
-rw-r----- 1 mysql mysql 114688 окт 15 10:41 users.ibd
```
Мы видим файлы со структурой `.frm` и данными `.ibd` каждая пара соответствует таблице в базе данных `shop` также присутствуют файлы с расширением `.TRN`, которые предназначены для обеспечения работы тригеров переместимся в системную БД mysql
```
root@Ubuntu-MySQL-VirtualBox:/var/lib/mysql/shop# cd ../mysql
```
посмотрим содержимое
```
root@Ubuntu-MySQL-VirtualBox:/var/lib/mysql/mysql# ls -la
```
-->
```
 итого 9904
 drwxr-x--- 2 mysql mysql    4096 окт  7 11:23 .
 drwx------ 7 mysql mysql    4096 ноя  2 10:14 ..
 -rw-r----- 1 mysql mysql    8820 окт  7 11:23 columns_priv.frm
 -rw-r----- 1 mysql mysql       0 окт  7 11:23 columns_priv.MYD
 -rw-r----- 1 mysql mysql    4096 окт  7 11:23 columns_priv.MYI
 -rw-r----- 1 mysql mysql    9582 окт  7 11:23 db.frm
 -rw-r----- 1 mysql mysql     976 окт  7 11:23 db.MYD
 -rw-r----- 1 mysql mysql    5120 окт  7 11:23 db.MYI
 -rw-r----- 1 mysql mysql      65 апр 22  2019 db.opt
 -rw-r----- 1 mysql mysql    8780 апр 22  2019 engine_cost.frm
 -rw-r----- 1 mysql mysql   98304 апр 22  2019 engine_cost.ibd
 -rw-r----- 1 mysql mysql   10223 окт  7 11:23 event.frm
 -rw-r----- 1 mysql mysql       0 окт  7 11:23 event.MYD
 -rw-r----- 1 mysql mysql    2048 окт  7 11:23 event.MYI
 -rw-r----- 1 mysql mysql    8665 окт  7 11:23 func.frm
 -rw-r----- 1 mysql mysql       0 окт  7 11:23 func.MYD
 -rw-r----- 1 mysql mysql    1024 окт  7 11:23 func.MYI
 -rw-r----- 1 mysql mysql      35 окт  7 11:23 general_log.CSM
 -rw-r----- 1 mysql mysql       0 окт  7 11:23 general_log.CSV
 -rw-r----- 1 mysql mysql    8776 окт  7 11:23 general_log.frm
 -rw-r----- 1 mysql mysql    8784 окт  7 11:23 gtid_executed.frm
 -rw-r----- 1 mysql mysql   98304 апр 22  2019 gtid_executed.ibd
 -rw-r----- 1 mysql mysql    8700 окт  7 11:23 help_category.frm
 -rw-r----- 1 mysql mysql  114688 окт  7 11:23 help_category.ibd
 -rw-r----- 1 mysql mysql    8612 окт  7 11:23 help_keyword.frm
 -rw-r----- 1 mysql mysql  262144 окт  7 11:23 help_keyword.ibd
 -rw-r----- 1 mysql mysql    8630 окт  7 11:23 help_relation.frm
 -rw-r----- 1 mysql mysql  147456 окт  7 11:23 help_relation.ibd
 -rw-r----- 1 mysql mysql    8770 окт  7 11:23 help_topic.frm
 -rw-r----- 1 mysql mysql 7340032 окт  7 11:23 help_topic.ibd
 -rw-r----- 1 mysql mysql   12982 окт  7 11:23 innodb_index_stats.frm
 -rw-r----- 1 mysql mysql   98304 окт 22 11:04 innodb_index_stats.ibd
 -rw-r----- 1 mysql mysql    8830 окт  7 11:23 innodb_table_stats.frm
 -rw-r----- 1 mysql mysql   98304 окт 22 11:04 innodb_table_stats.ibd
 -rw-r----- 1 mysql mysql    8986 окт  7 11:23 ndb_binlog_index.frm
 -rw-r----- 1 mysql mysql       0 апр 22  2019 ndb_binlog_index.MYD
 -rw-r----- 1 mysql mysql    1024 апр 22  2019 ndb_binlog_index.MYI
 -rw-r----- 1 mysql mysql    8586 окт  7 11:23 plugin.frm
 -rw-r----- 1 mysql mysql   98304 окт  7 11:23 plugin.ibd
 -rw-r----- 1 mysql mysql    9996 окт  7 11:23 proc.frm
 -rw-r----- 1 mysql mysql  301508 окт  7 11:23 proc.MYD
 -rw-r----- 1 mysql mysql    4096 окт  7 11:23 proc.MYI
 -rw-r----- 1 mysql mysql    8875 окт  7 11:23 procs_priv.frm
 -rw-r----- 1 mysql mysql       0 окт  7 11:23 procs_priv.MYD
 -rw-r----- 1 mysql mysql    4096 окт  7 11:23 procs_priv.MYI
 -rw-r----- 1 mysql mysql    8800 окт  7 11:23 proxies_priv.frm
 -rw-r----- 1 mysql mysql     837 апр 22  2019 proxies_priv.MYD
 -rw-r----- 1 mysql mysql    9216 апр 22  2019 proxies_priv.MYI
 -rw-r----- 1 mysql mysql    8692 апр 22  2019 server_cost.frm
 -rw-r----- 1 mysql mysql   98304 апр 22  2019 server_cost.ibd
 -rw-r----- 1 mysql mysql    8838 окт  7 11:23 servers.frm
 -rw-r----- 1 mysql mysql   98304 окт  7 11:23 servers.ibd
 -rw-r----- 1 mysql mysql   10908 окт  7 11:23 slave_master_info.frm
 -rw-r----- 1 mysql mysql   98304 апр 22  2019 slave_master_info.ibd
 -rw-r----- 1 mysql mysql    9468 окт  7 11:23 slave_relay_log_info.frm
 -rw-r----- 1 mysql mysql   98304 апр 22  2019 slave_relay_log_info.ibd
 -rw-r----- 1 mysql mysql    9364 окт  7 11:23 slave_worker_info.frm
 -rw-r----- 1 mysql mysql   98304 апр 22  2019 slave_worker_info.ibd
 -rw-r----- 1 mysql mysql      35 окт  7 11:23 slow_log.CSM
 -rw-r----- 1 mysql mysql       0 апр 22  2019 slow_log.CSV
 -rw-r----- 1 mysql mysql    9016 окт  7 11:23 slow_log.frm
 -rw-r----- 1 mysql mysql    8955 окт  7 11:23 tables_priv.frm
 -rw-r----- 1 mysql mysql    1894 окт  7 11:23 tables_priv.MYD
 -rw-r----- 1 mysql mysql    9216 окт  7 11:23 tables_priv.MYI
 -rw-r----- 1 mysql mysql    8636 окт  7 11:23 time_zone.frm
 -rw-r----- 1 mysql mysql   98304 окт  7 11:23 time_zone.ibd
 -rw-r----- 1 mysql mysql    8624 окт  7 11:23 time_zone_leap_second.frm
 -rw-r----- 1 mysql mysql   98304 окт  7 11:23 time_zone_leap_second.ibd
 -rw-r----- 1 mysql mysql    8606 окт  7 11:23 time_zone_name.frm
 -rw-r----- 1 mysql mysql   98304 окт  7 11:23 time_zone_name.ibd
 -rw-r----- 1 mysql mysql    8686 окт  7 11:23 time_zone_transition.frm
 -rw-r----- 1 mysql mysql   98304 окт  7 11:23 time_zone_transition.ibd
 -rw-r----- 1 mysql mysql    8748 окт  7 11:23 time_zone_transition_type.frm
 -rw-r----- 1 mysql mysql   98304 окт  7 11:23 time_zone_transition_type.ibd
 -rw-r----- 1 mysql mysql   10816 окт  7 11:23 user.frm
 -rw-r----- 1 mysql mysql     520 окт  7 11:23 user.MYD
 -rw-r----- 1 mysql mysql    4096 окт  7 11:23 user.MYI
```
Как видим тут есть таблицы MyISAM
- `-rw-r----- 1 mysql mysql    4096 окт  7 11:23 proc.` в которых хронятся хронимые процедуры и функции для неё есть файл `.frm` со структурой таблицы
- `-rw-r----- 1 mysql mysql    9996 окт  7 11:23 proc.frm` файл `.MYD` с данными
- `-rw-r----- 1 mysql mysql  301508 окт  7 11:23 proc.MYD` и файл `.MYI` с индексами
- `-rw-r----- 1 mysql mysql    4096 окт  7 11:23 proc.MYI`

Для того чтобы определить, какая подсистема хронения используется для конкретной таблицы не заглядывая в каталог данных используем команду
```
mysql> SHOW TABLE STATUS LIKE 'catalogs'\G
```
-->
```
 *************************** 1. row ***************************
            Name: catalogs
          Engine: InnoDB
         Version: 10
      Row_format: Dynamic
            Rows: 5
  Avg_row_length: 3276
     Data_length: 16384
 Max_data_length: 0
    Index_length: 32768
       Data_free: 0
  Auto_increment: 6
     Create_time: 2021-10-15 10:41:09
     Update_time: NULL
      Check_time: NULL
       Collation: utf8_romanian_ci
        Checksum: NULL
  Create_options:
         Comment: Разделы интернет-магазина
 1 row in set (0.00 sec)
```
список доступных движков и их характеристик
```
mysql> SHOW ENGINES\G
```
-->
```
 *************************** 1. row ***************************
       Engine: PERFORMANCE_SCHEMA
      Support: YES
      Comment: Performance Schema
 Transactions: NO
           XA: NO
   Savepoints: NO
 *************************** 2. row ***************************
       Engine: CSV
      Support: YES
      Comment: CSV storage engine
 Transactions: NO
           XA: NO
   Savepoints: NO
 *************************** 3. row ***************************
       Engine: MRG_MYISAM
      Support: YES
      Comment: Collection of identical MyISAM tables
 Transactions: NO
           XA: NO
   Savepoints: NO
 *************************** 4. row ***************************
       Engine: BLACKHOLE
      Support: YES
      Comment: /dev/null storage engine (anything you write to it disappears)
 Transactions: NO
           XA: NO
   Savepoints: NO
 *************************** 5. row ***************************
       Engine: MyISAM
      Support: YES
      Comment: MyISAM storage engine
 Transactions: NO
           XA: NO
   Savepoints: NO
 *************************** 6. row ***************************
       Engine: MEMORY
      Support: YES
      Comment: Hash based, stored in memory, useful for temporary tables
 Transactions: NO
           XA: NO
   Savepoints: NO
 *************************** 7. row ***************************
       Engine: ARCHIVE
      Support: YES
      Comment: Archive storage engine
 Transactions: NO
           XA: NO
   Savepoints: NO
 *************************** 8. row ***************************
       Engine: InnoDB
      Support: DEFAULT
      Comment: Supports transactions, row-level locking, and foreign keys
 Transactions: YES
           XA: YES
   Savepoints: YES
 *************************** 9. row ***************************
       Engine: FEDERATED
      Support: NO
      Comment: Federated MySQL storage engine
 Transactions: NULL
           XA: NULL
   Savepoints: NULL
 9 rows in set (0.07 sec)
```
Движок `InnoDB` был разработан для транзакционной обработки и астоматического восстановления после сбоя. Движок поддерживает внешние ключи и блокировку на уровне строк система хранения не хэширует информацию о количестве строк в таблице, поэтому в отчётах эта цифра часто приблизительная, а выполнение запросов с участием функции `COUNT()` очень трудоёмкий, т.к каждый раз происходит полное сканирование таблицы

# Таблицы `Engine`
- `Engine: MEMORY` полностью расположены в оперативной памяти и не поддерживают транзакций при перезапуске сервера содержимое таблиц обнуляется за счёт расположения в оперативной памяти операции с такой таблицей происходят быстро при операции вставки происходит табличная блокировка т.е нельзя одновременно вставлять 2 записи в таблицу, такие операции выстраиваются в очередь для данного типа таблиц по умолчанию используются хэш индексы используются редко т.к существуют `Nosql` решения для таких задач например БД `reddis`

- `Engine: BLACKHOLE` таблицы не содержат данных операции в отношении этих таблиц не фиксируются на жёстком диске, но фиксируются в бинарном журнале. Таблицы выступают в качестве ретранслятора бинарного журнала, когда с этим не справляется реплика например в топологии пирамида, когда необходимо к нагруженному мастер серверу подключить множество слейв серверов. В этом случае сервер, который реально не выполняет запросов справляется с задачей передачи бинарного журнала гораздо лучше. Для организации такого сервера таблицам назначается тип  `BLACKHOLE`

- `Engine: MyISAM` файловый движок не поддерживающий транзакций при операциях вставках также происходит табличная блокировка движки без транзакций. т.к транзакции потребляют ресурсы, когда они не важны и операции вставок не часты применяется в отношении небольших таблиц можно добиться значительного выигрыша в производительности.

- `Engine: MRG_MYISAM` объединение нескольких структурно одинаковых таблиц `MYISAM` в одну виртуальную таблицу для некоторой степени это своеобразный материализованный `UNION` запрос

- `Engine: CSV` позволяет рассматривать текстовые `CSV` файлы с разделителями запятыми как таблицы такие файлы легко создаются как в ручную так и любым скриптом они легко сохраняются из XL таблиц

- `Engine: ARCHIVE` позволяет выполнять только команды `INSERT` и `SELECT`. Таблицы потребляют исключительно мало оперативной память снижают дисковый ввод и вывод т.к данные сжимаются библиотекой зэли, чаще всего используется для протоколирования и сбора данных эта система хронения `ARCHIVE` поддерживает блокировку на уровне строк и специальный системный буфер для вставки с высокой степенью конкурентности. Не поддерживает транзакций оптимизирована для высокоскоростной вставки и хранении данных в сжатом виде

# ИНДЕКСЫ И ИХ НАСТРОЙКИ
- кэширование индексов
- управление выделением памяти
- Различие в оптимизации MySQL под разные типы таблиц
- Эффективность индексов

Индексы - структуры, помогающие mysql эффективно извлекать данные они кретически важны для хорошей производительности важность индексов увеличивается при росте объема данных, индексы хронят столбцы в заранее отсортированном виде сами индексы стараются держать в быстрой оперативной памяти, вместо хранения их на жёстком диске. MYSQL не может взять без спросу столько оперативной памяти сколько имеется в системе её потребуется выделять

В mysql имеется огромное количество разных Хэшей основное их назначение разместить в быстрой оперативной памяти информации с более медленного жёсткого диска в результате данные моментально отдаются из оперативной памяти вместо обращения к более медленному диску часть кэшей выделяется на ядро и являются общими для всех соединений. Часть кэшей выделяется на каждое соединение. Например кэши под индексы являются общими для всех клиентов, а кэши под сортировку данных индивидуальны для каждого соединения

# кэширование индексов. пример my.cnf. Пример конфигурации mysql сервера
```
 [mysqld]                             ядро:
 ...
 query_cache_size = 0                  0 +
 key_buffer_size = 8M                  8M +
 innodb_buffer_pool_size = 1024M       1024M
 innodb_additional_mem_pool_size = 8M  8M +
 innodb_log_buffer_size = 8M           8M =
 ...                                   1056M
 max_connections = 200
 ...                                  соединение:
 read_buffer_size = 1M                  1M +
 read_rnd_buffer_size = 1M              1M +
 sort_buffer_size = 2M                  2M +
 thread_stack = 256K                    256K +
 join_buffer_size = 128K                128K ~
                                        3.5M
```
Почти всегда можно подсчитать максимаьный размер, который займёт mysql кэшами общего назначения и отдельным соединением. Пример конфигурации mysql сервера в котором ядро может занять чуть больше 1 гб, а каждое из соединений порядка 3.5 Мб в качестве максимального количества соединений мы выставили 200, таким образом при максимальной нагрузке на соединения уйдёт порядка 700 мб

Если у нас на сервере имеется свободная оперативная память мы можем выделить для mysql дополнительную память например увеличить `innodb_buffer_pool_size = 8G`, для кэширования индексов и данных, а количество соединений `max_connections = 500` увеличить до 500, в результате при максимальной нагрузке сервер будет потреблять порядка 10 ГБ. 8 + 500 * 3.5

За реализацию индексов отвечают подсистемы хронения, поэтому в разных системах хронения кэширование индексов может осуществляться по разному. Например в таблицах типа `MyISAM` индексы и данные разделены данные всегда находятся на жёстком диске. Индексы по мере необходимости подтягиваются в оперативную память кэш индексов при необходимости данные кэшируются средствами операционной системы, поэтому если `MyISAM` основной тип используемых таблиц важно оставлять на сервере какое то количество оперативной памяти. В таблицах `InnoDB` индексы хронятся в едином табличном пространстве вместе с данными, поэтому говоря о кэшировании `InnoDB` имеется в виду что в оперативной памяти размещаются и индексы и данные для первичного ключа в `InnoDB` используется кластерный индекс. Это практически тоже самое бинарное дерево, как и в случае идексов только в качестве листьев этого дерева выступают строки таблицы. Таким образом строки с близким значением первичного ключа хронятся по соседству, кроме того на таблице можно построить только один кластерный индекс, поскольку невозможно хронить одну и туже запись в двух разных местах.

Оценить объем оперативной памяти выделенный под кэш `MyISAM` индексов можно при помощи команды
```
mysql> SHOW VARIABLES LIKE 'Key%';
-->
+--------------------------+----------+
| Variable_name            | Value    |
+--------------------------+----------+
| key_buffer_size          | 16777216 |
| key_cache_age_threshold  | 300      |
| key_cache_block_size     | 1024     |
| key_cache_division_limit | 100      |
| keyring_operations       | ON       |
+--------------------------+----------+
```
`key_buffer_size`  показывает объём в байтах, выделенный под этот кэш это значение можно редактировать при помощи конфигурационного файла `my.cnf`. Максимальнодопустимый размер для этой директивы 4 гб, мы приемущественно используем `InnoDB` поэтому этот хэш не стоит увеличивать слишком сильно оценить эффективность этого хэша можно с помощью команды
```
mysql> SHOW STATUS LIKE 'Key%';
-->
+------------------------+-------+
| Variable_name          | Value |
+------------------------+-------+
| Key_blocks_not_flushed | 0     |
| Key_blocks_unused      | 13396 |
| Key_blocks_used        | 3     |
| Key_read_requests      | 6     |
| Key_reads              | 3     |
| Key_write_requests     | 0     |
| Key_writes             | 0     |
+------------------------+-------+
7 rows in set (0.12 sec)
```
отфильтровав результаты по шаблону `Key`
- `Key_blocks_used` - количество занятых блоков в хэше
- `Key_blocks_unused`  - количество свободных блоков
- `Key_read_requests` - количество блоков прочитаных из хэша
- `Key_reads` - состояние блоков прочитанных с жёсткого диска в хэш
- `Key_write_requests` - состояние блоков записанных в хэш
- `Key_writes`  - состояние блоков записанных на жёсткий диск

оценить объём пул буферов выделенных под `InnoDB` (в байтах)
```
mysql> SHOW VARIABLES LIKE 'innodb_buffer_pool_size';
-->
+-------------------------+-----------+
| Variable_name           | Value     |
+-------------------------+-----------+
| innodb_buffer_pool_size | 134217728 |
+-------------------------+-----------+
1 row in set (0.00 sec)
```
По умолчанию 128 мб пул буферов в оперативной памяти под индексы и под данные

Объём пула буферов можно регулировать через одноимённую директиву конфигурационного файла `my.cnf`. Если mysql это основное ПО на сервере, то под пул буферов рекомендуется выделять 50-80% оперативной памяти. т.к хэшируются не только индексы, но и данные, пул буферов должен быть объёмным, если ситуация позволяет, желательно чтобы БД целиком проваливалась в пул буфера, а к жёсткому диску mysql обращалась только при записи транзакций. Если оперативная память на сервере будет исчерпана часть данных будет сбрасываться на жёсткий диск в своп при обращении к этим данным ОС вынуждена будет выгрузить другие данные из оперативной памяти и подгрузить запрашиваемые в результате скорость работы может замедлиться критически.

Все параметры mysql сервера лучше наращивать постепенно, тщательно отслеживая состояние ОС

оценить эффективность хэша `InnoDB`
```
mysql> SHOW STATUS LIKE 'Innodb_buffer_pool_%';
-->
+---------------------------------------+--------------------------------------------------+
| Variable_name                         | Value                                            |
+---------------------------------------+--------------------------------------------------+
| Innodb_buffer_pool_dump_status        | Dumping of buffer pool not started               |
| Innodb_buffer_pool_load_status        | Buffer pool(s) load completed at 211102 10:14:35 |
| Innodb_buffer_pool_resize_status      |                                                  |
| Innodb_buffer_pool_pages_data         | 398                                              |
| Innodb_buffer_pool_bytes_data         | 6520832                                          |
| Innodb_buffer_pool_pages_dirty        | 0                                                |
| Innodb_buffer_pool_bytes_dirty        | 0                                                |
| Innodb_buffer_pool_pages_flushed      | 36                                               |
| Innodb_buffer_pool_pages_free         | 7793                                             |
| Innodb_buffer_pool_pages_misc         | 0                                                |
| Innodb_buffer_pool_pages_total        | 8191                                             |
| Innodb_buffer_pool_read_ahead_rnd     | 0                                                |
| Innodb_buffer_pool_read_ahead         | 0                                                |
| Innodb_buffer_pool_read_ahead_evicted | 0                                                |
| Innodb_buffer_pool_read_requests      | 1689                                             |
| Innodb_buffer_pool_reads              | 365                                              |
| Innodb_buffer_pool_wait_free          | 0                                                |
| Innodb_buffer_pool_write_requests     | 325                                              |
+---------------------------------------+--------------------------------------------------+
18 rows in set (0.00 sec)
```
- `Innodb_buffer_pool_pages_total` - общее количество блоков в хэше
- `Innodb_buffer_pool_pages_free` - количество свободных блоков, если эта величина исчерпана, необходимо увеличить память под InnoDB
- `Innodb_buffer_pool_pages_data` - количество занятых блоков

`Innodb_buffer_pool_pages_data` + `Innodb_buffer_pool_pages_free` = `Innodb_buffer_pool_pages_total` отношение операций чтения и записи показывает эффективность хэша
- `Innodb_buffer_pool_read_requests / Innodb_buffer_pool_write_requests`
- `Innodb_buffer_pool_reads` - количество чтений с жёсткого диска
- `Innodb_buffer_pool_read_requests` - количество чтений из оперативной памяти

# ОПТИМИЗАЦИЯ ЗАПРОСОВ
- приёмы оптимизации
- команда `EXPLAIN`
- исследование плана выполнения запроса
- использование индексов в запросе

При выполнении запроса в MySQL после окончания всегда выводится время исполнения запроса
```
7 rows in set (0.12 sec)
1 row in set (0.73 sec)
и т.д.
```
Когда сервер обрабатывает большое количество запросов это может отразиться на времени и выливаться в значительную нагрузку

# СПОСОБЫ ОПТИМИЗАЦИИ
- меньше возвращает запросом данных
- Меньше `NULL` значений
- Меньше типов `TEXT` и `BLOB`
- небольшие промежуточные таблицы
- по возможности избегать полного сканирования таблиц

Оптимизатор запросов старается переработать запрос, чтобы он выполнялся наиболее эффективным, он может переставить условные конструкции местами чтобы задействовался индекс, если есть возможность вычислить значения заранее если можно получить результаты из индексов оптимизатор это сделет. Ряд оптимизаций зависит от разработчика, чем меньше данных возвращает запрос тем лучше. Усиленный сбор, ответ быстрее пересылается по сети это косается и количества возвращаемых запросом строк и данных в столбцах. Если из всей таблицы нам надо 2-3 столбца не следует извлекать все данные с помощью `*`  в `SELECT(*)` запросе лучше выбрать конкретные столбцы
```
mysql> SELECT * FROM users;
mysql> SELECT id, name FROM users;
```
запрос на извлечение всех строк менее эффективен, чем извлечение только части таблицы
```
mysql> SELECT id, name FROM users LIMIT 2;
```
Столбцы типа `VARCHAR` и `NULL` значения хронятся в специальной области для данных переменной длины. Эти данные обрабатываются менее эффективно, чем данные фиксированной длины. например `INT`, поэтому если не должно быть `NULL` значения сразу указывать в настройках столбца `NOT NULL`. Медленнее всех типов данных `BLOB` и `TEXT` т.к хронятся отдельно от всех столбцов таблицы операции с этими данными часто используют жёсткий диск

Основной способ узнать какие решения принимает оптимизатор это воспользоваться командой `EXPLANE`
```
mysql> SELECT id, name FROM catalogs ORDER BY id;
mysql> EXPLAIN SELECT id, name FROM catalogs ORDER BY id\G
-->
*************************** 1. row ***************************
            id: 1
   select_type: SIMPLE
         table: catalogs
    partitions: NULL
          type : index
possible_keys: NULL
           key: PRIMARY
       key_len: 8
           ref: NULL
          rows: 5
      filtered: 100.00
         Extra: NULL
1 row in set, 1 warning (0.52 sec)
```
MySQL помечает этот запрос специальным флагом по мере выполнения запроса флаг заставит сервер сообщать информацию о каждом шаге выполнения, а не исполнять его для каждой встречающейся в запросе таблице выводится одна строка. Если соединяются 2 таблицы будет выведено 2 строки
```
mysql> EXPLAIN SELECT id, name FROM catalogs UNION ALL SELECT id, name FROM catalogs\G
-->
*************************** 1. row ***************************
            id: 1
   select_type: SIMPLE
         table: catalogs
    partitions: NULL
          type : index
possible_keys: NULL
           key: PRIMARY
       key_len: 8
           ref: NULL
          rows: 5
      filtered: 100.00
         Extra: NULL
1 row in set, 1 warning (0.52 sec)

mysql> EXPLAIN SELECT id, name FROM catalogs UNION ALL SELECT id, name FROM catalogs\G

-->
*************************** 1. row ***************************
            id: 1
   select_type: PRIMARY
         table: catalogs
    partitions: NULL
          type : ALL
 possible_keys: NULL
           key: NULL
       key_len: NULL
           ref: NULL
          rows: 5
      filtered: 100.00
         Extra: NULL
*************************** 2. row ***************************
            id: 2
   select_type: UNION
         table: catalogs
    partitions: NULL
          type : ALL
possible_keys: NULL
           key: NULL
       key_len: NULL
           ref: NULL
          rows: 5
      filtered: 100.00
         Extra: NULL
2 rows in set, 1 warning (0.13 sec)
```
Команда `EXPLAIN` применима только для `SELECT` запроса для исследования других команд их надо привести к `SELECT` запросу прежде, потом применять `EXPLAIN`

Результат команды `EXPLAIN` всегда состоит из одних и тех же столбцов изменяется лишь количество и содержимое строк
- `select_type:` показывает соответствует ли строка простому или составному `SELECT` запросу
- `table:` к какой таблице относится данная строка
- `type :` метод доступа к таблице, как SQL будет искать строки в таблице
- `type : ALL` - будет полное сканирование таблицы, просмотреть таблицу от начала до конца чтобы найти нужную строку

### Метод доступа type:
- `ALL`
- `index`
- `range`
- `ref`
- `eq_ref`
- `const`
- `NULL`

Запросы с ключевым словом `LIMIT`. MySQL прекратит перебор строк, как будет наброно необходимое количество записей

- `index` - полное сканирование таблицы в порядке, который задаётся индексом
- `range` - просмотр в диапазоне индекса. Сканирование индекса. Часто встречается в случае `BETWEEN` условий или операций меньше и больше

Индекс зачастую находится в оперативной памяти и значения индекса отсортированы. Данные часто нахходятся на жёстком диске. Методы `ALL`, `INDEX` обращаются к данным таблицы метод `RANGE` работает с индексом данные которые в индексе достаточны для выполнения операции.

- `ref`, - `eq_ref`  доступ по индексу возвращаются строки соотвествующие единственно заданному значению
- `const` какую то часть запроса можно преобразовать к константе
- `NULL` субд сумела завершить запрос на стадии оптимизации
- `possible_keys:` какие индексы можно было бы задействовать для выполнения запроса, сколько бы индексов не было создано в запросе можно задействовать только один индекс
- `key:` сюда помещается выбранный оптимизатором индекс
- `key_len:` сколько байт индекса используется mysql, например может использоваться лишь часть составного индекса, это поле позволяет сориентироваться какая часть индекса используется
- `ref:` какие столбцы и константы из предыдущих таблиц используются для поиска в индексе
- `rows:` сколько строк нужно прочитать, чтобы найти запрошенные данные
- `filtered:` сколько строк удовлетворяет критерию выборки
- `Extra:` дополнительная информация

### Дополнительные сведения `Extra`
- `Using index` (будут использоваться покрывающие индексы)
- `Using where` (сервер производит дополнительную фильтрацию строк отобранных подсистемой хронения)
- `Using temporary` (применение временной таблицы для сортировки результата запроса)
- `Using filesort` (обычная сортировка для упорядочания результата не читается таблица в порядке который задаётся индексом)
