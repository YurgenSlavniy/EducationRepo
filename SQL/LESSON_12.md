# Урок 12

# Оптимизация в хранении данных
- нормализация
- денормализация
# Оптимизация производительности
- настройка конфигов
- оптимизация запросов БД

Мы стараемся привести наши базы к третьей нормальной форме, чтобы у нас были ключики на каждую сущность реального мира, чтобы у нас была табличка, первичные ключи, внешние ключи, индексы, связи, никакого дублирования данных. Но бывают случаи, когда есть смысл отказаться от строгих требований третей нормальной формы в пользу более простых требований второй нормальной формы.

Например пользователи когда листают ленту новостей, вроде это как простое действие, но при этом сайт выводит пользователю разные посты и новости - эти посты (аудио, видео, картинки, текст) из таблички `media` нашей базы `vk` мы выводим данные в определённом порядке. Запрос на чтение данных. Мы читаем эти медиа `SELECT` запросом и выводим разные даннные и эта ситуация осложняется одним нью ансом. С каждым постом мы должны отображать количество лайков, которое этот пост насобирал. А это значит данных из таблицы `media` нам будет недостаточно, мы в своё время позаботились о связи между media и таблицей `likes`. Мы можем сделать `JOIN`, объединить эти 2 таблицы и получить нужные данные. Нам надо будет:
-  сделать `JOIN`, 
- потом группировку - `GROUP BY`
- после группировки подсчитываем - `COUNT(*)` агригирующую функцию

Это всё относительно трудоёмкие задачи т.е их выполнятьдороже чем не выполнять. Обращаться к одной таблице всегда дешевле, чем обращаться к двум, даже если это мы делаем по внешнему ключу.

Рассмотрим некоторые оптимизации, некоторые изменения в структуре наших данных, которые помогут несколько взбодрить наш сервер.
Первое что сделать - добавить колонку `likes_count` в таблицу `media` информация о количестве лайков у нас в принципе уже есть - эта величина вычисляется запрсами. Хотим чтобы это поле было не вычисляемым, а значение в нём хоронилось постоянно. Это значит, что когда пользователь ставит лайк, то в таблицу `likes` добавлялась новая запись. А теперь нам надо, чтобы эта запись из таблицы `likes` пересчитались лайки и добавились в таблицу `media` во вновь созданную колонку, причём пересчёт лайков нужно будет делать либо триггером, либо хронимой процедурой - это будет означать транзакцию.

Выигрыш который мы получим он кроется в том, что при выводе новостей мы сможем избавиться от всех `JOIN, GROUP BY, COUNT(*)`

### вопрос:
А действительно ли мы получим прирост производительности? 

Чтение ленты новостей производится в разы, а то и в десятки раз чем проставление лайков, пользователи листают новости чаще, чем ставят лайки. Мы ускорили частые действия, упростили а более редкую операцию чуть усложнили, но в общем в среднем время улучшилось, ускорилось. Мы отошли от третьей нормальной формы, мы допустили избыточность данных, решили не пользоаться связями между таблицами.

Для этого нужно знать хорошо мат часть, и понимать, как устроен проект для которого все это делается. Часто в нагруженных системах принебрегают точностью ради скорости.

# ОПТИМИЗАЦИЯ ПРОИЗВОДИТЕЛЬНОСТИ
Какой то запрос работает медленно. Нам надо его отловить, проанализировать и исправить. Потом проверить действительно ли мы всё починили. Здесь нужно уметь настраивать mysql или другую субд. Есть мнение специалистов, что mysql с настройками по умолчанию очень нерациональна. А дальше разбираться с инструментами, которые есть для оптимизации запросов.

# НАСТРОЙКИ КНФИГОВ
Настройки лежат в файле `my.cnf` или `my.ini` в случае с `windows`. Относительно оптимизации рассморим 2 категори настроек:
1) логи медленных запросов. Например:`log-slow-queries=/logs/slow_queries.log` в её настройках пишем абсолютный путь к файлу в который мы хотим складывать медленные запросы. Если мы вводим такое понятие как медленный запрос, то нужно его определить. Что считать медленным запросом? По этому поводу есть ещё одна натсройка `long_query_time=5` (учитыватьтолько запросы, выполняющиеся более 5 секунд). Если запрос не укладывается в 5 секунд, мы его считаем медленным и будем логировать в `/logs/slow_queries.log` (куда указали в настройках) строчка в настройках `log-queries-not-using-indexes=1` (логгировать запросы, не использующие индексы) 1 - да, 0 - нет. Если запрос, который даже уложился в 5 сек. Не использовал индексы, а настройка `log-queries-not-using-indexes=1`, то всё равно надо залогировать в `/logs/slow_queries.log` - это позволяет нам обнаружить 2 самые популярные ошибки.

на простом примерчике:
```
mysql> SELECT *
	FROM vk.communities
	WHERE name = 'community 1';
```
Этот запрос скорее всего не будет использовать индекс и его можно будет обнаружить в `/logs/slow_queries.log`, потому что фильтрация происходит по полю name и из этого мы можем выловить 2 потенциальные ошибки:

2) человек который писал запрос ошибся и написал по полю `name`, а надо было писать по `id`
```
mysql> SELECT *
	FROM vk.communities
	WHERE id = 1;
```
3) человек написал правильный запрос, но это означает что ошибся и не предусмотрел такую ситуацию архитектор бд т.е забыли индекс наложть на поле `name`, если обнаружим этот запрос в логах, сможем поправить ситуацию

# НАСТРОЙКИ КАСАЮЩИЕСЯ КЭШа
Не надо кэшировать всё подряд! Кэш лучше использовать, когда данные чаще читаются, чем пишутся. Чтобы менять настройки кэша на сервере есть настройки:
- `query_cache_size=0` - размер кэша
- `query_cache_limit=1M` - максимальный размер кэшируемого запроса

Она задаёт максимальный размер для конкретного запроса, можем использовать:
- `M` - мегабайты, 
- `G` - гигобайты, 
- `K` - килобайты

`query_cache_type=0` (OFF - отключает кэширование. `DEMAND` - кэширование будет производиться, только при наличии дерективы `SQL_CACHE` в запросе. ON - включает кэширование). Эта настройка меняет тип кэширования `DEMAND` - кэширование по требованию. Мы передаём управление кэшированием вызывающей стороне, обычно принимает решение надо ли кэшировать запрос sql сервер. Благодоря настройке `DEMAND` мы отдаём решение на откуп тому, кто обратился к базе. (веб сервер, мабильное приложение и т.д.). Если в запросе присутствует деректива `SQL_CACHE`, то запрос надо кэшировать. При выставленной настройке `query_cache_type=DEMAND` инверсия зависимости. Эта настройка как раз позволяет эту инверсию зависимости реализовать передаём управление кэшированием взывающей стороне.

# практические примеры.
`В DBeaver` откроем табличку `likes`: `ЛП -> Databases -> vk -> tables -> likes` ЛКМ 2 раза . открывается 3 вкладки. Нас интересует вкладка свойства `(properties)`, рассмотрм пример, будто проектировщики не учли некоторые моменты, в рабочем окне свойства находим внешние ключи и открываем, удалим внений ключ с поля `media_id`, `CTRL + S`, у нас появляется запрос.
```
mysql> ALTER TABLE vk.likes DROP FOREIGN KEY likes_ibfk_2;
```
Открываем индексы `(indexes)`  и удаляем с этого же поля индекс
```
mysql> ALTER TABLE vk.likes DROP INDEX media_id;
```
В результате связь между таблицами `vk.likes и vk.media` пропала к нам набежали пользователи и нагенерировали массу лайков, запускаем запрос на генерацию 30 000 лайков
```
mysql> SELECT COUNT(*) FROM likes;
```
Посчитаем лайки. 30 000 показывает счёт. После этого мы настроили наш сервер, чтобы он собирал логи и допустим в логах мы обнаружили запрос:
```
-- список медиафайлов пользователя с количеством лайков
mysql> SELECT
	media.filename,
	media_types.name,
	COUNT(*) AS total_likes,
	CONCAT(firstname, ' ', lastname) AS owner,
	hometown
	FROM media
	JOIN media_types ON media.media_type_id = media_types.id
	JOIN likes ON media.id = likes.media_id
	JOIN users ON users.id = media.user_id
	JOIN profiles ON users.id = profiles.user_id
	WHERE users.id = 1
	GROUP BY media.id;
```
Данный запрос исполняется 600ms много это или мало?

Проанализируем условия в которых выполнялся этот запрос
- во первых сервер находится без нагрузки не было такого, что запрос пришёл на сервер и ждал пока исполнится, потому что там была очередь
- у нас не было издержек на транспортировку данных, запрос исполнился на том же самом сервере, где мы его написали. запросу не пришлось путешествовать с машины на сервер, а потом обратно с сервера, гнать весь массив данных на машину
- на нашем сервере данных очень мало в реальных бд десятки миллионов строчек в таблицах

 __Делаем вывод__: 600ms это неприемлимо много! мы его условно говоря отловили в логах, давайте мы его будем чинить. У нас для этого есть инструмент команда `EXPLAIN`
```
#   mysql> EXPLAIN
#   mysql> SELECT
#       ->  media.filename,
#       ->  media_types.name,
#       ->  COUNT(*) AS total_likes,
#       ->  CONCAT(firstname, ' ', lastname) AS owner,
#       ->  hometown
#       -> FROM media
#       ->  JOIN media_types ON media.media_type_id = media_types.id
#       ->  JOIN likes ON media.id = likes.media_id
#       ->  JOIN users ON users.id = media.user_id
#       ->  JOIN profiles ON users.id = profiles.user_id
#       -> WHERE users.id = 1
#       -> GROUP BY media.id;
```
Исполнив, мы получаем новую странненькую таблицу, которая на первый взгляд никак не связана с предыдущей, которая получалась в нашем запросе. `EXPLAIN` работает с командами `SELECT`, `DELETE`, `INSERT`, `REPLACE` and `UPDATE (CRUD)` работает со всем набором `CRUD` команд

КОМАНДА `EXPLAIN` возвращает нам несколько строк, где каждая строка это информация о деталях присоединения той или иной таблицы, учавствующей в запросе. В нашем заросе учавствует 5 таблиц `media, media_types, likes, users, profiles`, поэтому в `EXPLAIN` 5 строк вывелось, каждая строчка содержит информацию про конкретную таблицу

- колонка `table`: отображает имя таблицы можно смотреть документацию по команде `EXPLAIN`
```
8.8.2 EXPLAIN Output Format
7.4 Visual EXPLAIN Plan
```
разбираемся с тем, что нам `EXPLAIN` возвращает
- колонка `id`. первая колоночка, значение в этой колонке означает условную глубину вложенности конкретной таблицы в общем запросе. У нас везде 1. это означает, что у нас нет вложенных запросов у нас везде используются плоские `JOIN` и больше ничего в этом запросе
- колонка `select_type`. у нас везде значеие `SIMPLE`. В техдокументации можно найти таблицу со значением всех колонок. Есть табличка в котрой написаны возможные значения для колонки `select_type` `SIMPLE` обозначает обыкновенный `JOIN`
- колонка `table`. Содержит имя таблицы о которой в строке идёт речь
- колонка `partitions`. Мы их не использовали у нас везде `NULL`
- колонка `type`. Здесь есть значения, которые могут подсказать о подозрительных местах в нашем запросе
- `const` - это хорошее значение
- `eq_ref` - это хорошее знчение
- `ALL` - это плохое значение

Всё это можно подсмотреть на страничке тех. документации `Visual EXPLAIN Plan`  там есть соответствующая табличка `ALL` означает полное сканирование таблицы. Это значение `ALL` напротив таблицы `like`, которую мы до этого немного поломали убрав индексы и связи, она нам нужна, чтобы подсчитать `COUNT(*) AS total_likes`, чтобы получить каждое значение субд пробегала по всей таблице `likes` каждый раз от начала до конца. а это 30 000 записей.

ОДИН ПОДОЗРИТЕЛЬНЫЙ МОМЕНТ ОБНАРУЖЕН
- колонка `possible_keys`
- колонка `key_len`
- колонка `key`

Содержат информацию о ключах
- `possible_keys` - возможные ключи которые могли быть использованы при обращении к таблице
- `key` - выбранный ключ из возможных
- `key_len` - длина ключа, если в этих колонках нет значения - это плохо.Мы видим `NULL` в таблице `likes`
- колонка `ref`. Схожа по значению с предыдущими нул. Есть значение хорошо, нет значения - плохо
- колонка `rows`. Среднее количество строк, которое пробегала субд чтобы получить нужное значение. В каждой строке результирующего набора
- колонка `filtered`. Содержит значение в процентах от 1 до 100, которое обозначает количество строк, которые нам понадобились по отношению к тому количеству которое мы затронули. Чем ближе к 100 тем лучше
- колонка `extra`. Может содержать дополнительную информацию об использовании например временных таблиц, ключей, условий `WHERE`.

Пробежали по `EXPLAIN` запросу, обратили внимание что таблица `likes` требует внимания

Графический план исполнения запроса есть в бесплатном `mysql workbench` и есть в платном `DBeaver`. После исполнения запроса в workbench листаем вниз поле с исполненным запросом и выведенной таблицей и справа на панелях видим `EXECUTION PLANE`, где схематически нарисованно как исполнялся запрос, изображается в графическом виде на нижнем ярусе цветные прямоугольники, которые представляют собой таблички, которые участвовали в запросе. 5 таблиц учавствовало, 5 прямоугольников есть, цвет прямоугольника имеет значение. Есть голубые, зелёные, красные, значимость цветов можно посмотреть в тех. документации `7.4 Visual EXPLAIN Plan`. В графической схеме запроса та же информация, что была в табличном виде `EXPLAIN` ромбиками обозначаются `JOIN`. 4 ромбика  -  4 JOIN в запросе, группировка обозначается прямоугольником со скругленными углами, конечный результат - серый прямоугольник. В настройках отображения может стоять
- `Tabular Explain` - табличное отображение
- `Visual Explain` - графическое отображение

Всеми доступными способами мы убедились что таблица `like` требует оптимизации.

# таблица `like` используется у нас в запросе в этм месте
```
#       ->  JOIN likes ON media.id = likes.media_id
```
# присоединям мы её по полю `likes.media_id`
# а на `media_id` нет ни индекса ни внешнего ключа
# вернём индекс:
```
#   mysql> ALTER TABLE likes ADD INDEX (media_id);
```
# вернём внешний ключ:
```
#   mysql> ALTER TABLE likes ADD FOREIGN KEY (media_id) REFERENCES media(id);
```
Запрос исполняется некоторое время. Несколько секунд. Дело в том что когда добавляется внешний ключ на таблицу в которой уже есть какие то данные, то для всех существующих данных выполняется проверка в данном случае, что поле `media_id` в таблице `likes` на корректность данных полю `id` в таблице media, куда она ссылается у нас 30000 записей и все эти записи надо поверить и если бы хоть одна из них содержала бы некорректные данные, то мы бы не смогли добавить внешний ключ, поэтому так долго исполняется запрос.

Снова исполняем наш `EXPLAIN` и смотрим что же поменялось.
Колонка `type` - теперь значение `ref`. было `ALL`, колонка `possible_keys, key` - появились ключи, по которым можно собирать данные. было `NULL`, колонка `rows` теперь значение `1` . т.е мы с первого раза получаем нужную строку. Время запроса - 6мс вместо 600мс

# О КУРСОВОМ ПРОЕКТЕ.

Это набор sql скриптов присылаемых в текстовых файлах с расширением sql


1) составить общее текстовое описание БД и решаемых ею задач. В свободной форме 3-5 предложений. общее о чём проект
2) минимальное количество таблиц 10. На примере кинопоиск. проект про фильмы которые выходили, выходят, про отзывы, рейтинги, киносеансы и т.д. какие таблички можно придумать для кинопоиска?
  - список фильмов (названия, дата, страна ...)
  - жанры (с помощью жанров можно реализовать разный функционал)
  - киноличности (актёры, режесёрры, фамилии)
  - фильмографии (связь многие ко многим. между личностями и фильмами)
  один и тот же актёр снялся во множестве фильмов
  в одном фильме снялось множество актёров
  - трейлеры (к одному фильму может быть много трейлеров)
  связь один фильм ко многим трейлерам
  - пользователи (на сайте регестрируются пользователи)
  - рейтинги (связь многие ко многим. между пользователями и фильмами)
  - избранные фильмы (закладки пользователей)
  - рецензии (текст, дата, пользователь, лайки дизлайки чтобы оценивать
  - кинотеатры (локации, сеансы, время, цены, билеты)

  Монитизация. Можно продавать билеты, брать себе комиссию, тип WIN - WIN . когда всем хорошо:
- кинотеатрам - новый канал прихода посетителей
- пользователям - удобный для них способ купить билет
- проекту хорошо - он монитизирован
3) скрипты создания структуры БД (с первичными ключами, индексами, внешними ключами) DDL код. поля, типы данных, создание таблиц
4) создать ERDiagram для бд. Создать самому, что мы знаем что такое эта диаграмма, что на ней отображается и как ей пользоваться прислать её в виде скриншота. в DBeaver есть кнопочка скриншота (нижняя панель) либо пункт меню. файли -> сохранить как можно диаграмму из workbench .mwb файл
5) Скрипты наполнения БД данными речь о дампе. INSERT INTO команды важный пункт пользоваться пакетной вставкой данных
6) скрипты характерных выборок (включающие группировки, JOINы, вложенные таблицы) здесь думаем о том какие задачи решает проект
7) представления (минимум 2), сохранить несколько запросов как представления для примера можно посмотреть представления (Views) в учебной базе sakila. Для примера кинопоиск можно выбрать следующий вариант, например кассовые сборы. Это таблица фильмы объединёная с показами в кино (таблица кинотеатры) сгруппированная по айдишнику фильма и просуммированной выручкой за билеты. Ещё одно полезное представление - сегодня в кино фильмы, которые совпадают с локацией пользователя и дата которых сегодня. В этой выборке важно ориентироваться на географию пользователя. Следующая выборка - самые ожидаемые фильмы, фильмы которые ещё не вышли, сгруппированные например с рейтингами и посчитанным средним баллом. Могут быть упорядоченными по баллам и топ 5 например взяли
8) хранимые процедуры, триггеры, функции что нибудь одно из этого в курсовом проекте

Для кинопоиска например реализовать: предлагать индивидуальные рекомендации по фильмам взять топ 3 из любимого жанра, смешать с топ 3 с любимым актёром, режиссёром и с топ 3 по абсолютному рейтингу. Всё это вместе смиксовать и выдать топ 5 ресурсы по БД

### Рекомендации по дальнейшему обучению БД:
- Список литературы в комментариях к 1 уроку.
- Канал Mail.ru Технострим: https://www.youtube.com/user/TPMGTU
- Канал конференции Highload: https://www.youtube.com/user/profyclub
- Канал компании Percona: https://www.youtube.com/user/PerconaMySQL

### Документация по теме:
- Файл конфигурации: https://dev.mysql.com/doc/refman/8.0/en/option-files.html
- Команда EXPLAIN: https://dev.mysql.com/doc/refman/8.0/en/explain-output.html
- План исполнения запроса в Workbench: https://dev.mysql.com/doc/workbench/en/wb-performance-explain.html

### Explain. План исполнения запросов.
- https://dev.mysql.com/doc/workbench/en/wb-performance-explain.html
- https://dev.mysql.com/doc/employee/en/employees-introduction.html
