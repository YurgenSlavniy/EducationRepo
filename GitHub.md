# Обучающие материалы по GitHub:
https://learngitbranching.js.org/?locale=ru_RU 

______________________________________________
# Основы.
______________________________________________
## Введение
Хорошо подобранное введение в основные команды git
### 1: Знакомство с Git Commit
Коммит в git репозитории хранит снимок всех файлов в директории. Почти как огромная копия, только лучше

Git пытается быть лёгким и быстрым насколько это только возможно, так что он не просто слепо копирует всю директорию каждый раз, а ужимает (когда это возможно) коммит в набор изменений или «дельту» между текущей версией и предыдущей.

Также Git хранит всю историю о том, когда какой коммит был сделан. Вот почему большинство коммитов имеют предков - мы указываем на предков стрелками при визуализации. Поддержка истории коммитов более чем важна для всех, кто работает над проектом!

Можно ещё долго рассказывать о коммитах, но для простоты будем считать их полными снимками проекта. Коммиты очень легки, так что переключение между ними происходит предельно быстро!

Посмотрим, как это выглядит на практике. Справа расположена визуализация небольшого git репозитория. Сейчас в нём два коммита: первый, исходный коммит С0 и один коммит С1 после него, содержащий изменения.

Нажми на кнопку, чтобы совершить коммит

> $ git commit 

Отлично. Мы только что внесли изменения в репозиторий и сохранили их как коммит. У коммита, который мы только что сделали, есть родитель, С1, который указывает на предыдущий коммит.
______________________________________________
Пора попробовать! После того, как это окно закроется, сделай два коммита, чтобы пройти этот уровень.

> $ git commit 

> $ git commit 
______________________________________________

### 2: Ветвление в Git
Ветки в Git, как и коммиты, невероятно легковесны. Это просто ссылки на определённый коммит — ничего более. Вот почему многие фанаты Git повторяют мантру: __"делай ветки сразу, делай ветки часто"__. 
Так как создание множества веток никак не отражается на памяти или жестком диске, удобнее и проще разбивать свою работу на много маленьких веток, чем хранить все изменения в одной огромной ветке.

Чуть позже мы попробуем использовать ветки и коммиты, и вы увидите, как две эти возможности сочетаются. Можно сказать, что созданная ветка хранит изменения текущего коммита и всех его родителей.

Посмотрим, что такое ветки на практике

Создадим здесь новую ветку с именем newImage.

> git branch newImage

Вот и всё, ребята! Ветка newImage теперь указывает на коммит C1.

Теперь попробуем сделать некоторые изменения в этой ветке. Для этого нажми кнопку ниже.

> git commit

О-оу! Ветка main сдвинулась, тогда как ветка newImage - нет! Всё из-за того, что мы не переключились на новую ветку, а остались в старой, о чём говорит звёздочка около ветки main.

Сообщим Git, что хотим выбрать ветку _git checkout [name]_ 
Эта команда перенесёт нас на новую ветку в момент, когда мы ещё не коммитили изменения

> git checkout newImage

> git commit

Вот так! Наши изменения записаны уже в новую ветку

______________________________________________
Ну что ж, теперь ты готов к работе с ветками. Как только это окно закроется, создай ветку с именем bugFix и переключись на неё.

Кстати вот тебе совет, ты можешь создать новую ветку и переключиться на неё с помощью одной команды: _git checkout -b [yourbranchname]._

> git checkout -b bugFix 

или 

> git branch bugFix

> git checkout bugFix

> git commit
______________________________________________

### 3: Слияния веток в Git
Ок! Мы уже знаем, как создавать ветки и коммитить наши изменения. Теперь надо понять, как объединять изменения из двух разных веток. Очень удобно создать ветку, сделать свою часть работы в ней и потом объединить изменения из своей ветки с общими.

Первый способ объединения изменений, который мы рассмотрим - _это git merge_ - слияние или просто мердж. Слияния в Git создают особый вид коммита, который имеет сразу двух родителей. Коммит с двумя родителями обычно означает, что мы хотим объединить изменения из одного коммита с другим коммитом и всеми их родительскими коммитами.

Слишком запутанно =) На схеме всё проще и понятнее.

Вот у нас две ветки, каждая содержит по одному уникальному коммиту. Это означает, что ни одна из веток не содержит полный набор "работ", выполненных в этом репозитории. Можно исправить эту ситуацию, выполнив слияние.

Мы сделаем merge ветки bugFix в ветку main.

> git merge bugFix

Что мы видим? Во-первых, ветка main теперь указывает на коммит, у которого два родителя. Если проследовать по стрелкам от этого коммита, вы пройдёте через каждый коммит в дереве прямиком к началу. Это означает, что теперь в ветке main содержатся все изменения репозитория.

Во-вторых, обрати внимание, как изменились цвета коммитов. Мы ввели цветовую дифференциацию, чтобы помочь пониманию. У каждой ветки — свой цвет. Каждый коммит становится того цвета, какого его ветка. Если в нём изменения сразу двух веток - он становится цветом, смешанным из цветов родительских веток.

И вот мы видим, что цвет ветки main подмешан к каждому коммиту, а ветки bugFix - нет. Это можно поправить.

Смерджим ветку main в ветку bugFix.

> git checkout bugFix
 
> git merge main

Так как ветка bugFix была предшественницей main, Git не делал ничего, только сдвинул bugFix на тот же коммит, где находится main

Теперь все коммиты одного цвета, что означает, что каждая ветка содержит все изменения репозитория! Поздравляем!

______________________________________________
Чтобы пройти этот уровень, сделай следующее:

Создай новую ветку под названием bugFix

Переключись на новую ветку bugFix командой git checkout bugFix

Сделай один коммит

Вернись на ветку main при помощи git checkout

Сделай ещё один коммит

Слей ветку bugFix с веткой main при помощи git merge

Если что-то пошло не так - можешь подглядеть в эту шпаргалку командой "objective"!*

> git branch bugFix

> git checkout bugFix

> git commit

> git checkout main

> git commit 

> git merge bugFix
______________________________________________


### 4: Введение в rebase
Второй способ объединения изменений в ветках - это rebasing. При ребейзе Git по сути копирует набор коммитов и переносит их в другое место.

Несмотря на то, что это звучит достаточно непонятно, преимущество rebase в том, что c его помощью можно делать чистые и красивые линейные последовательности коммитов. История коммитов будет чище, если вы применяете rebase.

Посмотрим, как это работает..

У нас здесь снова две ветки. Обрати внимание, что выбрана ветка bugFix (отмечена звёздочкой)

Хочется сдвинуть наши изменения из bugFix прямо на вершину ветки main. Благодаря этому всё будет выглядеть, как будто эти изменения делались последовательно, хотя на самом деле - параллельно.

Применим git rebase.

> git rebase main

Супер! Теперь изменения из bugFix находятся в конце ветки main и являют собой линейную последовательность коммитов.

Обрати внимание, что коммит С3 до сих пор существует где-то, а С3' - это его "копия" в ветке main

Единственная проблема - ветка main не обновлена до последних изменений. Это легко исправить.

Вот мы выбрали ветку main. Вперёд - сделаем rebase на bugFix.

> git rebase bugFix

Вуаля! Так как main был предком bugFix, git просто сдвинул ссылку на main вперёд.

______________________________________________

Чтобы пройти этот уровень, сделай следующее:

Переключись на ветку bugFix
Сделай коммит
Вернись на main и сделай коммит ещё раз
Переключись на bugFix и сделай rebase на main
Удачи!

> git checkout bugFix

> git commit

> git checkout main

> git commit

> git checkout bugFix

> git rebase main

______________________________________________

## Едем дальше
Следующая порция абсолютной git-крутотенюшки. Проголодались?
### 1: Теряем голову, или detached HEAD
### 2: Относительные ссылки (^)
### 3: Относительные ссылки №2
### 4: Отмена изменений в Git
## Перемещаем труды туда-сюда
Не стесняйтесь менять историю
### 1: Введение в Cherry-pick
### 2: Введение в интерактивный Rebase
## Сборная солянка
Ассорти из приёмов работы с Git, хитростей и советов
### 1: Выберем один коммит.
### 2: Жонглируем коммитами
### 3: Жонглируем коммитами №2
### 4: git tag
### 5: Git describe
## Продвинутый уровень
Если ты смелый, ловкий, умелый – потренируйся тут
### 1: Rebase over 9000 раз
### 2: Здоровая семья, или несколько родителей
### 3: Спутанные ветки

______________________________________________
# Удалённые репозитории.
______________________________________________
## Push & Pull - удалённые репозитории в Git!
Настало время поделиться своими единичками и нулями. Время коллективного программирования
### 1: Введение в клонирование
### 2: Удалённые ветки
### 3: Git fetch
### 4: Git pull
### 5: Коллективная работа
### 6: Git push
### 7: Расхождение в истории
### 8: Заблокированная ветвь main
##  Через origin – к звёздам. Продвинутое использование Git Remotes
Весело было быть всесильным мудрым правителем...
### 1: Push Мастер!
### 2: Слияние с удалённым репозиторием
### 3: Слежка за удалённым репозиторием
### 4: Аргументы git push
### 5: Аргументы для push -- расширенная версия!
### 6: Аргументы для fetch
### 7: Пустой источник
### 8: Аргументы для pull
