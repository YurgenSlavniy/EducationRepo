1) c:\django> source .venv\Scripts\activate.bat - активация виртуальной среды
2) c:\django> cd project_name - переходим в сзданный проект
3) c:\django\project_name> python manage.py runserver - запуск сервера

# Представления и маршрутизация #
## 2.1 Обработка запроса ##
Центральным моментом любого веб-приложения является обработка запроса, который отправляет пользователь. В Django за обработку запроса отвечают представления или views. По сути представления представляют функции обработки, которые принимают данные запроса в виде объекта HttpRequest из пакета django.http и генерируют некоторый результат, который затем отправляется пользователю.

По умолчанию представления размещаются в приложении в файле views.py.

Например, возьмем стандартный проект, в который добавлено приложение (например, проект созданный в прошлой главе).

При создании нового проекта файл views.py имеет следующее содержимое:
```Python
views.py
___________________
from django.shortcuts import render
# Create your views here.
```
Данный код пока никак не обрабатывает запросы, он только импортирует функцию render(), которая может использоваться для обработки.

Генерировать результат можно различными способами. Один из них представляет использование класса HttpResponse из пакета django.http, который позволяет отправить текстовое содержимое.

Так, изменим файл views.py следующим образом:
```Python
views.py
___________________
from django.http import HttpResponse
  
def index(request):
    return HttpResponse("Главная")
 
def about(request):
    return HttpResponse("О сайте")
 
def contact(request):
    return HttpResponse("Контакты")
```
В данном случае определены три функции, которые будут обрабатывать запросы. Каждая функция принимает в качестве параметра request объект HttpRequest, который хранит информацию о запросе. Однако в данном случае они нам не нужны, поэтому параметр никак не используется. Для генерации ответа в конструктор объекта HttpResponse передается некоторая строка. Это может быть в том числе и код html в виде строки.

Чтобы эти функции сопоставлялись с запросами, надо определить для них маршруты в проекте в файле urls.py. В частности, изменим этот файл следующим образом:
```Python
urls.py
___________________
from django.urls import path
from hello import views
 
urlpatterns = [
    path('', views.index),
    path('about', views.about),
    path('contact', views.contact),
]
```

Переменная urlpatterns определяет набор сопоставлений функций обработки с определенными строками запроса. Например, запрос к корню веб-сайта будет обрабатываться функцией index, запрос по адресу "about" будет обрабатываться функцией about, а запрос "contact" - функцией contact.

Запустим проект и обратимся по некоторым из этих адресов.
```Адресная строка браузера
127.0.1.8000
```
```Адресная строка браузера
127.0.1.8000/about
```
```Адресная строка браузера
127.0.1.8000/contact
```

При этом мы можем отправлять не простой текст, а, например, код html, который затем интерпретируется браузером. Так, изменим файл views.py следующим образом:
```Python
views.py
___________________
from django.http import HttpResponse
  
def index(request):
    return HttpResponse("<h2>Главная</h2>")
 
def about(request):
    return HttpResponse("<h2>О сайте</h2>")
 
def contact(request):
    return HttpResponse("<h2>Контакты</h2>")
```
Соответственно теперь браузер получит код html

## 2.2 Определение маршрутов и функции path и re_path ## 
В прошлой теме рассматривалось сопоставление адресов URL и функций, которые обрабатывают запросы по этим адресам. Например, у нас есть следующие функции в файле views.py:
```Python
views.py
___________________
from django.http import HttpResponse
  
def index(request):
    return HttpResponse("<h2>Главная</h2>")
 
def about(request):
    return HttpResponse("<h2>О сайте</h2>")
 
def contact(request):
    return HttpResponse("<h2>Контакты</h2>")
```
Это так называемые функции-представления или view function. И в файле urls.py проекта они сопоставляются с адресами URL с помощью функции path():
```Python
urls.py
___________________
from django.urls import path
from hello import views
 
urlpatterns = [
    path('', views.index),
    path('about', views.about),
    path('contact', views.contact),
]
```
За сопоставление путей и функций-представлений отвечает функция path(), которая располагается в пакете django.urls и которая принимает четыре параметра:
```python
path(route, view, kwargs=None, name=None)
```
1) route: представляет шаблон адреса URL, которому должен соответствовать запрос

2) view: функция-представление, которое обрабатывает запрос

3) kwargs: дополнительные аргументы, которые передаются в функцию-представление

4) name: название маршрута

В примере выше применялись только первые два параметра, которые являются обязательными: запрошенный адрес URL и функция, которая обрабатывает запрос по этому адресу. Дополнительно через третий параметр можно указать имя маршрута:
```python
path('', views.index, name='home'),
```
В данном случае маршрут будет называться "home".

## re_path ##
Хотя мы можем успешно применять функцию path() для определения маршрутов, она довольно ограничена по своему действию. Запрошенный путь должен в точности соответствовать указанному в маршруте адресу URL. Так, в примере выше, что функция views.about могла обрабатывать запрос, адрес должен быть в точности "about". Например, стоит нам указать слеш в конце: "about/" и django уже не сможет сопоставить путь с запросом.

В качестве альтернативы для определения маршрутов мы можем использовать функцию re_path(), которая также располагается в пакете django.urls и имеет тот же набор параметров:
```python
re_path(route, view, kwargs=None, name=None)
```
Ее преимущесто состоит в том, что она позволяет задать адреса URL с помощью регулярных выражений.

Например, изменим определение файла urls.py следующим образом:
```Python
urls.py
___________________
from django.urls import path, re_path
from hello import views
 
urlpatterns = [
    path('', views.index),
    re_path(r'^about', views.about),
    re_path(r'^contact', views.contact),
]
```
Адрес в первом маршруте по-прежнему образуется с помощью функции path и указывает на корень веб-приложения.

Остальные два маршрута образуются с помощью функции re_path(). Причем, поскольку определяется регуляное выражение, то перед строкой с шаблоном адреса URL ставится буква r. В самом шаблоне адреса можно использовать различные элементы синтаксиса регулярных выражений. В частности, выражение ^about указывает, что адрес должен начинаться с "about". Однако он необязательно в точности должен соответствовать строке "about", как это было в случае с функцией path.

Например, мы можем обратиться по любому адресу, главное чтобы он начинался с "about", и тогда подобный запрос будет обрабатываться функцией views.about.
```Адресная строка браузера
127.0.1.8000/about/hello
```
Всё отработает и мы увидим отоброжение 
```
"<h2>О сайте</h2>"
```
с отработкой всех html тегов.

## Очередность маршрутов ##
Когда запрос приходит к приложению, то система проверяет соответствие запроса маршрутам по мере их определения: вначале сравнивается первый маршрут, если он не подходит, то сравнивается второй и так далее. Поэтому более общие маршруты должны определяться в последнюю очередь, а более конкретные маршруты должны идти в начале. Например:
```Python
urls.py
___________________
from django.urls import path, re_path
from hello import views
 
urlpatterns = [
    re_path(r'^about/contact/', views.contact),
    re_path(r'^about', views.about),
    path('', views.index),
]
```
В данном случае адрес "^about/contact" представляет более конкретный маршрут по сравнению c "^about". Поэтому он определяется в первую очередь.

Если бы было наоборот:
```Python
urls.py
___________________
urlpatterns = [
    path('', views.index),
    re_path(r'^about', views.about),
    re_path(r'^about/contact', views.contact),
]
```
то запрос по адресу "about/contact" обрабатывался бы функцией views.about

## Основные элементы синтаксиса регуляных выражений ##
Некоторые базовые элементы регуляных выражений, которые можно использовать для определения адресов URL:

- ^(начало адреса)

- $(конец адреса)

- +(1 и более символов)

- ?(0 или 1 символ)

- {n}(n символов)

- {n, m}(от n до m символов)

- .(любой символ)

- \d+(одна или несколько цифр)

- \D+(одна или несколько НЕ цифр)

- \w+(один или несколько буквенных символов)

Рассмотрим несколько возможных сопоставлений шаблонов адресов и запросов:
```
Адрес               Запрос

r'^$'               http://127.0.0.1/ (корень сайта)

r'^about'           http://127.0.0.1/about/ или http://127.0.0.1/about/contact

r'^about/contact'   http://127.0.0.1/about/contact

r'^products/\d+/'   http://127.0.0.1/products/23/ или http://127.0.0.1/products/6459/abc Но не соответствует запросу http://127.0.0.1/products/abc/

r'^products/\D+/'   http://127.0.0.1/products/abc/ или http://127.0.0.1/products/abc/123 Не соответствует запросу http://127.0.0.1/products/123/ или http://127.0.0.1/products/123/abc

r'^products/phones|tablets/'     http://127.0.0.1/products/phones/1 или http://127.0.0.1/products/tablets/ Не соответствует запросу http://127.0.0.1/products/clothes/

r'^products/\w+'      http://127.0.0.1/products/abc/ или http://127.0.0.1/products/123/ Не соответствует запросу http://127.0.0.1/products/abc-123

r'^products/[-\w]+/'     http://127.0.0.1/products/abc-123

r'^products/[A-Z]{2}/'    http://127.0.0.1/products/RU Не соответствует запросам http://127.0.0.1/products/Ru или http://127.0.0.1/products/RUS
```

## Передача значений в функцию ##
Выше были рассмотрены все параметры функций path и re_path, кроме однаго - kwargs, который позволяет передать в функцию-представление некоторые значения. Например, в файле views.py определим следующие функции:
```Python
views.py
___________________
from django.http import HttpResponse
   
def index(request):
    return HttpResponse("<h2>Главная</h2>")
  
def about(request, name, age):
    return HttpResponse(f"""
            <h2>О пользователе</h2>
            <p>Имя: {name}</p>
            <p>Возраст: {age}</p>
    """)
```
Здесь функция about() также принимает два дополнительных параметра: name и age (условно имя и возраст пользователя). В функции их значения отправляются пользователю вместе с остальным содержимым.

Изменим файл urls.py:
```Python
urls.py
___________________
from django.urls import path
from hello import views
  
urlpatterns = [
    path('', views.index),
    path('about', views.about, kwargs={"name":"Tom", "age": 38}),
]
```
С помощью параметра kwargs в функцию about передается словарь с двумя значениями - для двух параметров функции. Соответственно при обращении к этой функции мы увидим в браузере соответствующие данные

## 2.3 Получение данных запроса. HttpRequest ##
Функции-представления в качестве обязательного параметра получают объект HttpRequest, который хранит информацию о запросе. HttpRequest определяет ряд атрибутов, которые хранят информацию о запросе. Выделим следующие из них:

- scheme: схема запроса (http или https)

- body: представляет тело запроса в виде строки байтов

- path: представляет путь запроса

- method: метод запроса (GET, POST, PUT и т.д.)

- encoding: кодировка

- content_type: тип содержимого запроса (значение заголовка CONTENT_TYPE)

- GET: объект в виде словаря, который содержит параметры запроса GET

- POST: объект в виде словаря, который содержит параметры запроса POST

- COOKIES: отправленные клиентом куки

- FILES: отправленные клиентом файлы

- META: хранит все доступные заголовки http в виде словаря. Набор заголовков зависит от клиента и сервера, некоторые из них:
```
- CONTENT_LENGTH: длина содержимого.
- CONTENT_TYPE: MIME-тип запроса.
- HTTP_ACCEPT: типы ответа, которые принимает клиент.
- HTTP_ACCEPT_ENCODING: кодировка, в которой клиент принимает ответ.
- HTTP_ACCEPT_LANGUAGE: язык ответа, который принимает клиент.
- HTTP_HOST: хост сервера.
- HTTP_REFERER: страница, с которой клиент отправил запрос (при ее наличии).
- HTTP_USER_AGENT: юзер-агент или информация о браузере клиента.
- QUERY_STRING: строка запроса.
- REMOTE_ADDR: IP-адрес клиента.
- REMOTE_HOST: имя хоста клиента.
- REMOTE_USER: аутентификационные данные клиента (при наличии)
- REQUEST_METHOD: тип запроса (GET, POST).
- SERVER_NAME: имя хоста сервера.
- SERVER_PORT: порт сервера.
```
- headers: заголовки запроса в виде словаря

Также HttpRequest определяет ряд методов. Отметим следующие из них:

- get_full_path(): возвращает полный путь запроса, включая строку запроса

- get_host(): возвращает хост клиента, для этого используется значения заголовков HTTP_X_FORWARDED_HOST (если включена опция USE_X_FORWARDED_HOST) и HTTP_HOST

- get_port(): возвращает номер порта

Например, получим некоторую информацию о запросе. Для этого в файле views.py:
```Python
views.py
___________________
from django.http import HttpResponse
 
def index(request):
    host = request.META["HTTP_HOST"] # получаем адрес сервера
    user_agent = request.META["HTTP_USER_AGENT"]    # получаем данные бразера
    path = request.path     # получаем запрошенный путь
     
    return HttpResponse(f"""
        <p>Host: {host}</p>
        <p>Path: {path}</p>
        <p>User-agent: {user_agent}</p>
    """)
```
В данном случае получаем два заголовка "HTTP_HOST" и "HTTP_USER_AGENT" и запрошенный путь.

В файле urls.py зарегистрируем данную функцию:
```Python
urls.py
___________________
from django.urls import path
from hello import views
 
urlpatterns = [
    path("index", views.index),
]
```
## 2.4 HttpResponse и отправка ответа ##
Для отправки ответа клиенту в Django применяется класс HttpResponse из пакета django.http. В общем случае для отправки некоторых данных достаточно эти данные передать в конструктор HttpResponse. Например, пусть в файле views.py имеется простейшая функция-представление, которая отправляет ответ клиенту:
```Python
views.py
___________________
from django.http import HttpResponse
 
def index(request):
    return HttpResponse("Hello")
```
И в файле urls.py эта функция соотносится с некоторым маршрутом:

```Python
urls.py
___________________
from django.urls import path
from hello import views
 
urlpatterns = [
    path("", views.index),
]
```
Подобная функция просто передает в HttpResponse некоторый текст, который пользователь затем увидит в браузере. Однако подобной функциональностью HttpResponse не ограничивается. Так, функция инициализации класса определяет несколько параметров:

```Puthon
HttpResponse.__init__(content=b'', content_type=None, status=200, reason=None, charset=None, headers=None)
```
Параметры:

- content: содержимое ответа в виде строки байтов. Если передается другое содержимое, то оно конвертируется в строку байтов

- content_type: MIME-тип ответа, устанавливает HTTP-заголовок Content-Type. Если этот параметр не установлен, то применяется mime-тип text/html и значение настройки DEFAULT_CHARSET, то есть в итоге будет: "text/html; charset=utf-8".

- charset: кодировка ответа в виде строки. По умолчанию django пытается установить кодировку из параметра content_type, а в случае неудачи для установки кодировки применяется настройка DEFAULT_CHARSET.

- status: статусный код ответа. По умолчанию равно 200

- reason_phrase: сообщение, которое отправляется в вместе статусным кодом

- headers: заголовки ответа в виде словаря

Для хранения отправляемых данных он определяет ряд атрибутов. Некоторые из них:

- content: содержимое ответа в виде строки байтов

- headers: отправляемые заголовки в виде словаря

- charset: кодировка ответа в виде строки. По умолчанию django пытается установить кодировку из заголовка content_type, а в случае неудачи для установки кодировки применяется настройка DEFAULT_CHARSET.

- status_code: статусный код ответа

- reason_phrase: сообщение, которое отправляется в вместе статусным кодом

Рассмотрим некоторые возможности. Например, изменим определение функции в файле views.py:
```Python
views.py
___________________
from django.http import HttpResponse
 
def index(request):
    return HttpResponse("Hello METANIT.COM", headers={"SecretCode": "21234567"})
```
В данном случае также устанавливается заголовок "SecretCode". Хотя в реальности в HTTP не существует такого заголовка, но мы можем определять кастомные заголовки, чтобы передать через них клиенту какую-нибудь информацию. Например, после обращения к функции мы можем в браузере через инструменты разработчика проинспектировать отправленные сервером заголовки и найти там в том числе заголовок "SecretCode".

Подобным образом можно установить другие параметры, например, статусный код и сообщение к нему:
```Python
views.py
___________________
from django.http import HttpResponse
 
def index(request):
    return HttpResponse("Произошла ошибка", status=400, reason="Incorrect data")
```

Установка содержимого и кодировки:
```Python
views.py
___________________
from django.http import HttpResponse
 
def index(request):
    return HttpResponse("<h1>Hello</h1>", content_type="text/plain", charset="utf-8")
```
Хотя в содержимом ответа применяются теги html "h1", но браузере теперь будет рассматривать это содержимое как простой текст, потому что установлен заголовок "text/plain"

## 2.5 Параметры представлений ##
Функции-представления могут принимать параметры, через которые могут передаваться различные данные. Подобные параметры передаются в адресе URL. Например, в запросе
```
http://127.0.0.1:8000/index/Tom/38/
```
последние два сегмента Tom/38/ могут представлять параметры URL, которые могут быть связанны с параметрами функции-представления через систему маршрутизации. Подобные параметры еще можно назвать параметрами маршрута

## Определение параметров через функцию path ##
Определим в файле views.py следующие функции:
```Python
views.py
___________________
from django.http import HttpResponse
   
def index(request):
    return HttpResponse("<h2>Главная</h2>")
  
def user(request, name):
    return HttpResponse(f"<h2>Имя: {name}</h2>")
```
В данном случае функция user имеет два параметра. Для второго параметра - name мы будем получать данные из строки запроса. То есть это будет параметр маршрута. И как любой другой параметр мы сможем использовать его внутри функции.

Далее в файле urls.py определим следующий код:
```Python
urls.py
___________________
from django.urls import path
from hello import views
  
urlpatterns = [
    path("", views.index),
    path("user/<str:name>", views.user),
]
```
Для второго маршрута здесь определен параметр name (который соответствует параметру name функции views.user). Параметры заключаются в угловые скобки в формате <спецификатор:название_параметра>. Например, здесь параметр name имеет спецификатор str.

По умолчанию Django предоставляет следующие спецификаторы:

- str: соответствует любой строке за исключенем символа "/". Если спецификатор не указан, то используется по умолчанию

- int: соответствует любому положительному числу

- slug: соответствует последовательности буквенных символов ASCII, цифр, дефиса и символа подчеркивания, например, building-your-1st-django-site

- uuid: сооветствует идентификатору UUID, например, 075194d3-6885-417e-a8a8-6c931e272f00

- path: соответствует любой строке, которая также может включать символ "/" в отличие от спецификатора str

Также отмечу, что количество и название параметров в шаблонах адресов URL соответствуют количеству и названиям параметров соответствующих функций, которые обрабатывают запросы по данным адресам.

Запустим приложение, обратимся к функции views.user, например, с помошью запроса http://127.0.0.1:8000/user/Tom, и через строку запроса - через ее третий сегмент мы сможем передать значение для параметра name

Подобным образом можно определить и большее количество параметров. Например, добавим второй параметр в функцию user в views.py:
```Python
views.py
___________________
from django.http import HttpResponse
   
def index(request):
    return HttpResponse("<h2>Главная</h2>")
  
def user(request, name, age):
    return HttpResponse(f"<h2>Имя: {name}  Возраст:{age}</h2>")
```
А в файле urls.py добавим в маршрут параметр age:
```Python
urls.py
___________________
from django.urls import path
from hello import views
  
urlpatterns = [
    path("", views.index),
    path("user/<name>/<int:age>", views.user),
]
```
Предполагается, что параметр age будет представлять число, поэтому для него используется спецификатор int. В этом случае мы можем обратиться к функции user, например, с помощью запроса
```
http://127.0.0.1:8000/user/Tom/38
```
В этом случае сегмент "/Tom/" будет сопоставлен с параметром name, а "/38" - с параметром age.

## Значения для параметров по умолчанию ##
В примере выше использовались два параметра, но что, если мы не передадим для одного или обоих параметров значения?

В этом случае мы получим ошибку. Параметры маршрута являются частью шаблона URL. Соответственно если в строке запроса не передаются значения для параметров, такой запрос не соответствует маршруту. Поэтому Django не сможет найти нужный маршрут для обработки запроса, и мы получим ошибку 404 (ресурс не найден).

Однако такое поведение не всегда может быть желательным. И мы можем задать для параметров маршрута значения по умолчанию на случай, если через строку запроса не передаются значения. Так, для функции user в views.py определим значения для параметров по умолчанию:
```Python
views.py
___________________
from django.http import HttpResponse
   
def index(request):
    return HttpResponse("<h2>Главная</h2>")
  
def user(request, name="Undefined", age =0):
    return HttpResponse(f"<h2>Имя: {name}  Возраст: {age}</h2>")
```
В данном случае, если для параметра name не передается значение, то он получает в качестве значения строку "Undefined". Для параметра age значение по умолчанию 0.

В этом случае для функции user в файле urls.py надо определить дополнительные маршруты, которые не учитывают необязательные параметры:

```Python
urls.py
___________________
from django.urls import path
from hello import views
  
urlpatterns = [
    path("", views.index),
    path("user", views.user),
    path("user/<name>", views.user),
    path("user/<name>/<int:age>", views.user),
]
```
## Определение параметров через функцию re_path ##
Подобным образом мы можем использовать функцию re_path для определения параметров. Определим в приложении в файле views.py следующие функции:
```Python
views.py
___________________
from django.http import HttpResponse
   
def index(request):
    return HttpResponse("<h2>Главная</h2>")
  
def user(request, name, age):
    return HttpResponse(f"<h2>Имя: {name}  Возраст: {age}</h2>")
```
Теперь изменим файл urls.py, чтобы он мог сопоставить данные функции с запросами:
```Python
urls.py
___________________
from django.urls import path, re_path
from hello import views
  
urlpatterns = [
    path("", views.index),
    re_path(r"^user/(?P<name>\D+)/(?P<age>\d+)", views.user),
]
```
Для представления параметра в шаблоне адреса используется выражение ?P<>. Общее определение параметру соответствует формату (?P<имя_параметра>регулярное_выражение). Между угловыми скобками помещается название параметра. После закрывающей угловой скобки идет регулярное выражение, которому дожно соответствовать значение параметра.

Во втором шаблоне адреса определяются два параметра: name и age. При этом параметр age должен представлять число, а параметр name должен состоять только из буквенных символов.

Теперь мы можем через адресную строку передать данные в приложение:
```
127.0.0.1/user/Bob/45
```
Также мы можем указать для определенных параметров значения по умолчанию:
```Python
def user(request, name="Undefined", age =0):
    return HttpResponse(f"<h2>Имя: {name}  Возраст: {age}</h2>")
```
В этом случае надо дополнительно определить еще маршруты в файле urls.py для тех запросов, в которых не передаются значения для маршрутов:
```Python
urls.py
___________________
from django.urls import path, re_path
from hello import views
  
urlpatterns = [
    path("", views.index),
    re_path(r"^user/(?P<name>\D+)/(?P<age>\d+)", views.user),
    re_path(r"^user/(?P<name>\D+)", views.user),
    re_path(r"^user", views.user),
]
```
Обратите внимание на порядок размещения маршрутов: в отличие от случая с функцией path теперь сначала размещаются более конкретные маршруты с большим количеством параметров.
 
## 2.6 Вложенные маршруты и функция include ##
Функция include() позволяет определить вложенные маршруты или подмаршруты для неокторого маршрута. В качестве параметра она принимает набор маршрутов:
```
include(pattern_list)
```
Параметр pattern_list представляет набор вызовов функций path() и/или re_path(). Например, определеим в файле views.py следующие функции:
```Python
views.py
___________________
from django.http import HttpResponse
 
def index(request):
    return HttpResponse("Главная страница")
 
def products(request):
    return HttpResponse("Список товаров")
 
def new(request):
    return HttpResponse("Новые товары")
 
def top(request):
    return HttpResponse("Наиболее популярные товары")
```
Здесь последние три функции функционально относятся к товарам.

И определим в файле urls.py следующие маршруты:
```Python
urls.py
___________________
from django.urls import path, include
from hello import views
  
product_patterns = [
    path("", views.products),
    path("new", views.new),
    path("top", views.top),
]
 
urlpatterns = [
    path("", views.index),
    path("products/", include(product_patterns)),
]
```
Здесь в виде переменной product_patterns отдельно определен набор маршрутов, который касается товаров.

Для установки этих маршрутов этот список передается в функцию include()
```
path("products", include(product_patterns)),
```
Причем этот список будет ассоциирован с шаблоном "product". В этом случае шаблоны вложенных маршрутов будут объединены с шаблоном родительского маршрута, и таким образом будет сформирован общий шаблон, которому должен соответствовать запрос.

Например, если придет запрос "http://127.0.0.1:8000/products/top", то он будет обрабатываться функцией top.

Таким образом, мы можем сгруппировать маршруты для запросов, которые начинаются с определенного шаблона. Что также позволяет избежать повтора частей шаблона, когда шаблон url начинается с одного и того же сегмента.

## Получение параметров ##
Вложенные маршруты получают параметры, определенные в родительских маршрутах. Например, определим в файле views.py следующие функции-представления:
```Python
views.py
___________________
from django.http import HttpResponse
 
def index(request):
    return HttpResponse("Главная страница")
 
def products(request, id):
    return HttpResponse(f"Товар {id}")
 
def comments(request, id):
    return HttpResponse(f"Комментарии о товаре {id}")
 
def questions(request, id):
    return HttpResponse(f"Вопросы о товаре {id}")
```
Здесь все функции кроме первой имеют второй параметр - id - условный номер товара.

Изменим файл urls.py:
```Python
urls.py
___________________
from django.urls import path, include
from hello import views
 
product_patterns = [
    path("", views.products),
    path("comments", views.comments),
    path("questions", views.questions),
]
 
urlpatterns = [
    path("", views.index),
    path("products/<int:id>/", include(product_patterns)),
]
```
Здесь для второго маршрута определяется числовой параметр id. Этот параметр передается всем вложенным маршрутам, соответственно нам не надо определять данный параметр во вложенных маршрутах

## 2.7 Параметры строки запроса ## 
От параметров, которые передаются через адрес URL, следует отличать параметры, которые передаются через строку запроса. Например, в запросе
```
http://127.0.0.1:8000/index/3/Tom/
```
два последних сегмента 3/Tom/ представляют параметры URL или параметры маршрута. А в запросе
```
http://127.0.0.1:8000/index?id=3&name=Tom
```
те же самые значения 3 и Tom представляют параметры строки запроса.

Параметры строки запроса указывается после вопросительного знака ?. Каждый параметр предсталяет пару ключ-значение, напимер, в id=3 : id - название или ключ параметра, а 3 - его значение. Параметры в строке запроса отделяются друг от друга знаком амперсанда.

Для получения параметров из строки запроса применяется метод request.GET.get(), в которую передается название параметра.

Например, определим в файле views.py следующие функции:
```Python
views.py
___________________
from django.http import HttpResponse
   
def index(request):
    return HttpResponse("<h2>Главная</h2>")
  
def user(request):
    age = request.GET.get("age")
    name = request.GET.get("name")
    return HttpResponse(f"<h2>Имя: {name}  Возраст: {age}</h2>")
```
Функция user принимает извлекает из строки запроса два параметра: name и age.

В файле urls.py определим следующие маршруты:
```Python
urls.py
___________________
from django.urls import path
from hello import views
  
urlpatterns = [
    path("", views.index),
    path("user", views.user)
]
```
При обращении к приложению по адресу http://127.0.0.1:8000/user?name=Tom&age=22, параметр name будет иметь значение "Tom", а параметр age - 22.

Однако возможна ситуация, когда для каких-то параметров не будет передано значение. В этом случае мы можем указать для подобных параметров значение по умолчанию. Для этого изменим определение функции user в views.py:
```Python
views.py
___________________
from django.http import HttpResponse
   
def index(request):
    return HttpResponse("<h2>Главная</h2>")
  
def user(request):
    age = request.GET.get("age", 0)
    name = request.GET.get("name", "Undefined")
    return HttpResponse(f"<h2>Имя: {name}  Возраст: {age}</h2>")
```
Второй параметр функции request.GET.get() представляет значение по умолчанию для параметра, для которого не задано значение.

Соответвенно при обращении по адресу http://127.0.0.1:8000/user/ параметры name и age получат значения по умолчанию.

## 2.8 Переадресация и отправка статусных кодов ##
## Переадресация ##
При перемещении документа с одного адреса на другой мы можем воспользоваться механизмом переадресации, чтобы указать пользователям и поисковику, что документу теперь доступен по новому адресу.

Переадресация бывает временная и постоянная. При временной переадресации мы указываем, что документ временно перемещен на новый адрес. В этом случае в ответ отправляется статусный код 302. При постоянной переадресации мы уведомляем, что документ теперь постоянно будет достуен по новому адресу

Для создания временной переадресации применяется класс HttpResponseRedirect, а для постоянной - класс HttpResponsePermanentRedirect, которые расположены в пакете django.http.

Так, определим в файле views.py следующий код:
```Python
views.py
___________________
from django.http import HttpResponse, HttpResponseRedirect, HttpResponsePermanentRedirect
 
def index(request):
    return HttpResponse("Index")
 
def about(request):
    return HttpResponse("About")
 
def contact(request):
    return HttpResponseRedirect("/about")
 
def details(request):
    return HttpResponsePermanentRedirect("/")
````
При обращении к функции contact она будет перенаправлять по пути "about", который будет обрабатываться функцией about. А функция details будет использовать постоянную переадресацию и перенаправлять на корень веб-приложения.

И также в файле urls.py для тестирования определим следующие маршруты:
```Python
urls.py
___________________
from django.urls import path
from hello import views
  
urlpatterns = [
    path("", views.index),
    path("about/", views.about),
    path("contact/", views.contact),
    path("details/", views.details),
]
```
## Отправка статусных кодов ##
Также в пакете django.http есть ряд классов, которые позволяют отправлять определенный статусный код:
```
Статусный код                Класс

304 (Not Modified)          HttpResponseNotModified
400 (Bad Request)           HttpResponseBadRequest
403 (Forbidden)             HttpResponseForbidden
404 (Not Found)             HttpResponseNotFound
405 (Method Not Allowed)    HttpResponseNotAllowed
410 (Gone)                  HttpResponseGone
500 (Internal Server Error) HttpResponseServerError
```
В функцию конструктора этих классов можно передать некоторые данные, например, сообщение об ошибке, которое увидит пользователь:
```Python
HttpResponseNotModified()
HttpResponseBadRequest("Bad Request")
HttpResponseForbidden("Forbidden")
HttpResponseNotFound("Not Found")
HttpResponseNotAllowed("Method is not allowed")
HttpResponseGone("Content is no longer here")
HttpResponseServerError("Server Error")
```
Например, определим следующий файл views.py:
```Python
views.py
___________________
from django.http import HttpResponse, HttpResponseNotFound, HttpResponseForbidden, HttpResponseBadRequest
 
 
def index(request, id):
    people = ["Tom", "Bob", "Sam"]
    # если пользователь найден, возвращаем его
    if id in range(0, len(people)):
        return HttpResponse(people[id])
    # если нет, то возвращаем ошибку 404
    else:
        return HttpResponseNotFound("Not Found")
 
def access(request, age):
    # если возраст НЕ входит в диапазон 1-110, посылаем ошибку 400
    if age not in range(1, 111):
        return HttpResponseBadRequest("Некорректные данные")
    # если возраст больше 17, то доступ разрешен
    if(age > 17):
        return HttpResponse("Доступ разрешен")
    # если нет, то возвращаем ошибку 403
    else:
        return HttpResponseForbidden("Доступ заблокирован: недостаточно лет")
```
Функция index принимает параметр id. Это будет индекс элемента в списке people. Однако пользователь может передать и недействительный индекс, например, 100, хотя в примере в списке только 3 элемента. Поэтому, если передан действительный индекс, то возвращаем элемент по этому индексу. Если же индекс нейдествителен, то с помощью класса HttpResponseNotFound возвращаем ошибку 404 и сообщение об ошибке.

Аналогично функция access принимает параметр age, который представляет условный возвраст пользователя. Если возраст выходит за некоторые разумные пределы (1-110), то с помощью класса HttpResponseBadRequest возвращаем ошибку 400. Если возраст укладывается в эти рамки, но он меньше 18, то с помощью класса HttpResponseForbidden возвращаем ошибку 403 о том, что доступ запрещен.

Для теста в файле urls.py определим следующие маршруты:
```Python
urls.py
___________________
from django.urls import path
from hello import views
  
urlpatterns = [
    path("index/<int:id>", views.index),
    path("access/<int:age>", views.access),
]
```
Обратися к функции index, передав для параметра id корректные и некорректные значения. И в зависимости от значения параметра мы увидим либо данные из списка people, либо ошибку 404.

Аналогично при обращении по адресу "/access" в зависимости от значения параметра age мы увидим либо сообщения об ошибке, либо обычное сообщение.

Стоит отметить, что статусные сообщения об ошибках также отображаются в консоль запущенного приложения.

## 2.9 Отправка json ##

За отправку клиенту данных в формате JSON в Django отвечает специальный класс - JsonResponse, который по сути представляет подкласс HttpResponse. Основная особенность JsonResponse состоит в том, что при отправке данных он автоматически устанавливает для заголовка Content-Type (тип содержимого) значение application/json

Его конструктор принимает ряд параметров:
```python
def __init__(data, encoder=DjangoJSONEncoder, safe=True, json_dumps_params=None, **kwargs)
```
- data: отправляемые данные

- encoder: сериализатор, которые сериализует отправляемые данные в формат JSON. По умолчанию представляет тип django.core.serializers.json.DjangoJSONEncoder

- safe: представляет булевое значение. Если равно False, то сериализации подлежит любой объект. Если же равно True, то отправляемые данные должны представлять тип dict то есть словарь. По умолчанию равно True

- json_dumps_params: словарь аргументов, который передается в функцию json.dumps() для генерации ответа

Например, отправим какие-нибудь данные в формате JSON. Для этого определим в файле views.py следующий код:
```Python
views.py
___________________
from django.http import JsonResponse
 
def index(request):
    return JsonResponse({"name": "Tom", "age": 38})
```
В данном случае отправляется словарь с двумя элементами name и age. И при обращении в браузере к функции index мы увидим эти данные.

## Сериализация произвольных объектов ##
По умолчанию JsonResponse сериализует и отправляет только словари. Однако что, если мы хотим отправить объект какого-то своего типа? В этом случае необходимо определить класс-сериализатор, который будет содержать логику сериализации объекта в json. Например:
```Python
views.py
___________________
from django.http import JsonResponse
from django.core.serializers.json import DjangoJSONEncoder
 
def index(request):
    bob = Person("Bob", 41)
    return JsonResponse(bob, safe=False, encoder=PersonEncoder)
 
class Person:
  
    def __init__(self, name, age):
        self.name = name    # имя человека
        self.age = age        # возраст человека
 
class PersonEncoder(DjangoJSONEncoder):
    def default(self, obj):
        if isinstance(obj, Person):
            return {"name": obj.name, "age": obj.age}
            # return obj.__dict__
        return super().default(obj)
```
В данном случае JsonResponse отправляет объект типа Person, у которого определены два атрибута: name и age.

Объект Person не является словарем, поэтому параметр safe имеет значение False. Кроме того, параметр encoder указывает на сериализатор, который будет сериализовать данные в json. В данном случае это класс PersonEncoder.

Класс сериализатора наследуется от django.core.serializers.json.DjangoJSONEncoder. Он реализует метод default, который возвращает сериализованный объект. В частности, в этом методе сначала проверяем, представляет ли параметр объект Person. И если представляет, то возвращаем словарь из значений атрибутов объекта

```python
return {"name": obj.name, "age": obj.age}
```
Стоит отметить, что в данном случае мы можем просто возвратить представление объекта в виде словаря

```python
return obj.__dict__
```
Однако в отдельных ситуациях может потребоваться более тонкая настройка сериализации.

Если же объект не представляет тип Person, то передаем его в реализацию метода default родительского класса.

## 2.10 Отправка и получение кук ##
Куки представляют самый простой способ сохранить данные пользователя. Куки хранятся на компьютере пользователя и могут устанавливаться как на сервере, так и на клиенте. Так как куки посылаются с каждым запросом на сервер, то их максимальный размер ограничен 4096 байтами. Рассмотрим, как отправить клиенту и получить от клиента куки в приложении на Django.

## Установка куки ##
За установку куки и отправку их клиенту отвечает метод set_cookie() класса HttpResponse. Этот метод имеет следующую сигнатуру:
```python
set_cookie(key, value='', max_age=None, expires=None, path='/', domain=None, secure=False, httponly=False, samesite=None)
```
Параметры метода:

- key: ключ или имя куки

- value: значение куки

- max_age: максимальное время жизни куки в секундах. Это может быть либо объект timedelta, либо число, либо значение None (ограничивает время жизни куки текущей сессией браузера, является значением по умолчанию).

- expires: время и дата, когда истекает действие куки. Должен представлять строку в формате "Wdy, DD-Mon-YY HH:MM:SS GMT" или объект datetime.datetime

- path: путь, для которого устанавливаются куки

- domain: домен, к которому применяются куки

- secure: устанавливает используемый протокол. Так, если имеет значение True, то куки будут посылаться на сервер только в запросе по протоколу https

- httponly: устанавлиет доступность для скриптов javascript на клиенте. Так, значение httponly=True предотвращает доступ к куки из кода javascript на клиенте
samesite: устанавливает разрешения на отправку куки в кроссдоменных запросах. Так, значения samesite='Strict' и samesite='Lax' указывают браузеру не посылать куки в кроссдоменных запросах. Значение по умолчанию samesite='None' разрешает отправку куки в кроссдоменных запросах

Также класс HttpResponse предоставляет еще один метод для установки кук:
```python
set_signed_cookie(key, value, salt='', max_age=None, expires=None, path='/', domain=None, secure=False, httponly=False, samesite=None)
```
Данный метод принимает те же параметры, его отличие в том, что он применяет шифрование. Необязательный параметр salt позволяет задать соль для шифрования.

Например, установим куки. Пусть в файле views.py имеется следующая функция:
```Python
views.py
___________________
from django.http import HttpResponse
 
# установка куки
def set(request):
    # получаем из строки запроса имя пользователя
    username = request.GET.get("username", "Undefined")
    # создаем объект ответа
    response = HttpResponse(f"Hello {username}")
    # передаем его в куки
    response.set_cookie("username", username)
    return response
```
Из строки запроса получаем значение параметра "username" и передаем его в куки по одноименному ключу

Пусть в файле urls.py эта функция вызывается в запросе по пути "/set":
```Python
urls.py
___________________
from django.urls import path
from hello import views
  
urlpatterns = [
    path("set", views.set),
]
```
Обратимся к по адресу "/set", передав через строку запроса параметр username, и сервер установит куки, а браузер сохранит их. И мы сможем их увидеть через инструменты разработчика.

## Получение куки ##
Если куки не шифрованные, то для их получения у объекта HttpRequest можно использовать атрибут COOKIES, который представляет словарь.

Если куки шифрованные методом set_signed_cookie, то для их получения в классе HttpRequest применяется метод
```python
get_signed_cookie(key, default=RAISE_ERROR, salt='', max_age=None)
```
Параметры метода:

- key: ключ куки, которые надо получить

- default: значение по умолчанию, если куки с указанным ключом отсутствуют в запросе

- max_age: максимальное время жизни куки в секундах

- salt: соль шифрования, должен иметь то же самое значение, которое передавалось в set_signed_cookie

Например, получим ранее установленные куки по ключу. Определим в файле views.py дополнительную функцию get():
```Python
views.py
___________________
from django.http import HttpResponse
 
# установка куки
def set(request):
    # получаем из строки запроса имя пользователя
    username = request.GET.get("username", "Undefined")
    response = HttpResponse(f"Hello {username}")
    # передаем его в куки
    response.set_cookie("username", username)
    return response
 
# получение куки
def get(request):
    # получаем куки с ключом username
    username = request.COOKIES["username"]
    return HttpResponse(f"Hello {username}")
```
С помощью выражения request.COOKIES["username"] получаем куки по ключу "username" и передаем их значение в ответ клиенту.

Пусть в файле urls.py эта функция вызывается в запросе по пути "/get":
```Python
urls.py
___________________
from django.urls import path
from hello import views
  
urlpatterns = [
    path("set", views.set),
    path("get", views.get),
]
```
Обратимся к по адресу "/get" и получим ранее установленную куку username.
