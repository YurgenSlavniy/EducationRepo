# Представления и маршрутизация #
## Обработка запроса ##
Центральным моментом любого веб-приложения является обработка запроса, который отправляет пользователь. В Django за обработку запроса отвечают представления или views. По сути представления представляют функции обработки, которые принимают данные запроса в виде объекта HttpRequest из пакета django.http и генерируют некоторый результат, который затем отправляется пользователю.

По умолчанию представления размещаются в приложении в файле views.py.

Например, возьмем стандартный проект, в который добавлено приложение (например, проект созданный в прошлой главе).

При создании нового проекта файл views.py имеет следующее содержимое:
```Python
views.py
___________________
from django.shortcuts import render
# Create your views here.
```
Данный код пока никак не обрабатывает запросы, он только импортирует функцию render(), которая может использоваться для обработки.

Генерировать результат можно различными способами. Один из них представляет использование класса HttpResponse из пакета django.http, который позволяет отправить текстовое содержимое.

Так, изменим файл views.py следующим образом:
```Python
views.py
___________________
from django.http import HttpResponse
  
def index(request):
    return HttpResponse("Главная")
 
def about(request):
    return HttpResponse("О сайте")
 
def contact(request):
    return HttpResponse("Контакты")
```
В данном случае определены три функции, которые будут обрабатывать запросы. Каждая функция принимает в качестве параметра request объект HttpRequest, который хранит информацию о запросе. Однако в данном случае они нам не нужны, поэтому параметр никак не используется. Для генерации ответа в конструктор объекта HttpResponse передается некоторая строка. Это может быть в том числе и код html в виде строки.

Чтобы эти функции сопоставлялись с запросами, надо определить для них маршруты в проекте в файле urls.py. В частности, изменим этот файл следующим образом:
```Python
urls.py
___________________
from django.urls import path
from hello import views
 
urlpatterns = [
    path('', views.index),
    path('about', views.about),
    path('contact', views.contact),
]
```

Переменная urlpatterns определяет набор сопоставлений функций обработки с определенными строками запроса. Например, запрос к корню веб-сайта будет обрабатываться функцией index, запрос по адресу "about" будет обрабатываться функцией about, а запрос "contact" - функцией contact.

Запустим проект и обратимся по некоторым из этих адресов.
```Адресная строка браузера
127.0.1.8000
```
```Адресная строка браузера
127.0.1.8000/about
```
```Адресная строка браузера
127.0.1.8000/contact
```

При этом мы можем отправлять не простой текст, а, например, код html, который затем интерпретируется браузером. Так, изменим файл views.py следующим образом:
```Python
views.py
___________________
from django.http import HttpResponse
  
def index(request):
    return HttpResponse("<h2>Главная</h2>")
 
def about(request):
    return HttpResponse("<h2>О сайте</h2>")
 
def contact(request):
    return HttpResponse("<h2>Контакты</h2>")
```
Соответственно теперь браузер получит код html

## Определение маршрутов и функции path и re_path ## 
В прошлой теме рассматривалось сопоставление адресов URL и функций, которые обрабатывают запросы по этим адресам. Например, у нас есть следующие функции в файле views.py:
```Python
views.py
___________________
from django.http import HttpResponse
  
def index(request):
    return HttpResponse("<h2>Главная</h2>")
 
def about(request):
    return HttpResponse("<h2>О сайте</h2>")
 
def contact(request):
    return HttpResponse("<h2>Контакты</h2>")
```
Это так называемые функции-представления или view function. И в файле urls.py проекта они сопоставляются с адресами URL с помощью функции path():
```Python
urls.py
___________________
from django.urls import path
from hello import views
 
urlpatterns = [
    path('', views.index),
    path('about', views.about),
    path('contact', views.contact),
]
```
За сопоставление путей и функций-представлений отвечает функция path(), которая располагается в пакете django.urls и которая принимает четыре параметра:
```python
path(route, view, kwargs=None, name=None)
```
1) route: представляет шаблон адреса URL, которому должен соответствовать запрос

2) view: функция-представление, которое обрабатывает запрос

3) kwargs: дополнительные аргументы, которые передаются в функцию-представление

4) name: название маршрута

В примере выше применялись только первые два параметра, которые являются обязательными: запрошенный адрес URL и функция, которая обрабатывает запрос по этому адресу. Дополнительно через третий параметр можно указать имя маршрута:
```python
path('', views.index, name='home'),
```
В данном случае маршрут будет называться "home".

## re_path ##
Хотя мы можем успешно применять функцию path() для определения маршрутов, она довольно ограничена по своему действию. Запрошенный путь должен в точности соответствовать указанному в маршруте адресу URL. Так, в примере выше, что функция views.about могла обрабатывать запрос, адрес должен быть в точности "about". Например, стоит нам указать слеш в конце: "about/" и django уже не сможет сопоставить путь с запросом.

В качестве альтернативы для определения маршрутов мы можем использовать функцию re_path(), которая также располагается в пакете django.urls и имеет тот же набор параметров:
```python
re_path(route, view, kwargs=None, name=None)
```
Ее преимущесто состоит в том, что она позволяет задать адреса URL с помощью регулярных выражений.

Например, изменим определение файла urls.py следующим образом:
```Python
urls.py
___________________
from django.urls import path, re_path
from hello import views
 
urlpatterns = [
    path('', views.index),
    re_path(r'^about', views.about),
    re_path(r'^contact', views.contact),
]
```
Адрес в первом маршруте по-прежнему образуется с помощью функции path и указывает на корень веб-приложения.

Остальные два маршрута образуются с помощью функции re_path(). Причем, поскольку определяется регуляное выражение, то перед строкой с шаблоном адреса URL ставится буква r. В самом шаблоне адреса можно использовать различные элементы синтаксиса регулярных выражений. В частности, выражение ^about указывает, что адрес должен начинаться с "about". Однако он необязательно в точности должен соответствовать строке "about", как это было в случае с функцией path.

Например, мы можем обратиться по любому адресу, главное чтобы он начинался с "about", и тогда подобный запрос будет обрабатываться функцией views.about.
```Адресная строка браузера
127.0.1.8000/about/hello
```
Всё отработает и мы увидим отоброжение 
```
"<h2>О сайте</h2>"
```
с отработкой всех html тегов.

## Очередность маршрутов ##
Когда запрос приходит к приложению, то система проверяет соответствие запроса маршрутам по мере их определения: вначале сравнивается первый маршрут, если он не подходит, то сравнивается второй и так далее. Поэтому более общие маршруты должны определяться в последнюю очередь, а более конкретные маршруты должны идти в начале. Например:
```Python
urls.py
___________________
from django.urls import path, re_path
from hello import views
 
urlpatterns = [
    re_path(r'^about/contact/', views.contact),
    re_path(r'^about', views.about),
    path('', views.index),
]
```
В данном случае адрес "^about/contact" представляет более конкретный маршрут по сравнению c "^about". Поэтому он определяется в первую очередь.

Если бы было наоборот:
```Python
urls.py
___________________
urlpatterns = [
    path('', views.index),
    re_path(r'^about', views.about),
    re_path(r'^about/contact', views.contact),
]
```
то запрос по адресу "about/contact" обрабатывался бы функцией views.about

## Основные элементы синтаксиса регуляных выражений ##
Некоторые базовые элементы регуляных выражений, которые можно использовать для определения адресов URL:

- ^(начало адреса)

- $(конец адреса)

- +(1 и более символов)

- ?(0 или 1 символ)

- {n}(n символов)

- {n, m}(от n до m символов)

- .(любой символ)

- \d+(одна или несколько цифр)

- \D+(одна или несколько НЕ цифр)

- \w+(один или несколько буквенных символов)

Рассмотрим несколько возможных сопоставлений шаблонов адресов и запросов:
```
Адрес               Запрос

r'^$'               http://127.0.0.1/ (корень сайта)

r'^about'           http://127.0.0.1/about/ или http://127.0.0.1/about/contact

r'^about/contact'   http://127.0.0.1/about/contact

r'^products/\d+/'   http://127.0.0.1/products/23/ или http://127.0.0.1/products/6459/abc Но не соответствует запросу http://127.0.0.1/products/abc/

r'^products/\D+/'   http://127.0.0.1/products/abc/ или http://127.0.0.1/products/abc/123 Не соответствует запросу http://127.0.0.1/products/123/ или http://127.0.0.1/products/123/abc

r'^products/phones|tablets/'     http://127.0.0.1/products/phones/1 или http://127.0.0.1/products/tablets/ Не соответствует запросу http://127.0.0.1/products/clothes/

r'^products/\w+'      http://127.0.0.1/products/abc/ или http://127.0.0.1/products/123/ Не соответствует запросу http://127.0.0.1/products/abc-123

r'^products/[-\w]+/'     http://127.0.0.1/products/abc-123

r'^products/[A-Z]{2}/'    http://127.0.0.1/products/RU Не соответствует запросам http://127.0.0.1/products/Ru или http://127.0.0.1/products/RUS
```

## Передача значений в функцию ##
Выше были рассмотрены все параметры функций path и re_path, кроме однаго - kwargs, который позволяет передать в функцию-представление некоторые значения. Например, в файле views.py определим следующие функции:
```Python
views.py
___________________
from django.http import HttpResponse
   
def index(request):
    return HttpResponse("<h2>Главная</h2>")
  
def about(request, name, age):
    return HttpResponse(f"""
            <h2>О пользователе</h2>
            <p>Имя: {name}</p>
            <p>Возраст: {age}</p>
    """)
```
Здесь функция about() также принимает два дополнительных параметра: name и age (условно имя и возраст пользователя). В функции их значения отправляются пользователю вместе с остальным содержимым.

Изменим файл urls.py:
```Python
urls.py
___________________
from django.urls import path
from hello import views
  
urlpatterns = [
    path('', views.index),
    path('about', views.about, kwargs={"name":"Tom", "age": 38}),
]
```
С помощью параметра kwargs в функцию about передается словарь с двумя значениями - для двух параметров функции. Соответственно при обращении к этой функции мы увидим в браузере соответствующие данные

## Получение данных запроса. HttpRequest ##
Функции-представления в качестве обязательного параметра получают объект HttpRequest, который хранит информацию о запросе. HttpRequest определяет ряд атрибутов, которые хранят информацию о запросе. Выделим следующие из них:

- scheme: схема запроса (http или https)

- body: представляет тело запроса в виде строки байтов

- path: представляет путь запроса

- method: метод запроса (GET, POST, PUT и т.д.)

- encoding: кодировка

- content_type: тип содержимого запроса (значение заголовка CONTENT_TYPE)

- GET: объект в виде словаря, который содержит параметры запроса GET

- POST: объект в виде словаря, который содержит параметры запроса POST

- COOKIES: отправленные клиентом куки

- FILES: отправленные клиентом файлы

- META: хранит все доступные заголовки http в виде словаря. Набор заголовков зависит от клиента и сервера, некоторые из них:
```
- CONTENT_LENGTH: длина содержимого.
- CONTENT_TYPE: MIME-тип запроса.
- HTTP_ACCEPT: типы ответа, которые принимает клиент.
- HTTP_ACCEPT_ENCODING: кодировка, в которой клиент принимает ответ.
- HTTP_ACCEPT_LANGUAGE: язык ответа, который принимает клиент.
- HTTP_HOST: хост сервера.
- HTTP_REFERER: страница, с которой клиент отправил запрос (при ее наличии).
- HTTP_USER_AGENT: юзер-агент или информация о браузере клиента.
- QUERY_STRING: строка запроса.
- REMOTE_ADDR: IP-адрес клиента.
- REMOTE_HOST: имя хоста клиента.
- REMOTE_USER: аутентификационные данные клиента (при наличии)
- REQUEST_METHOD: тип запроса (GET, POST).
- SERVER_NAME: имя хоста сервера.
- SERVER_PORT: порт сервера.
```
- headers: заголовки запроса в виде словаря

Также HttpRequest определяет ряд методов. Отметим следующие из них:

- get_full_path(): возвращает полный путь запроса, включая строку запроса

- get_host(): возвращает хост клиента, для этого используется значения заголовков HTTP_X_FORWARDED_HOST (если включена опция USE_X_FORWARDED_HOST) и HTTP_HOST

- get_port(): возвращает номер порта

Например, получим некоторую информацию о запросе. Для этого в файле views.py:
```Python
views.py
___________________
from django.http import HttpResponse
 
def index(request):
    host = request.META["HTTP_HOST"] # получаем адрес сервера
    user_agent = request.META["HTTP_USER_AGENT"]    # получаем данные бразера
    path = request.path     # получаем запрошенный путь
     
    return HttpResponse(f"""
        <p>Host: {host}</p>
        <p>Path: {path}</p>
        <p>User-agent: {user_agent}</p>
    """)
```
В данном случае получаем два заголовка "HTTP_HOST" и "HTTP_USER_AGENT" и запрошенный путь.

В файле urls.py зарегистрируем данную функцию:
```Python
urls.py
___________________
from django.urls import path
from hello import views
 
urlpatterns = [
    path("index", views.index),
]
```

