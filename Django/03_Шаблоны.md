# Шаблоны #
## Создание и использование шаблонов ##
Шаблоны (templates) отвечают за формирование внешнего вида приложения. Они предоставляют специальный синтаксис, который позволяет внедрять данные в код HTML.

Допустим, у нас есть проект metanit, и в нем определено одно приложение - hello.

Настройка функциональности шаблонов в проекте Django производится в файле settings.py. с помощью переменной TEMPLATES. Так, по умолчанию переменная TEMPLATES в файле settings.py имеет следующее определение:
```python
settings.py
_______________________
TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]
```
Данная переменная принимает список конфигураций для каждого движка шаблонов. По умолчанию определена одна конфигурация, которая имеет следующшие параметры

- BACKEND: движок шаблонов. По умолчанию применяется встроенный движок django.template.backends.django.DjangoTemplates

- DIRS: определяет список каталогов, где движок шаблонов будет искать файлы шаблонов. По умолчанию пустой список

- APP_DIRS: указывает, будет ли движок шаблонов искать шаблоны внутри папок приложений в папке templates.

- OPTIONS: определяет дополнительный список параметров

Итак, в конфигурации по умолчанию параметр APP_DIRS имеет значение True, а это значит, что движок шаблонов будет также искать нужные файлы шаблонов в папке приложения в каталоге templates. То есть по умолчанию мы уже имеем настроенную конфигурацию, готовую к использованию шаблонов. Теперь определим сами шаблоны.

Добавим в папку приложения каталог templates. А в нем определим файл index.html:

Далее в файле index.html определим следующий код:
```
index.html
_______________________
<!DOCTYPE html>
<html>
<head>
    <title>Django на METANIT.COM</title>
    <meta charset="utf-8" />
</head>
<body>
    <h2>Hello METANIT.COM</h2>
</body>
</html>
```
По сути это обычная веб-страница, которая содержит код html. Теперь используем эту страницу для отправки ответа пользователю. И для этого перейдем в приложении hello к файлу views.py, который определяет функции для обработки запроса. Изменим этот файл следующим образом:
```python
views.py
_______________________
from django.shortcuts import render
 
def index(request):
    return render(request, "index.html")
```
Из модуля django.shortcuts импортируется функция render.

Функция index вызывает функцию render, которой передаются объект запроса request и путь к файлу шаблона в рамках папки templates "index.html".

В файле urls.py проекта пропишем сопоставление функции index с запросом к корню веб-приложения:
```python
urls.py
_______________________
from django.urls import path
from firstapp import views
 
urlpatterns = [
    path("", views.index),
]
```

И запустим проект на выполнение и перейдем к приложению в браузере (если проект запущен, то его надо перезапустить)

Подобным образом можно указать и другие шаблоны. Например, в папку templates добавим еще две страницы: about.html и contact.html 

И также в файле views.py определим функции, которые используют данные шаблоны:
```python
views.py
_______________________
from django.shortcuts import render
 
def index(request):
    return render(request, "index.html")
 
def about(request):
    return render(request, "about.html")
 
def contact(request):
    return render(request, "contact.html")
```
А в файле urls.py свяжем функции с маршрутами:
```python
urls.py
_______________________
from django.urls import path
from hello import views
 
urlpatterns = [
    path("", views.index),
    path("about/", views.about),
    path("contact/", views.contact),
]
```
## TemplateResponse ##
Выше для генерации шаблона применялась функция render(), которая является наиболее распространенным вариантом. Однако также мы можем использовать класс TemplateResponse:
```python
from django.template.response import TemplateResponse
  
def index(request):
    return TemplateResponse(request,  "index.html")
```
Результат будет тот же самый.

## Передача данных в шаблоны ##

Одним из преимуществ шаблонов является то, что мы можем передать в них динамически из представлений различные данные. Для вывода данных в шаблоне могут использоваться различные способы. Для вывода самых простых данных применяется двойная пара фигурных скобок:
```
{{ название_объекта }}
```
Например, пусть в проекте у нас есть папка templates, в которой содержится шаблон index.html:

Определим в файле index.html следующий код:
```
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Django на METANIT.COM</title>
</head>
<body>
    <h2>{{ header }}</h2>
    <p>{{ message }}</p>
</body>
</html>
```
Здесь используется две переменных: message и header. Они будут передаваться из представления.

Чтобы из функции-представления передать данные в шаблон применяется третий параметр функции render, который еще называется context и который представляет словарь. Например, изменим файл views.py следующим образом:
```python
views.py
_______________________
from django.shortcuts import render
 
def index(request):
    data = {"header": "Hello Django", "message": "Welcome to Python"}
    return render(request, "index.html", context=data)
```
В шаблоне используются две переменных, соответственно словарь, который передается в функцию render через параметр context, теперь содержит два значения с ключами header и message.

В результате при обращении к корню веб-приложения мы увидим следующий вывод в браузере: Hello Django , Welcome to Python

## Передача сложных данных ##
Рассмотрим передачу более сложных данных. Допустим, в представлении передаются следующие данные:
```python
views.py
_______________________
from django.shortcuts import render
  
def index(request):
    header = "Данные пользователя"              # обычная переменная
    langs = ["Python", "Java", "C#"]            # список
    user ={"name" : "Tom", "age" : 23}          # словарь
    address = ("Абрикосовая", 23, 45)           # кортеж
  
    data = {"header": header, "langs": langs, "user": user, "address": address}
    return render(request, "index.html", context=data)
```
В качестве третьего параметра в функцию render нам надо передать словарь, поэтому все данные оборачиваются в словарь и в таком виде передаются в шаблон.

В этом случае шаблон мог бы выглядеть, например, следующим образом:
```
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Django на METANIT.COM</title>
</head>
<body>
    <h1>{{ header }}</h1>
    <p>Имя: {{ user.name}} Возраст: {{user.age}}</p>
    <p>Адресс: ул. {{address.0}}, д. {{address.1}}, кв. {{address.2}}</p>
    <p>Языки: {{langs.0}}, {{langs.1}}</p>
</body>
</html>
```
Поскольку объекты langs и address представляют соответственно массив и кортеж, то мы можем обратиться к их элементам через индексы, как мы бы работали бы с ними в коде на Python, например, первый элемент кортежа address: address.0.

Подобным образом, поскольку объект user представляет словарь, то мы можем обратиться к его элементам по ключам name и age: {{ user.name}} {{user.age}}.

В итоге мы получим следующий вывод в веб-браузере: 
```
ДАННЫЕ ПОЛЬЗОВАТЕЛЯ
Имя: Том Возраст: 23
Адресс: улица Абрикосовая д.23 кв.45
языки: python, java
```

## TemplateResponse ##
Если для генерации шаблона применяется класс TemplateResponse, то в его конструктор также через третий параметр можно передать данные для шаблона:
```python
views.py
_______________________
from django.template.response import TemplateResponse
  
def index(request):
    header = "Данные пользователя"              # обычная переменная
    langs = ["Python", "Java", "C#"]            # список
    user ={"name" : "Tom", "age" : 23}          # словарь
    address = ("Абрикосовая", 23, 45)           # кортеж
  
    data = {"header": header, "langs": langs, "user": user, "address": address}
    return TemplateResponse(request,  "index.html", data)
```
## Передача объектов классов ##
Подобным образом можно передавать в шаблоны объекты своих классов. Например, определение функции-представления:
```python
views.py
_______________________
from django.shortcuts import render
  
def index(request):
    return render(request, "index.html", context = {"person": Person("Tom")})
 
class Person:
  
    def __init__(self, name):
        self.name = name    # имя человека
```
Здесь определяется класс Person, в конструкторе которого передается некоторое значение для атрибута name. В функции index в шаблон передается объект с ключом "person".

В шаблоне index.html мы можем обращаться к функциональности объекта, например, к его атрибуту name:
```
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Django на METANIT.COM</title>
</head>
<body>
    <h1>Person {{ person.name }}</h1>
</body>
</html>
```
## Фильтры шаблонов ##
В дополнение к тегам Django также поддерживает фильтры, которые позволяют произвести некоторую простешую обработку значений внутри шаблонов. Полный список фильтров можно найти в документации. Здесь же рассмотрим только некоторые наиболее используемые.

## add ## 
Фильтр add добавляет к одному значению другое.
```
значение1 | add: значение2
```
Например:
```
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Django on METANIT.COM</title>
</head>
<body>
    <div>
{% with message="Hello" %}
    <h2>{{ message|add:" Django" }}</h2>
{% endwith %}
    </div>
</body>
</html>
```
В данном случае определяется переменная message (это также могли бы быть данные, передаваемые из представления). Затем при выводе значения этой переменной к ней добавляется строка " Django"

## capfirst ## 
Фильтр capfirst делает первую букву заглавной:
```
{{ message|capfirst }}
```
Например, если message равно "django", то послет применения фильтра на веб-странице будет выведено "Django".

## cut ##
Фильтр cut удаляет из строки определенную подстроку:
```
{% with message="Я был дома" %}
    {{ message|cut:"был" }}
{% endwith %}
```
В данном случае из строки "Я был дома" удаляется подстрока "был", поэтому шаблон выведет "Я дома"

## Проверка значения и значение по умолчанию ##
Фильтр default проверяет значение, и если оно равно False, то возвращает некоторое значение по умолчанию.
```
{% with isEnabled=False %}
    {{ isEnabled|default:"unabled" }}
{% endwith %}
```
В данном случае переменная isEnabled равна False, поэтому шаблон выведет "unabled"

При этом сама переменная необязательно должна хранить именно True или False, это может быть любое выражение, которое можно привести в значению True/False. Например:
```
{% with name="" %}
    {{ name|default:"Undefined" }}
{% endwith %}
```
В данном случае переменная name представляет пустую строку, поэтому при применении фильтра получим False, а фильтр возвратит строку "Undefined".

Похожим действием обладает фильтр default_if_none - он возвращает значение по умолчанию, если переданное ему значение равно None:
```
{% with user=None %}
    {{ user|default_if_none:"Undefined" }}
{% endwith %}
```
## floatformat ##

floatformat форматирует числа с плавающей точкой.

Если фильтру не передается аргумент, то число округляется до одного знака после запятой:
```
Значение               Шаблон                 Результат

34.23234     {{ value|floatformat }}             34.2
34.00000     {{ value|floatformat }}             34
34.26000     {{ value|floatformat }}             34.3
```
Фильтру можно передать числовой аргумент, который указывает, до скольких знаков после запятой надо округлять:
```
Значение                Шаблон                 Результат

34.23234     {{ value|floatformat:3 }}          34.232
34.00000     {{ value|floatformat:3 }}          34.000
34.26000     {{ value|floatformat:3 }}          34.260
```
Если аргумент - отрицательное число, то число также округляется до определенного количества знака после запятой, однако нули при этом отсекуются:
```
Значение                Шаблон                 Результат

34.23234    {{ value|floatformat:"-3" }}        34.232
34.00000    {{ value|floatformat:"-3" }}        34
34.26000    {{ value|floatformat:"-3" }}        34.260
```
Аргумент 0 позволяет округлить число до ближайщего целого:
```
Значение                Шаблон                 Результат

34.23234     {{ value|floatformat:"0" }}         34
34.00000     {{ value|floatformat:"0" }}         34
39.56000     {{ value|floatformat:"0" }}         40
```
Если аргумент имеет суффикс g, то применяется группировка с использованием разделителя разрядов в соответствии с текущей локалью:
```
Значение                Шаблон                 Результат

34232.34    {{ value|floatformat:"2g" }}       34,232.34
34232.06    {{ value|floatformat:"g" }}        34,232.1
34232.00    {{ value|floatformat:"-3g" }}      34,232
```
При выводе применяется текущая локаль проекта. Например, если мы откроем файл settings.py, то можем там найти переменную LANGUAGE_CODE, которая определяет локаль:
```python
LANGUAGE_CODE = 'en-us'
```
По умолчанию применяется американский вариант английского языка и соответствующие им настройки локали. Соответственно разделителем между целой и дробной частью будет точка, а между разрядами - запятая. Но, например, изменим на русскоязычную культуру:
```python
LANGUAGE_CODE = 'ru-ru'
```
Теперь для кода
```
{% with value=34232.34 %}
    {{ value|floatformat:"2g" }}
{% endwith %}
```
Тмы получим вывод
```
1
34 232,34
```
Если же необходимо отключить локализацию, аргументу добавляется суффикс u:
```
{{ value|floatformat:"2u" }}
```
## Форматирование дат ##
Фильтр date применяется к объекту datetime и в качестве аргумента получает следующие спецификаторы даты и времени:

- d: день месяца в виде двух цифр (одна цифра дополняется нулем слева). Диапазон значений от '01' до '31'

- j: день месяца без дополнения нулем. Диапазон значений от '1' до '31'

- D: день недели в текстовом виде в виде трех символов, например, 'Fri'

- l: день недели в полном виде, например, 'Friday'

- S: возвращает английский суффикс для порядковых числительных для дня месяца. Возможные значения: 'st', 'nd', 'rd' и 'th'

- w: номер деня недели. Значения в диапазоне от'0' (воскресенье) до '6' (суббота)

- z: номер дня года. Диапазон значений от 1 до 366

- W: номер недели года (первым днем недели считается понедельник). Значения от 1 до 53

- m: номер месяца в виде двух цифр. Диапазон значений от '01' до '12'

- n: номер месяца в виде двух цифр без предварения нулем. Диапазон значений от '1' до '12'

- M: текстовое значение месяца в виде трех символов. Например, 'Jan'

- b: текстовое значение месяца в виде трех символов в нижнем регистре. Например, 'jan'
 
- E: локализованное название месяца. Например, 'августа' ("август" в родительном падеже)

- F: полное название месяца. Например, 'January'

- N: аббревиатура месяца. Например, 'Jan.', 'Feb.', 'March', 'May'

- t: число дней в текущем месяце. Значения от 28 до 31

- y: двухчисловой код года с дополнением нулем. Диапазон значений от '00' до '99'

- Y: четырехчисловой код года с дополнением нулем. Диапазон значений от '0001' до '9999'

- L: является ли год високосным. Значения: True(является) и False (не является)

- o: ISO-8601 week-numbering year,

- g: час в 12-часовом формате без дополнения нулем. Диапазон значений от '1' до '12'

- G: час в 24-часовом формате без дополнения нулем. Диапазон значений от '0' до '23'

- h: час в 12-часовом формате с дополнением нулем. Диапазон значений от'01' до '12'

- H: час в 24-часовом формате с дополнением нулем. Диапазон значений от'00' до '23'

- i: минуты от '00' до '59'

- s: секунды от '00' до '59'

- u: микросекунды от 000000 до 999999

- a: 'a.m.' или 'p.m.'

- A: 'AM' или 'PM'

- f: время в 12-часовом формате с минутами. Например, '1:30'

- P: время в 12-часовом формате с минутами и "a.m."/"p.m.". Например, '12:30 p.m.'

- e: часовая зона, например, '', 'GMT', '-500', 'US/Eastern', etc.

- O: смещение в часах относительно гринвича. Например, '+0200'

- T: временная зона текущего компьютера. 'EST', 'MDT'

- c: дата и время в формате ISO 8601. Например, 2008-01-02T10:30:00.000123+02:00 или 2008-01-02T10:30:00.000123

- r: дата и время в формает RFC 5322

Также можно передать ряд предустановленных констант:

- DATE_FORMAT

- DATETIME_FORMAT

- SHORT_DATE_FORMAT

- SHORT_DATETIME_FORMAT

Например, в представлении в шаблон передается некоторая дата:
```python
views.py
____________________
from datetime import datetime 
from django.shortcuts import render
  
def index(request):
    return render(request, "index.html", context={"my_date": datetime.now()})
```
Выведем эту дату в шаблоне:
```
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Django on METANIT.COM</title>
</head>
<body>
    <div>
<h2>{{ my_date|date:"d.m.Y" }}</h2>
<h2>{{ my_date|date:"H:i" }}</h2>
<h2>{{ my_date|date:"c" }}</h2>
<h2>{{ my_date|date:"SHORT_DATE_FORMAT" }}</h2>
</body>
</html>
```

## Операции со списками ##
Ряд фильтров предназначены для работы со списками.

- Фильтр join объединяет элементы списка, используя определенный разделитель:
```
{{ users|join:", "}}
```
Предположим, что здесь users - это список ["Tom", "Sam", "Bob", "Mike"], то после применения фильтра получится строка "Tom, Sam, Bob, Mike".

- Фильтр slice получает часть списка. Для извлечения часть списка он получает начальный и конечный индексы для извлечения элементов:
```
slice:"start:"
slice:":end"
slice:"start:end"
```
параметр start указывает на индекс элемента, начиная с которого надо скопировать элементы, а через параметр end передается индекс элемента, до которого нужно копировать список. Если start или end не указываются, то start по умолчанию равен 0, а end - на длину списка. Например
```
{{ {{ users|slice:"1:3" }}}}
```
Здесm извлекаются элементы с 1 по 3 индекс (не включая), то есть получится список ["Sam", "Bob"].

- Фильтр length возвращает длину списка (также этот фильтр можно применять для нахождения длины строки).
```
{{ users|length}}
```
Здесь фильтр возвратит 4.

## Статические файлы ##
Веб-приложение, как правило, использует различные статические файлы - изображения, файлы стилей css, скриптов javascript и так далее. Рассмотрим, как мы можем использовать подобые файлы.

При создании проекта Django он уже имеет некоторую базовую настройку для работы со статическими файлами. В частности, в файле settings.py определена переменная STATIC_URL, которая хранит путь к каталогу со статическими файлами:
```python
STATIC_URL = 'static/'
```
А среди установленных приложений в переменной INSTALLED_APPS указано приложение django.contrib.staticfiles
```python
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'hello',
]
```

Переменная STATIC_URL имеет значение "static/", а это значит, что нам достаточно создать в папке приложения каталог с именем "static" и добавить в него необходимые нам статические файлы. Но, естественно, при необходимости через данную настройку мы можем изменим расположение каталога статических файлов.

Итак, добавим в папку приложения новый каталог static. Чтобы не сваливать все статические файлы в кучу, определим для каждого типа файлов отдельные папки. В частности, создадим в папке static для изображений каталог images, а для стилей - каталог css. Подобным образом можно создавать папки и для других типов файлов.

В папку static/images добавим какое-нибудь изображение - в моем случае это будет файл forest.jpg. А в папке static/css определим новый файл styles.css, который будет иметь какие-нибудь простейшие стили, например:
```
body{ font-family: Verdana;}
h1{color:navy;}
img{width:350px;}
```

Теперь используем эти файлы в шаблоне. Для этого в начале файла шаблона необходимо определить инструкцию
```
{% load static %}
```
При этом данный код должен идти после тега DOCTYPE.

Для определения пути к статическим файлам используются выражения типа
```
{% static "путь к файлу внутри папки static" %}
```
Так, пусть в приложении в папке templates определен шаблон index.html, который имеет следующий код:
```
<!DOCTYPE html>
{% load static %}
<html>
<head>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="{% static "css/styles.css" %}" />
    <title>Django на METANIT.COM</title>
</head>
<body>
    <h1>Зимний лес</h1>
    <img src="{% static "images/forest.jpg" %}" alt="зимний лес" >
</body>
</html>
```

При запуске приложения шабон index.html будет генерироваться в следующую веб-страницу, которая будет использовать изображение и применять стили.

## Настройка путей к файлам ##
Если нам не устраивает храние файлов в каталоге по умолчанию - каталоге static, либо мы хотим указать несколько папок, то мы можем в файле settings.py задать все необходимые каталоги с помощью переменной STATICFILES_DIRS, которая принимает список путей:
```python
STATICFILES_DIRS = [
    BASE_DIR / "static",
    "/var/www/static/",
    "/somefolder/"
]
```
## TemplateView ##
В предыдущих темах когда приходил запрос система маршрутизации выбирала нужное представление, и то уже в свою очерель использовало шаблон для генерации ответа. Hо в приниципе если в ответ на запрос нам просто надо возвратить пользователю содержимое шаблона, то для этого необязательно определять функцию-представления. И можно воспользоваться встроенным классом TemplateView.

Так, определим несколько простейших шаблонов. Пусть это будет файл about.html со следующим кодом:
```
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Hello Django</title>
</head>
<body>
    <h1>About</h1>
</body>
</html>
```
И также определим шаблон contact.html со следующим кодом:
```
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Hello Django</title>
</head>
<body>
    <h1>Contact</h1>
</body>
</html>
```

Изменим файл urls.py следующим образом:
```python
urls.py
____________________
from django.urls import path
from django.views.generic import TemplateView
 
urlpatterns = [
    path("about/", TemplateView.as_view(template_name="about.html")),
    path("contact/", TemplateView.as_view(template_name="contact.html")),
]
```
Фактически TemplateView сам по себе предоставляет функционалность представления. С помощью метода as_view() через параметр template_name устанавливается путь к шаблону, который будет использоваться в качестве ответа.

## Передача данных в шаблоны ##
С помощью параметра extra_context в метод as_view можно передать данные для шаблона. Данные должны представлять словарь. Например:
```python
urls.py
____________________
from django.urls import path
from django.views.generic import TemplateView
 
urlpatterns = [
    path("about/", TemplateView.as_view(template_name="about.html", 
        extra_context={"header": "О сайте"})),
    path("contact/", TemplateView.as_view(template_name="contact.html")),
]
```
Здесь в шаблон "about.html" передается объект header, который представляет строку "О сайте". И в этом случае мы можем использовать этот объект в шаблоне:
```
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Hello Django</title>
</head>
<body>
    <h1>{{ header }}</h1>
</body>
</html>
```
## Конфигурация шаблонов ##
За конфигурацию шаблонов в проекте отвечает переменная TEMPLATES в файле settings.py. По умолчанию она имеет следующее содержимое:
```python
TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]
```
Данная переменная принимает список конфигураций для каждого движка шаблонов. По умолчанию определена одна конфигурация, которая имеет следующшие параметры

- BACKEND: движок шаблонов. По умолчанию применяется встроенный движок django.template.backends.django.DjangoTemplates

- DIRS: определяет список каталогов, где движок шаблонов будет искать файлы шаблонов. По умолчанию пустой список

- APP_DIRS: указывает, будет ли движок шаблонов искать шаблоны внутри папок приложений в папке templates.

- OPTIONS: определяет дополнительный список параметров. В частности, указывает, какие обработчики (процессоры) будут использоваться при обработке шаблонов.

## Пути к шаблонам ##
По умолчанию параметр APP_DIRS имеет значение True, а это значит, что движок шаблонов будет также искать нужные файлы шаблонов в папке приложения в каталоге templates. Это довольно удобно, если для каждого приложения предназначены какие-то свои шаблоны. Это также позволяет избежать проблем с наименованиями.

Тем не менее иногда возникает необходимость размещения шаблонов где-то в другом месте. Например, у нас есть общие шаблоны для всего проекта - для всех приложений, и было бы логично разместить их в каком-то одном общем месте, например, в папке проекта. К примеру, определим в каталоге проекта папку templates (название папки может быть любым). И в этой папке определим файл index.html с каким-нибудь простейшим кодом:
```
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Django on METANIT.COM</title>
</head>
<body>
    <h1>Hello METANIT.COM!</h1>
</body>
</html>
```

В моем случае проект называется metanit, который располагается в одноименной папке. В проекте находится папка templates с одним шаблоном. Но чтобы этот шаблон задействовать, надо настроить пути к этой папке в файле setting.py. Так, изменим переменную TEMPLATES:
```python
TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [
            BASE_DIR / "metanit/templates",
        ],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]
```
В данном случае в список папок DIRS добавляется один путь - BASE_DIR / "metanit/templates". Для образования пути берется определенная в начале файла settings.py переменная BASE_DIR:

```python
BASE_DIR = Path(__file__).resolve().parent.parent
```
которая представляет путь к каталогу, в котором располгается папка проекта. И к этому пути добавляется папка проекта (metanit) и каталог templates.

Пусть в views.py определена функция, которая использует шаблон index.html:
```python
views.py
____________________
from django.shortcuts import render
  
def index(request):
    return render(request, "index.html")
```
И в файле urls.py определен маршрут для этой функции:
```python
urls.py
____________________
from django.urls import path
from hello import views
  
urlpatterns = [
    path("", views.index),
]
```
Соответственно при обращении к функции index мы увидим в браузере содержимое файла index.html.

Подобным образом мы можем указать в качестве хранилища шаблонов любой каталог внутри проекта или приложения или даже набор каталогов.

## Расширение шаблонов и фильтр extends ##
Нередко шаблоны должны иметь одинаковую базовую структуру, одни и те же блоки, при этом определять для отдельных блоков различное содержимое. Это позволяет сформировать единообразный стиль сайта, когда веб-страницы имеют одни и те же структурные элементы - меню, хедер, футер, сайдбары и так далее.

В этом случае мы можем определять все шаблоны по отдельности. Однако если возникнет необходимость изменить какой-то блок, например, добавить в общее меню еще один пункт, тогда придется менять все шаблоны, коих может быть довольно много. И в этом случае оптимальнее повторно использовать один базовый шаблон, который определяет все основные блоки.

Например, определим шаблон, который назовем base.html:
```
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>{% block title %}Default title{% endblock title %}</title>
</head>
<body>
    <div><a href="/">Главная</a> | <a href="contacts">Контакты</a></div>
    <h1>{% block header %}{% endblock header %}</h1>
    <div>{% block content%}{% endblock content %}</div>
    <div>MyCorp. 2022. All rights reserved.</div>
</body>
</html>
```
С помощью элементов {% block название_блока %}{% endblock название_блока %} определяются отдельные блоки шаблонов. При этом для каждого блока определяется открывающий элемент {% block название_блока %} и закрывающий элемент {% endblock название_блока %}.

Например, блок title:
```
{% block title %}Default title{% endblock title %}
```
Когда другие шаблоны будут применять данный шаблон, то они могут определить для блока title какое-то свое содержимое.

Для каждого блока можно определить содержимое по умолчанию. Так, для блока title это строка "Default title". И если другие шаблоны, которые будут использовать данный шаблон, не определяет содержимое для блока title, то данный блок будет использовать строку "Default title"

Подобным образом здесь определены блоки header и content. Содержимое по умолчанию для блоков определять не обязательно. Самих блоков при необходимости можно определить сколько угодно.

Кроме того, в базовом шаблоне определено навигационное меню из двух ссылок. Но так как оно будет общим для всех шаблонов, то для него не определен отдельный блок. И также определен футер, который тоже будет общим для всех страниц.

Теперь применим этот базовый шаблон. Например, создадим новый шаблон index.html:
```
{% extends "base.html" %}
{% block title %}Index{% endblock title %}
{% block header %}Главная{% endblock header %}
```
С помощью выражения {% extends "base.html" %} определяем, какой базовый шаблон будет расширяться. Затем определяется содержимое для блоков title и header. Стоит отметить, что необязательно указывать содержимое для всех блоков базового шаблона.

Также создадим также шаблон contacts.html:
```
{% extends "base.html" %}
{% block title %}Контакты{% endblock title %}
{% block header %}Контакты{% endblock header %}
  
{% block content %}
<p>Телефон: +12345677890</p>
<p>Email: admin@admin.com</p>
{% endblock content %}
```
Этот шаблон также расширяет базовый шаблон base.html. В отличие от index.html здесь также определяется содержимое для блока content.

Таким образом, подобная функциональность позволяет нам избежать повторения одних и тех же элементов в разных шаблонов. и в то же время если нам потребуется что-то изменить, например, структуру страницы или какой-то общий элемент, то достаточно это сделать в одном файле - base.html.

Пусть в файле views.py имеются функции, которые используют эти шаблоны:
```python
views.py
____________________
from django.shortcuts import render
  
def index(request):
    return render(request, "index.html")
 
def contacts(request):
    return render(request, "contacts.html")
```
А в файле urls.py эти функции сопоставляются с определенными маршрутами:
```python
urls.py
____________________
from django.urls import path
from hello import views
  
urlpatterns = [
    path("", views.index),
    path("contacts/", views.contacts),
]
```
В итоге вне зависимости от того, к какой функции мы обратимся, мы получим на веб-странице одну и те жу структуру с общими меню и футером.

В итоге если нам потребуется изменить структуру всех веб-страниц сайта, добавить новые элементы или убрать старые, то достаточно будет изменить один базовый шаблон.

## Вложенные шаблоны и фильтр include ##
Фильтр include позволяет добавить в один шаблон другой шаблон. Название подключаемого шаблона передается фильтру в качестве параметра:
```
{% include подключаемый_файл  %}
```
Допустим, в приложении у нас имеются два шаблона: index.html и banner.html

Пусть в файле banner.html будет какой-нибудь простейший код:
```
<div>Руководство по Django на METANIT.COM</div>
```
В другом файле - index.html подключим данный шаблон:
```
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Django on METANIT.COM</title>
</head>
<body>
<h2>Главная страница</h2>
{% include "banner.html"  %}
</body>
</html>
```
В итоге при обращении к шаблону index.html на веб-странице появится содержимое из подключенного шаблона banner.html

Стоит отметить, что вместо жесткой установки пути к вложенному шаблону в виде строки, можно использовать переменные:
```
{% include template_name %}
```
В данном случае предполагается, что template_name - это переменная, которая хранит путь к вложенному шаблону.

## Передача данных ##
Во вложенные шаблоны также можно передавать некоторые данные. Например, изменим код в banner.html следующим образом:
```
<div>Руководство по {{ tutorial }} на {{ site}}</div>
```
Здесь используются переменные tutorial и site. Теперь изменим код index.html, передав для этих переменныx некоторые данные:
```
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Django on METANIT.COM</title>
</head>
<body>
<h2>Главная страница</h2>
{% include "banner.html" with tutorial="Python" site="METANIT.COM"  %}
</body>
</html>
```
Для передачи данных для фильтра определяются две переменных: tutorial и site. Объявление переменных идет после оператора with.

## Передача данных из родительского шаблона ##
Вложенные шаблоны автоматически подхватывают данные их родительских шаблонов. Например, возьмем выше определенный шаблон banner.html:
```
<div>Руководство по {{ tutorial }} на {{ site}}</div>
```
В файле views.py определим следующую функцию-представление:
```python
views.py
____________________
from django.shortcuts import render
  
def index(request):
    return render(request, "index.html", context={"site":"METANIT.COM"})
```
Здесь в шаблон index.html передается элемент site. Теперь изменим код index.html:
```
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Django on METANIT.COM</title>
</head>
<body>
<h2>Главная страница</h2>
{% include "banner.html" with tutorial="Python" %}
</body>
</html>
```
Теперь для шаблона banner.html НЕ создается переменная site, потому что вложенный шаблон автоматически получить данные по ключу "site" из родительского шаблона index.html. Однако это поведение не всегда удобно. Мы можем запретить автоматическую передачу данных из родительского во вложенный шаблон, используя оператор only:

```
{% include "banner.html" with tutorial="Python" only %}
```
В этом случае шаблон banner.html не получит данные по ключу "site".
