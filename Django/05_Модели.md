# Модели #
## Подключение к базе данных ##

По умолчанию Django в качестве базы данных использует SQLite. Она очень проста в использовании и не требует запущенного сервера. Все файлы базы данных могут легко переноситься с одного компьютера на другой. Однако при необходимости мы можем использовать в Django большинство распространенных СУБД.

Для работы с базами данных в проекте Django в файле settings.py определен параметр DATABASES, который по умолчанию выглядит следующим образом:
```python
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}
```
Переменная DATABASES содержит набор конфигураций подключений к базам данных в виде словаря. Ключи в этом словаре - названия подключений. То есть мы можем определить кучу подключений. Но как минимум одно подключение должно быть определено в переменной DATABASES - подключение с именем default, которое представляет подключение по умолчанию.

Конфигурация каждого подключения может состоять из ряда параметров. По умолчанию указываются только два параметра. Параметр ENGINE указывает на используемый движок для доступа к БД. В данном случае это встроенный пакет django.db.backends.sqlite3.

Второй параметр - NAME указывает на путь к базе данных. По умолчанию база данных называется db.sqlite3. Для установки пути используется каталог из переменной BASE_DIR, которая задана в начале файла:
```python
BASE_DIR = Path(__file__).resolve().parent.parent
```
По умолчанию BASE_DIR указывает на каталог, в котором находится папка проекта. И после первого запуска проекта в указанном каталоге по умолчанию будет создан файл db.sqlite3, который собственно и будет использоваться в качестве базы данных.

## Поддерживаемые субд ##
Чтобы использовать другие системы управления базами данных, необходимо будет установить соответствующий пакет.
```
СУБД              Пакет                Команда установки

PostgreSQL      psycopg2             pip install psycopg2
MySQL           mysql-python         pip install mysql-python
Oracle          cx_Oracle            pip install cx_Oracle
```
## Параметры подключения ##
Выше в настройках по умолчанию применялись только два параметра: ENGINE и NAME. Однако при необходимости можно указать и дополнительные параметры:

- ATOMIC_REQUESTS: при значении True обертывает каждый запрос к бд в транзакцию. По умолчанию равно False

- AUTOCOMMIT: при значении False отключает систему управления транзакциями Django. По умолчанию равно True

- ENGINE: движок бд. Поддерживаются следующие встроенные движки:
```
- django.db.backends.postgresql
- django.db.backends.mysql
- django.db.backends.sqlite3
- django.db.backends.oracle
```
- HOST: хост базы данных

- NAME: имя базы данных, для sqlite - путь к бд

- CONN_MAX_AGE: время жизни подключения в секундах. Значение 0 закрывает подключение сразу после завершения каждого запроса к бд. А значение None указывает на постоянное подключение. По умолчанию равно 0

- CONN_HEALTH_CHECKS: при значении True проверяет активность подключения, и если оно закрыто, заново устанавливает соединение. По умолчанию равно False

- OPTIONS: дополнительный набор параметров, который может потребоваться при подключении к определенных базам данных.

- PASSWORD: пароль. По умолчанию равно '' (пустая строка)

- PORT: порт бд. По умолчанию равно ''

- TIME_ZONE: часовой пояс. По умолчанию равно None

- USER: имя пользователя. По умолчанию равно ''

- TEST: набор настроек в виде словаря для теста подключения

Для разных СУБД может потребоваться разный набор параметров. Например, подключение к БД Postgres в общем случае выглядит так:
```python
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': 'mydatabase',
        'USER': 'mydatabaseuser',
        'PASSWORD': 'mypassword',
        'HOST': '127.0.0.1',
        'PORT': '5432',
    }
}
```
## Миграции базы данных ##
При создании базы данных она еще пуста, не содержит никаких данных. Однако в консоли при запуске проекта мы можем увидеть некоторое сообщение, выделенное красным цветом.

Дело в том, что для ряда приложений, подключенных в проект по умолчанию, требуется база данных для сохранения некоторых своих данных. Так, в в файле settings.py в переменной INSTALLED_APPS по умолчанию указан ряд приложений
```python
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    # остальные приложения ......
    # ................
]
```
Первые четыре приложения так или иначе используют базу данных. Однако, чтобы базы данных создала нужные для этих приложений таблицы, необходимо выполнить миграции - специальные скрипты, которые изменяют стуруктуру базы данных. Для этого выполним в консоли команду
```
python manage.py migrate
```

Если после этого мы откроем базу данных db.sqlite3, которая есть в проекте, в какой-нибудь специальной программе для просмотра БД SQLite, то мы увидим, что она содержит ряд таблиц

Для просмотра и работы с базами данных SQLite можно использовать бесплатную программу DB Browser for SQLite, которая доступна для всех основных операционных систем.

В частности, можно увидеть, что база данных содержит более десятка таблиц и индексов. Все они связанных с системой аутентификации и авторизации, администрирования и сессиями. И даже если мы непосредственно не будем использовать базу данных, но будем использовать системы аутентификации и авторизации, админитсрирования или сессии, то для нормальной работы нам все равно потребуется база данных и необходимо будет выполнить миграции.

## Создание моделей ##
Модели в Django описывают структуру используемых данных. Используемые в программе данные хранятся в базах данных, и с помощью моделей как раз осуществляется взаимодействие с базой данных.

При создании приложения по умолчанию в его каталог добавляется файл models.py, который применяется для определения моделей. Модель представляет класс, унаследованный от django.db.models.Model.

Так, изменим файл models.py следующим образом:
```python
models.py
_______________
from django.db import models
 
class Person(models.Model):
    name = models.CharField(max_length=20)
    age = models.IntegerField()
```

Здесь определена простейшая модель, которая называется Person и которая представляет человека. В модели определены два поля. Поле name представляет тип CharField - текстовое поле, которое хранит последовательность символов. Оно будет хранить имя человека. Для CharField обязательно надо указать параметр max_length, который задает максимальную длину хранящейся строки. И поле age представляет тип IntegerField - числовое поле, которое хранит целые числа. Оно предназначено для хранения возраста человека.

Каждая модель сопоставляется с определенной таблицей в базе данных. Однако пока у нас нет в бд таблицы, которая хранит объекты модели Person. И в этом случае нам надо создать и выполнить миграцию. Миграция преобразует базу данных в соответствии с определением моделей.

Вначале необходимо создать миграцию с помощью команды
```
python manage.py makemigrations
```

После этого в приложении в папке migrations мы обнаружим новый файл, который будет иметь примерно следующее содержимое:
```python
from django.db import migrations, models
 
 
class Migration(migrations.Migration):
 
    initial = True
 
    dependencies = [
    ]
 
    operations = [
        migrations.CreateModel(
            name='Person',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(max_length=20)),
                ('age', models.IntegerField()),
            ],
        ),
    ]
```
Это и есть миграция. Здесь можно заметить, что создается не два, а три поля - поле id, которое будет представлять первичный ключ, добавляется по умолчанию. Поэтому в приниципе в самой модели нам не нужно явным образом определять какой-либо идентификатор.

Теперь надо выполнить данную миграцию. Для этого выполняется команда
```
python manage.py migrate
```
После этого, если мы откроем базу данных db.sqlite3, которая есть в проекте, то мы увидим, что в нее добавлена таблица для хранения данных модели Person:

Стоит учитывать, что в процессе работы над проектом определение модели может меняться - к ней могут добавляться новые поля, либо могут удаляться уже существующие, либо могут добавляться новые модели, данные которых мы также захотим хранить в базе данных. И в этом случае опять надо создавать миграцию и применять ее к базе данных, чтобы база данных была синхронизирована с определением моделей.

## Типы полей моделей ##
Для определения моделей мы можем использовать следующие типы полей:

- BinaryField(): хранит бинарные данные

- BooleanField(): хранит значение True или False (0 или 1)

- NullBooleanField(): хранит значение True или False или Null

- DateField(): хранит дату

- TimeField(): хранит время

- DateTimeField(): хранит дату и время

- DurationField(): хранит период времени

- AutoField(): хранит целочисленное значение, которое автоматически инкрементируется, обычно применяется для первичных ключей

- BigAutoField(): хранит 64-битное целочисленное значение, но в отличие от AutoField гарантирует, что число входит в диапазон от 1 до 9223372036854775807.

- SmallAutoField(): хранит 16-битное целочисленное значение в диапазоне от 1 до 32767

- BigIntegerField(): представляет число - значение типа Number, которое укладывается в диапазон от -9223372036854775808 до 9223372036854775807. В зависимости от выбранной СУБД диапазон может немного отличаться

- DecimalField(decimal_places=X, max_digits=Y): представляет значение типа Number, которое имеет максимум X разрядов и Y знаков после запятой

- FloatField(): хранит, значение типа Number, которое представляет число с плавающей точкой

- IntegerField(): хранит значение типа Number, которое представляет целочисленное значение

- PositiveIntegerField(): хранит значение типа Number, которое представляет положительное целочисленное значение (от 0 до 2147483647)

- PositiveBigIntegerField(): хранит значение типа Number, которое представляет положительное 64-битное целочисленное значение (от 0 до 9223372036854775807)

- PositiveSmallIntegerField(): хранит значение типа Number, которое представляет небольшое положительное целочисленное значение (от 0 до 32767)

- SmallIntegerField(): хранит значение типа Number, которое представляет небольшое целочисленное значение (от -32768 до 32767)

- CharField(max_length=N): хранит строку длиной не более N символов

- TextField(): хранит строку неопределенной длины

- EmailField(): хранит строку, которая представляет email-адрес. Значение автоматически валидируется встроенным валидатором EmailValidator

- FileField(): хранит строку, которая представляет имя файла

- FilePathField(): хранит строку, которая представляет путь к файлу длиной в 100 символов

- ImageField(): хранит строку, которая представляет данные об изображении

- GenericIPAddressField(): хранит строку, которая представляет IP-адрес в формате IP4v или IP6v

- SlugField(): хранит строку, которая может содержать только буквы в нижнем регистре, цифры, дефис и знак подчеркивания

- URLField(): хранит строку, которая представляет валидный URL-адрес

- UUIDField(): хранит строку, которая представляет UUID-идетификатор

- JSONField(): хранит данные в формате JSON, которая представляет UUID-идетификатор

Таблица сопоставления полей с типами в различных СУБД:
```
Тип                         SQLite              MySQL              PostgreSQL                        Oracle

BinaryField()            BLOB NOT NULL     longblob NOT NULL      bytea NOT NULL                      BLOB NULL
BooleanField()           bool NOT NULL     bool NOT NULL          boolean NOT NULL                    NUMBER(1) NOT NULL CHECK("Значение" IN(0,1))
NullBooleanField()       bool NULL         bool NULL              boolean NULL                        NUMBER(1) NOT NULL CHECK(("Значение" IN(0,1)) OR ("Значение" IS NULL))
DateField()              date NULL         date NULL              date NULL                           DATE NOT NULL
TimeField()              time NULL         time NULL              time NULL                           TIMESTAMP NOT NULL
DateTimeField()          datetime NULL     datetime NULL          timestamp NULL                      TIMESTAMP NOT NULL
DurationField()          bigint NOT NULL   bigint NOT NULL        interval NOT NULL                   INTERVAL DAY(9) TO SECOND(6) NOT NULL
AutoField()              integer NOT NULL  AUTOINCREMENT          integer AUTO_INCREMENT NOT NULL     serial NOT NULL NUMBER(11) NOT NULL
BigIntegerField          bigint NOT NULL   bigint NOT NULL        bigint NOT NULL                     NUMBER(19) NOT NULL

DecimalField (decimal_places=X, max_digits=Y)   decimal NOT NULL    numeric(X, Y) NOT NULL   numeric(X, Y) NOT NULL    NUMBER(10, 3) NOT NULL

FloatField            real NOT NULL     double precision NOT NULL   double precision NOT NULL      DOUBLE PRECISION NOT NULL
IntegerField          integer NOT NULL   integer NOT NULL           integer NOT NULL               NUMBER(11) NOT NULL
PositiveIntegerField  integer unsigned NOT NULL    integer UNSIGNED NOT NULL   integer NOT NULL CHECK ("Значение" > 0)   NUMBER NOT NULL CHECK ("Значение" > 0)
PositiveSmallIntegerField   smallint unsigned NOT NULL   smallint UNSIGNED NOT NULL   smallint NOT NULL CHECK ("Значение" > 0)  NUMBER(11) NOT NULL CHECK ("Значение" > 0)

SmallIntegerField        smallint NOT NULL      smallint NOT NULL       smallint NOT NULL         NUMBER(11) NOT NULL
CharField(max_length=N)  varchar(N) NOT NULL    varchar(N) NOT NULL     varchar(N) NOT NULL       NVARCHAR2(N) NULL
TextField()              text NOT NULL           longtext NOT NULL         text NOT NULL           NCLOB NULL
EmailField()           varchar(254) NOT NULL    varchar(254) NOT NULL    varchar(254) NOT NULL    NVARCHAR2(254) NULL
FileField()            varchar(100) NOT NULL    varchar(100) NOT NULL    varchar(100) NOT NULL    NVARCHAR2(100) NULL
FilePathField()        varchar(100) NOT NULL    varchar(100) NOT NULL    varchar(100) NOT NULL    NVARCHAR2(100) NULL
ImageField()           varchar(100) NOT NULL    varchar(100) NOT NULL    varchar(100) NOT NULL    NVARCHAR2(100) NULL
GenericIPAddressField()   char(39) NOT NULL     char(39) NOT NULL        inet NOT NULL            VARCHAR2(39) NULL
SlugField()             varchar(50) NOT NULL    varchar(50) NOT NULL     varchar(50) NOT NULL     NVARCHAR2(50) NULL
URLField()             varchar(200) NOT NULL    varchar(200) NOT NULL    varchar(200) NOT NULL    NVARCHAR2(200) NULL
UUIDField()             char(32) NOT NULL       char(32) NOT NULL        uuid NOT NULL            VARCHAR2(32) NULL
JSONField()                                                              jsonb
```

## QuerySet API ##
В центре работы с моделями и базы данными находится объект QuerySet и его методы. QuerySet представляет набор запросов к базе данных, а его методы создают подобные запросы. А Django позволяет транслировать вызовы методов QuerySet в соответствующие SQL-запросы. Отмечу основые методы, которые можно применять для работы с данными моделей:

- filter(): фильтрует набор данных и возвращает выборку данных, которая соответствует фильтру, также в виде объекта QuerySet

- exclude(): фильтрует набор данных и возвращает выборку, которая НЕ соответствует фильтру, в виде объекта QuerySet

- order_by(): сортирует набор данных и возвращает отсортированную выборку в виде объекта QuerySet

- distinct(): возвращает объект QuerySet, который содержит только уникальные объекты

- values(): возвращает данные объектов в виде словаря

- values_list(): возвращает данные объектов в виде списка

- none(): возвращает пустой набор данных в виде объекта EmptyQuerySet (класс производный от QuerySet)

- all(): возвращает объект QuerySet, который содержит все объекты из таблицы

- union(): объединяет два объекта QuerySet и возвращает объединенный объект QuerySet

- intersection(): возвращает пересечение двух объектов QuerySet в виде другого QuerySet

- difference(): возвращает разность двух объектов QuerySet в виде другого QuerySet

- raw(): выполняет переданный в качестве параметра SQL-запрос

- get(): возвращает один объект модели

- create(): создает один объект модели

- get_or_create(): возвращает один объект модели по указанным параметрам, а если он отсутствует, то создает его

- update_or_create(): обновляет один объект модели по указанным параметрам, а если он отсутствует, то создает его

- bulk_create(): создает набор объектов модели

- save(): сохраняет один объект модели (если он ранее остутствовал в БД, то добавляет его, есть присутствовал, то обновляет его)

- bulk_update(): обновляет набор объектов

- count(): возвращает количество объектов в наборе

- in_bulk(): возвращает словарь объектов, которые имеют определенные идентификаторы

- latest(): возвращает объект с самыми последними изменениями

- earliest(): возвращает объект с самыми ранними изменениями

- first(): возвращает первый объект набора

- last(): возвращает последний объект набора

- aggregate(): выполняет агрегатную функцию (нахождение суммы, среднего, минимального, максимального значения и т.д.) и возвращает результат в виде числа

- exists(): проверяет, есть ли в наборе как минимум один объект. Если есть, то возвращается True, иначе возвращается False

- contains(): проверяет, есть ли в наборе определенный объект. Если есть, то возвращается True, иначе возвращается False

- update(): обновляет один объект модели

- delete(): удаляет один объект модели

Полный список методов можно найти в документации.

Причем выполнение методов QuerySet в базе данных происходит не сразу - при вызове метода, а при получение конкретного результата их QuerySet, например, при переборе набора. Посмотрим выполнение методов на примере. Допустим, в файле models.py определена следующая модель Person:
```python
models.py
_______________
from django.db import models
 
class Person(models.Model):
    name = models.CharField(max_length=20)
    age = models.IntegerField()
```
Для упрощения протестируем код в файле views.py, код которого вызывается при запуске приложения. В частности, определим в нем следующий код:
```python
views.py
_______________
from .models import Person
 
# получаем все объекты
people = Person.objects.all()
print(people.query)
 
# получаем объекты с именем Tom
people = people.filter(name = "Tom")
print(people.query)
 
# получаем объекты с возрастом, равным 31
people = people.filter(age = 31)
print(people.query)
 
# здесь происходит выполнения запроса в БД
for person in people:
    print(f"{person.id}.{person.name} - {person.age}")
```

Сначала идет получение всех данных с помощью метода all():
```python
people = Person.objects.all()
```
Переменная people здесь будет представлять объект QuerySet, который представляет набор из всех объектов таблицы.

С помощью свойства query у результата запроса мы можем получить SQL-запрос и, например, вывести его на консоль:
```
print(people.query)
```
Затем фильтруем набор с помощью метода filter() и выбираем только те объекты, где поле name равно "Tom":
```python
people = people.filter(name = "Tom")
```
Метод filter также возвращает QuerySet, который присваивается той же переменной people.

Затем выбираем только те объекты, где поле name равно "Tom":
```python
people = people.filter(age = 31)
```
Таким образом, к набору QuerySet были применены три метода, однако ни в одном случае не происходит обращения к базе данных. Это происходит, только когда мы непосредственно обращаемся к объектам набора, перебирая их в цикле.
```python
for person in people:
    print(f"{person.id}.{person.name} - {person.age}")
```
А по консольному выводу мы можем увидеть, как у нас создается финальный SQL-запрос, который и будет выполняться в БД при переборе объектов в цикле.

## Создание и получение объектов модели ##
Рассмотрим добавление в базу данных и получение из нее на примере модели Person:
```python
from django.db import models
 
class Person(models.Model):
    name = models.CharField(max_length=20)
    age = models.IntegerField()
```
## Добавление данных ##
### create ###
Для добавления данных применяется метод create():
```
tom = Person.objects.create(name="Tom", age=23)
```
Если добавление пройдет успешно, то объект будет иметь id, который можно получить через tom.id.

Асинхронная версия метода - acreate
```python
from .models import Person
import asyncio
  
async def acreate_person():
    person = await Person.objects.acreate(name="Tim", age=26)
    print(person.name)
 
# запускаем асинхронную функцию acreate_person
asyncio.run(acreate_person())
```
### save ###
Однако в своей сути метод create() использует другой метод - save(), который мы также можем использовать отдельно для добавления объекта:
```python
tom = Person(name="Tom", age=23)
tom.save()
```
После успешного добавления также можно получить идентификатор добавленной записи с помощью tom.id.

### bulk_create() ###
Метод bulk_create() (и его асинхронная версия abulk_create()) позволяет добавить набор объектов, который передается в в метод в качестве параметра:
```python
from .models import Person
  
people = Person.objects.bulk_create([
    Person(name="Kate", age=24),
    Person(name="Ann", age=21),
])
 
for person in people:
    print(f"{person.id}. {person.name}")
```
### Получение из бд ###
- Получение одного объекта
Метод get() возвращает один объект по определенному условию, которое передается в качестве параметра:
```
tom = Person.objects.get(name="Tom")    # получаем запись, где name="Tom"
bob = Person.objects.get(age=23)        # получаем запись, где age=42
```
При использовании этого метода надо учитывать, что он предназначен для выборки таких объектов, которые имеются в единичном числе в базе данных. Если в таблице не окажется подобного объекта, то мы получим ошибку имя_модели.DoesNotExist. Если же в таблице будет несколько объектов, которые соответствуют условию, то будет сгенерированно исключение MultipleObjectsReturned. Поэтому следует применять данный метод с осторожностью, либо применять обработку соответствующих исключений:
```python
from .models import Person
from django.core.exceptions import ObjectDoesNotExist, MultipleObjectsReturned
 
try:
    tom = Person.objects.get(name="Tom")    # MultipleObjectsReturned
    alex = Person.objects.get(name="Alex")  # ObjectDoesNotExist
except ObjectDoesNotExist:
    print("Объект не сушествует")
except MultipleObjectsReturned:
    print("Найдено более одного объекта")
```
- Асинхронная версия метода называется aget:
```python
from .models import Person
import asyncio
  
async def get_person():
    person = await Person.objects.aget(id=1)
    print(person.name)
 
# запускаем асинхронную функцию get_person
asyncio.run(get_person())
```
### get_or_create ###
Метод get_or_create() (и его асинхронная версия aget_or_create) возвращает объект, а если его нет в бд, то добавляет в бд новый объект.
```python
bob, created = Person.objects.get_or_create(name="Bob", age=24)
print(created)
print(bob.name)
print(bob.age)
```
В данном случае, если в таблице нет объекта со значениями name="Bob" и age=24, то он добавляется. Если есть, то он возвращается.

Метод возвращает добавленный объект (в данном случае переменная bob) и булевое значение (created), которое хранит True, если добавление прошло успешно.

Стоит учитывать, что если в таблице уже есть несколько объектов (два и больше) с указанными значениями, то сгенерируется исключение MultipleObjectsReturned.

### all() ###
Если необходимо получить все имеющиеся объекты, то применяется метод all():
```python
people = Person.objects.all()
```
Данный метод возвращает объект типа QuerySet.

### filter() ###
Если надо получить все объекты, которые соответствуют определенному критерию, то применяется метод filter(), который в качестве параметра принимает критерий выборки:
```python
people = Person.objects.filter(age=23)
# использование нескольких критериев
people2 = Person.objects.filter(name="Tom", age=23)
```
Метод filter позволяет определять более сложные условия, но поскольку это отдельная большая тем, то подробнее будет рассмотрена в отдельной статье.

### exclude() ###
Метод exclude() позволяют исключить из выборки записи, которые соответвуют переданному в качестве параметра критерию:
```python
# исключаем пользователей, у которых age=23
people = Person.objects.exclude(age=23)
```
Можно комбинировать два выше рассмотренных метода:
```python
# выбираем всех пользователей, у которых name="Tom" кроме тех, у которых age=23
people = Person.objects.filter(name="Tom").exclude(age=23)
```
### in_bulk() ###
Метод in_bulk() (и его асинхронная версия ain_bulk) является более эффективным способом для чтения большого количества записей. В качестве параметра в него можно передать список идентификаторов объектов, которые надо получить. В качестве результата он возвращает словарь, то есть объект dict:
```python
# получаем все объекты
people = Person.objects.in_bulk()
for id in people:
    print(people[id].name)
    print(people[id].age)
 
# получаем объекты с id=1 и id=3
people2 = Person.objects.in_bulk([1,3])
for id in people2:
    print(people2[id].name)
    print(people2[id].age)
```
Метод in_bulk() возвращает словарь, где ключи представляют id объектов, а значения по этим ключам - собственно эти объекты, то есть в данном случае объекты Person.

### Ограничение количества ###
С помощью синтаксиса списков можно получить определенную порцию данных из QuerySet:
```python
from .models import Person
 
people = Person.objects.all()[:5]
```
В данном случае выбираем первые 5 объектов, что на уровне базы данных транслируется в SQL-выражение LIMIT 5

Первый параметр указывает, сколько объектов надо пропустить:
```python
from .models import Person
 
people = Person.objects.all()[5:10]
for person in people:
    print(f"{person.id}.{person.name} - {person.age}")
```
В данном случае пропускаем первые 5 объектов и выбираем следующие 5 объектов до 10-го индекса, что на уровне базы данных транслируется в выражение OFFSET 5 LIMIT 5

## Редактирование и удаление объектов модели ##
Рассмотрим пример с редактированием и удалением объектов модели на примере модели Person:
```python
from django.db import models
 
class Person(models.Model):
    name = models.CharField(max_length=20)
    age = models.IntegerField()
```
### Обновление ###
### save() ###
Для обновления объекта также применяется метод save():
```python
bob = Person.objects.get(id=2)
bob.name = "Bob"
bob.save()
```
В этом случае Django полностью обновляет объект, все его свойства, даже если мы их не изменяли. Чтобы указать, что нам надо обновить только определенные поля, следует использовать параметр update_fields:
```python
from .models import Person
 
bob = Person.objects.get(id=1)
bob.name = "Robert"
bob.save(update_fields=["name"])
```
Это позволит повысить производительность.

### update() ###
Другой способ обновления объектов представляет метод update() (и его асинхронная версия aupdate()) в сочетании с методом filter, которые вместе выполняют один запрос к базе данных:
```python
from .models import Person
 
number = Person.objects.filter(id=1).update(name="Mike")
print(result) # количество обновленных строк
```
В данном случае у объектов с id = 1 устанавливаем для поля name значение "Mike". Метод возвращает количество обновленных строк.

Если нам не надо получать обновляемый объект, то данный способ позволит нам увеличить производительность взаимодействия с бд.

Также можно установить и большое количество полей:
```python
Person.objects.filter(id=1).update(name="Mike", age = 33)
```
Иногда бывает необходимо изменить значение столбца в бд на основании уже имеющегося значения. В этом случае мы можем использовать функцию F():
```python
from .models import Person
from django.db.models import F
 
Person.objects.all(id=2).update(age = F("age") + 1)
```
В данном случае полю age присваивается уже имеющееся значение, увеличенное на единицу.

При этом важно учитывать, что метод update обновляет все записи в таблице, которые соответствуют условию.

Если надо обновить вообще все записи, вне зависимости от условия, то необходимо комбинировать метод update с методом all():
```python
from .models import Person
from django.db.models import F
 
Person.objects.all().update(name="Mike")
Person.objects.all().update(age = F("age") + 1)
update_or_create()
```
Метод update_or_create (и его асинхронная версия aupdate_or_create()) обновляет запись, а если ее нет, то добавляет ее в таблицу:
```python
values_for_update={"name":"Bob", "age": 31}
bob, created = Person.objects.update_or_create(id=2, defaults = values_for_update)
```
Метод update_or_create() принимает два параметра. Первый параметр представляет критерий выборки объектов, которые будут обновляться. Второй параметр представляет объект со значениями, которые получат выбранные объекты. Если критерию не соответствует никаких объектов, то в таблицу добавляется новый объект, а переменная created будет равна True.

### bulk_update() ###
Метод bulk_update() (и его асинхронная версия abulk_update()) позволяет обновить за один раз набор объектов.
```python
bulk_update(objs, fields, batch_size=None)
```
Первый параметр - obj указывает на обновляемые объекты, а второй параметр - fields представляет обновляемые поля с новыми значениями. Последний параметр - batch_size указывает, сколько объектов обновляется в одном запросе (по умолчанию обновляются все объекты)

```python
from .models import Person
  
first_person = Person.objects.get(id=1)
first_person.name = "Tomas"
 
second_person = Person.objects.get(id=2)
second_person.age = 29
 
number = Person.objects.bulk_update([first_person, second_person], ["name", "age"])
print(number)   # 2
```
В данном случае у первого объекта обновляется значение поля "name", а у второго - значение поля "age". Поэтому в качестве второго параметра передается список с данными полями. Результатом метода является количество обновленных объектов.

Данный метод имеет некоторые ограничения. В частности, мы не можем обновить значение первичного ключа. Также если в обновляемом наборе есть дубли, то только первое вхождение объекта будет использоваться для обновления.

## Удаление ##
Для удаления мы можем вызвать метод delete() (либо его асинхронную версию adelete()) у удаляемого объекта:
```python
person = Person.objects.get(id=2)
person.delete()
```
Если не требуется получение отдельного объекта из базы данных, тогда можно удалить объект с помощью комбинации методов filter() и delete():
```python
Person.objects.filter(id=4).delete()
```
Удаление всех данных из таблицы:
```python
Person.objects.all().delete()
```

## Фильтрация ##
Django предоставляет богатые возможности по фильтрации данных. Для фильтрации данных у объекта QuerySet могут применяться следующие методы:

- get(): получает один объект модели

- filter(): получает набор объектов модели, которые соответствуют условию. Результат метода - объект QuerySet

- exclude(): получает набор объектов модели, которые НЕ соответствуют условию. Результат метода - объект QuerySet

Все три метода в качестве параметра получают условию, по которому идет фильтрация. Рассмотрим, какие условия мы можем определить.

Допустим, в файле models.py определена следующая модель Person:
```python
models.py
_______________
from django.db import models
 
class Person(models.Model):
    name = models.CharField(max_length=20)
    age = models.IntegerField()
```
Самый простый простой тип условия преставляет равенство свойства модели некоторому значению,:
```python

from .models import Person
 
# получаем пользователя по имени
tom = Person.objects.get(name="Tom")
print(f"{tom.name} - {tom.age}")
 
# получаем пользователей, у которых возраст равен 32
people_by_age1 = Person.objects.filter(age=32)
for person in people_by_age1:
    print(f"{person.name} - {person.age}")
 
# получаем пользователей, у которых возраст НЕ равен 32
people_by_age2 = Person.objects.exclude(age=32)
for person in people_by_age2:
    print(f"{person.name} - {person.age}")
```
В первом случае ищем один объект по имени:
```
tom = Person.objects.get(name="Tom")
```
или поиск по возрасту
```
people_by_age1 = Person.objects.filter(age=32)
```
Но кроме обычного равенства свойств модели некоторому значению можно применять и другие условия. Они определяются с помощью спецификатора фильтрации, который указывается в условии после свойства модели через два знака подчеркивания:
```
свойство__спецификатор = значение
```
Рассмотрим спецификаторы, которые можно использовать.

### exact и iexact ###
- exact выбирает все объекты моделей, в которых свойство равно определенному значению. 
- inexact выполняет ту же самую задачу, только выборка значений не зависит от регистра:
```PYTHON
# получаем пользователя по имени Tom
tom = Person.objects.get(name__exact="Tom")
 
# получаем пользователей, у которых возраст равен 32
people_by_age = Person.objects.filter(age__exact=32)
 
# получаем пользователя по имени Tom или tom или TOM
tom = Person.objects.get(name__iexact="Tom")
```
Стоит учитывать, что в некоторых СУБД, например, в MySQL, поиск по строкам регистрозависимый, то есть "Tom" и "tom" - это две разные строки.

Если необходимо найти данные, где поле таблицы имеет значение NULL, то свойству модели передается значение None:
```python
# получаем пользователей, у которых имя равно NULL
people_by_name = Person.objects.filter(name__exact=None)
```
### contains и icontains ###
- contains находит строки, которые содержат некоторую подстроку, причем поиск регистрозависимый. 
- icontains выполняет аналогичную задачу, за тем исключением, что поиск не зависит от регистра:
```python
# получаем пользователей, у которых имя содержит букву o
people1 = Person.objects.filter(name__contains="o")
 
# получаем пользователей, у которых имя содержит букву T или t
people2 = Person.objects.filter(name__icontains="T")
```
### in ###
in находит модели со свойством, значение которого равно одному из значений из списка:
```python
# получаем пользователей, у которых возраст равен или 32, или 35, или 38, 
people = Person.objects.filter(age__in=[32, 35, 38])
```
### gt, gte, lte, lt ###
Ряд спецификаторов позволяют найти объекты, свойства которых больше или меньше определенного значения: gt (больше чем), gte (больше чем или равно), lt (меньше чем), lte (меньше чем или равно):
```python
# получаем пользователей, у которых возраст меньше или равен 32 
people = Person.objects.filter(age__lte=32)

# получаем пользователей, у которых возраст больше 40
people = Person.objects.filter(age__gt=40)
```
### startswith и istartswith ###
startswith выбирает объекты моделей со значениями, которые начинаются на определенную строку. Выборка зависит от регистра.

istartswith выполняет ту же задачу, только выборка не зависит от регистра.
```python
# получаем пользователей, у которых имя начинается с To
people = Person.objects.filter(name__startswith="To") 
 
# получаем пользователей, у которых имя начинается с To или to
people = Person.objects.filter(name__istartswith="To")
```
### endswith и iendswith ###
endswith выбирает объекты моделей со значениями, которые начинаются на определенную строку. Выборка зависит от регистра.

iendswith выполняет ту же задачу, только выборка не зависит от регистра.
```python
# получаем пользователей, у которых имя заканчивается на m
people = Person.objects.filter(name__endswith="m")
 
# получаем пользователей, у которых имя заканчивается на m или M
people = Person.objects.filter(name__iendswith="m")
```
### range ###
range определяет диапазон, в которое должно входить значение свойства модели:
```python
# получаем пользователей, у которых возраст в диапазоне от 28 до 38 включительно
people = Person.objects.filter(age__range=(28, 38))
```
### isnull ###
isnull выбирает объекты моделей, у которых поле в таблице имеет значение NULL (при значении True) или, наоборот, не имеет значение NULL (при значении False)
```python
# получаем пользователей, у которых имя не установлено
people = Person.objects.filter(name__isnull=True)
 
# получаем пользователей, у которых возраст установлен
people = Person.objects.filter(age__isnull=False)
```
### regex и iregex ###
regex и iregex задают регулярное выражение, которому должно соответствовать значение свойства модели. В случае с regex выборка зависит от регистра, а у iregex - не зависит от регистра.
```python
# получаем пользователей, у которых имя заканчивается на am или om
people = Person.objects.filter(name__regex=r"(am|om)$")
```
### спецификаторы дат ###
Целый ряд спецификаторов фильтрации предназначен для работы с датами:

- date: значение поля должно соответствовать определенной дате. Представляет объект datetime.date

- year: год даты должен соответствовать определенному значению.

- month: определяет месяц даты

- day: определяет день даты

- week: определяет номер недели даты (1-52 или 53)

- week_day: определяет день недели даты (от 1 (воскресенье) до 7 (суббота)

- iso_week_day: определяет день недели даты (от 1 (понедельник) до 7 (воскресенье)

- quarter: определяет номер квартала даты

- time: определяет время даты. Представляет объект datetime.time

- hour: определяет час даты (от 0 до 23)

- minute: определяет минуту даты (от 0 до 59)

- second: определяет секунду даты (от 0 до 59)

Все данные спецификаторы кроме date и time принимают целые числа. Допустим, у нас есть следующая модель:
```python
from django.db import models
 
class Order(models.Model):
    datetime = models.DateTimeField()
```
Получим заказы за определенные месяцы:
```python
from .models import Order
from datetime import datetime
 
# добавление начальных данных
if Order.objects.count() == 0:
    Order.objects.create(datetime = datetime(2021, 12, 26, 11, 25, 34))
    Order.objects.create(datetime = datetime(2022, 5, 12, 12, 25, 34))
    Order.objects.create(datetime = datetime(2022, 5, 22, 13, 25, 34))
    Order.objects.create(datetime = datetime(2022, 8, 19, 14, 25, 34))
 
# получаем заказы, сделанные в 5-м месяце
orders = Order.objects.filter(datetime__month=5)
for order in orders:
    print(order.datetime)
 
 
# получаем заказы, сделанные до 5-го месяца
orders = Order.objects.filter(datetime__month__gt=5)
for order in orders:
    print(order.datetime)
```
К спецификаторам дат можно добавлять дополнительные спецификаторы, чтобы конкретизировать условие, как во втором случае: datetime__month__gt=5

Поиск по дате и времени:
```python
from .models import Order
from datetime import datetime, date, time
 
if Order.objects.count() == 0:
    Order.objects.create(datetime = datetime(2021, 12, 26, 11, 25, 34))
    Order.objects.create(datetime = datetime(2022, 5, 12, 12, 25, 34))
    Order.objects.create(datetime = datetime(2022, 5, 22, 13, 25, 34))
    Order.objects.create(datetime = datetime(2022, 8, 19, 14, 25, 34))
 
# получаем заказы, сделанные 22 мая
orders = Order.objects.filter(datetime__date=date(2022, 5, 22))
for order in orders:
    print(order.datetime)
 
 
# получаем заказы, сделанные после 12 часов 
orders = Order.objects.filter(datetime__time__gt=time(12, 20, 0))
for order in orders:
    print(order.datetime)
```
## Логические операторы ##
Логические операторы позволяют скомбинировать две выборки. Имеются следующие логические операторы: AND (&), OR (|) и XOR (^)

Оператор AND (&) указывает, что оба условия должны быть истинными:
```python
people = Person.objects.filter(name="Tom") & Person.objects.filter(age=22)
```
В данном случае в базе данных будет идти поиск строки, в которой одновременно поле name равно "Tom" и поле age равно 22. А на уровне базы данных это будет выражение:
```python
SELECT ... WHERE name='Tom' AND age=22
```
Оператор OR (|) указывает, что достаточно, чтобы одно из двух условий было истинным:
```python
people = Person.objects.filter(name="Tom") | Person.objects.filter(age=22)
```
В данном случае в базе данных будет идти поиск строки, в которой либо поле name равно "Tom", либо поле age равно 22. А на уровне базы данных это будет выражение:
```python
SELECT ... WHERE name='Tom' OR age=22
```
Оператор XOR (^) указывает, что необходимо, чтобы только одно из двух условий было истинно:
```python
people = Person.objects.filter(name="Tom") ^ Person.objects.filter(age=22)
```
В данном случае в базе данных будет идти поиск строки, в которой истинно либо условие name="Tom", либо поле условие age=22, но не одновременно оба условия. На уровне базы данных могут формироваться различные выражения в зависимости от поддержки оператора XOR.

## values и values_list и сортировка ##
### Сортировка ###
Для сортировки по возрастанию применяется функция order_by. В нее передаются поля, по которым идет сортировка:
```python
from .models import Person
 
# упорядочиваем по имени по возрастанию
people = Person.objects.order_by("name")
for person in people:
    print(person.name)
```
Подобным образом в функцию можно передать и большее количество полей, по которым последовательно будет выполняться сортировка:
```python
# упорядочиваем по имени и возрасту
people = Person.objects.order_by("name", "age")
```
Для сортировки по убыванию перед названием поля указывается знак минус:
```python
# упорядочиваем по имени по убыванию
people = Person.objects.order_by("-name")
values и values_list()
```
Методы values() и values_list() предназначены для оптимизации: для извлечения поднабора данных без необходимости создания полного объекта модели.

values возвращает объект QuerySet, где каждый объект модели представлен в виде словаря:
```python
from .models import Person 
 
people = Person.objects.values()
print(people)
 
# Результат
# <QuerySet [{'id': 1, 'name': 'Bob', 'age': 42}, {'id': 2, 'name': 'Tom', 'age': 38}, {'id': 3, 'name': 'Sam', 'age': 28}, {'id': 4, 'name': 'Alice', 'age': 32}, {'id': 5, 'name': 'Tom', 'age': 22}]>
```
Также можно передать в метод values названия полей, которые должны быть в словаре (по умолчанию выбираются все поля модели):
```python
people = Person.objects.values("id", "name")
print(people)
 
# Результат
# <QuerySet [{'id': 1, 'name': 'Bob'}, {'id': 2, 'name': 'Tom'}, {'id': 3, 'name': 'Sam'}, {'id': 4, 'name': 'Alice'}, {'id': 5, 'name': 'Tom'}]>
```
В данном случае словарь будет включать только поля id и name.

Метод values_list во многом аналогичен values(): он возвращает объект QuerySet, который состоит из кортежей. Каждый кортеж хранит данные одного объекта модели. Например:
```python
from .models import Person 
 
people = Person.objects.values_list()
print(people)
 
# Результат
# <QuerySet [(1, 'Bob', 42), (2, 'Tom', 38), (3, 'Sam', 28), (4, 'Alice', 32), (5, 'Tom', 22)]>
```
Также можно выбрать отдельные поля, передав их названия в метод:
```python
people = Person.objects.values_list("id", "name")
print(people)
 
# Результат
# <QuerySet [(1, 'Bob'), (2, 'Tom'), (3, 'Sam'), (4, 'Alice'), (5, 'Tom')]>
```
Если выбирается только одно поле, то в итоге получится набор кортежей, в каждом из которых будет по одному значению. Но передав параметру flat значение True можно упростить набор, вынеся значения на уровень выше:
```python
people = Person.objects.values_list("name", flat=True)
print(people)
 
# Результат
# <QuerySet ['Bob', 'Tom', 'Sam', 'Alice', 'Tom']>
```
## Операции с множествами ## 
### distinct() ###
distinct() выбирает уникальные значения:
```python
# без distinct
people = Person.objects.values_list("name", flat=True)
print(people)
 
# <QuerySet ['Bob', 'Tom', 'Sam', 'Alice', 'Tom']>
 
# с distinct
people = Person.objects.values_list("name", flat=True).distinct()
print(people)
 
# <QuerySet ['Bob', 'Tom', 'Sam', 'Alice']>
```
В данном случае получаем набор из всех имен пользователей. Но во втором случае также добавляем метод distinct(), который позволяет отсечь дубли.

### union() ###
Метод union() возвращает QuerySet, который является объединением двух QuerySet, что на уровне базы данных соответствует выполнению оператора UNION:
```python
toms = Person.objects.filter(name="Tom")
 
bobs = Person.objects.filter(name="Bob")
 
# объединяем два QuerySet
people = toms.union(bobs)
print(people.values())
 
# <QuerySet [{'id': 1, 'name': 'Bob', 'age': 42}, {'id': 2, 'name': 'Tom', 'age': 38}, {'id': 5, 'name': 'Tom', 'age': 22}]>
```
По умолчанию метод union() выбирает только уникальные значения из обоих выборок. Если такое поведение нежелательно, то в метод необходимо передать аргумент all=True:
```python
toms = Person.objects.filter(name="Tom")
 
bobs = Person.objects.filter(name="Bob")
 
# выбираем только уникальные (по умолчанию)
people = toms.values("name").union(bobs)
print(people)
# <QuerySet [{'name': 'Bob'}, {'name': 'Tom'}]>
 
# выбираем все
people = toms.values("name").union(bobs, all=True)
print(people)
# <QuerySet [{'name': 'Tom'}, {'name': 'Tom'}, {'name': 'Bob'}]>
```
Метод может принимать несколько выборок, которые объединяются с первой выборкой.

### intersection() ###
Метод intersection() возвращает QuerySet в виде перечения других QuerySet (то есть находит объекты, которые есть во всех выборках). На уровне базы данных это будет соответствовать выполнению SQL-оператора INTERSECT:
```python
toms = Person.objects.filter(name="Tom")
print(toms.values())
# <QuerySet [{'id': 2, 'name': 'Tom', 'age': 38}, {'id': 5, 'name': 'Tom', 'age': 22}]>
 
less35 = Person.objects.filter(age__lt=35)
print(less35.values())
# <QuerySet [{'id': 3, 'name': 'Sam', 'age': 28}, {'id': 4, 'name': 'Alice', 'age': 32}, {'id': 5, 'name': 'Tom', 'age': 22}]>
 
# находим пересечение двух QuerySet
people = toms.intersection(less35)
print(people.values())
# <QuerySet [{'id': 5, 'name': 'Tom', 'age': 22}]>
```
Метод может принимать несколько выборок, которые пересекаются с первой выборкой.

### difference() ###
Метод difference() возвращает QuerySet в виде разности других QuerySet (то есть находит объекты, которые есть в первой выборке, но отсутствуют в других). На уровне базы данных это будет соответствовать выполнению SQL-оператора EXCEPT:
```python
toms = Person.objects.filter(name="Tom")
print(toms.values())
# <QuerySet [{'id': 2, 'name': 'Tom', 'age': 38}, {'id': 5, 'name': 'Tom', 'age': 22}]>
 
less35 = Person.objects.filter(age__lt=35)
print(less35.values())
# <QuerySet [{'id': 3, 'name': 'Sam', 'age': 28}, {'id': 4, 'name': 'Alice', 'age': 32}, {'id': 5, 'name': 'Tom', 'age': 22}]>
 
# находим разность двух QuerySet
people = toms.difference(less35)
print(people.values())
# <QuerySet [{'id': 2, 'name': 'Tom', 'age': 38}]>
```
Метод может принимать множество выборок, которые надо вычесть из первой.

## Получение отдельных объектов и проверка их наличия ##
### latest и earliest ###
Метод latest() (и его асинхронная версия alatest()) возвращает объект, где были самые последние изменения в определенных полях.

Метод earliest() (и его асинхронная версия aearliest()) возвращает объект, где были самые ранние изменения в определенных полях.

В качестве параметра оба метода принимают набор полей, на основании которых возвращается объект:
```python
from .models import Person
  
# получаем объект с самыми последними изменениями в поле id
latest_person = Person.objects.latest("id")
print(f"{latest_person.name} - {latest_person.age}")
 
# получаем объект c самыми ранними изменениями в поле name
earliest_person = Person.objects.earliest("id")
print(f"{earliest_person.name} - {earliest_person.age}")
```
Можно передать набор полей:
```python
# получаем объект с самыми последними изменениями в поле age 
# и с самыми ранними изменениями в поле name
latest_person = Person.objects.latest("age", "-name")
print(f"{latest_person.name} - {latest_person.age}")
```
Если передается поле c минусом, то поиск идет в обратном порядке: для метода latest идет поиск поля с самыми ранними изменениями, а для метода earliest - с самыми поздними изменениями.

Если ни одного объекта не найдено (например, в случае с пустым набором), оба метода генерируют исключение DoesNotExist

### first и last ###
Метод first() (и его асинхронная версия afirst()) возвращает первый объект из набора.

Метод last() (и его асинхронная версия alast()) возвращает последний объект из набора.
```python
from .models import Person
  
# получим первый объект
first_person = Person.objects.first()
print(f"{first_person.name} - {first_person.age}")
 
# получим последний объект
last_person = Person.objects.last()
print(f"{last_person.name} - {last_person.age}")
 
# получим первый объект из набора, отсортированного по возрасту
first_person = Person.objects.order_by("age").first()
print(f"{first_person.name} - {first_person.age}")
```
Если ни одного объекта не найдено (например, в случае с пустым набором), оба метода возвращают значение None

### exists() ###
Метод exists() (и его асинхронная версия aexists()) возвращает True, если набор QuerySet содержит данные, и False - если не содержит:
```python
from .models import Person
  
is_present = Person.objects.filter(name = "Tom").exists()
if is_present:
    print("в наборе есть объекты")
else:
    print("объекты в наборе отсутствуют")
```
### contains() ###
Метод contains() (и его асинхронная версия acontains()) возвращает True, если набор QuerySet содержит определенный объект, и False - если не содержит:
```python
from .models import Person
  
# получим последний объект
last_person = Person.objects.last()
 
# есть ли объект last_person среди тех, у которых age меньше 35
is_present = Person.objects.filter(age__lt=35).contains(last_person)
if is_present:
    print("объект есть в наборе")
else:
    print("объект отсутствует")
```
## Агрегатные операции ##
### Количество объектов ###
Для вычисления количества объектов у QuerySet применяется метод count() и его асинхронная версия acount():
```python
from .models import Person
  
number = Person.objects.count()
print(number)
```
На уровне базы данных метод транслируется в SQL-выражение SELECT COUNT(*)

В Django для подсчета количества объектов также может использоваться функция len(). В нее передается QuerySet, для которого надо вычислить количество объектов.
```python
from .models import Person
  
people = Person.objects.all()
number = len(people)    # количество объектов в наборе people
print(number)
```
Что использовать: count или len? Если объекты уже ранее были загружены (например, с помощью метода all()), то оптимальнее использовать функцию len(), которая не выполняет к базе данных запрос SQL, а работает с уже загруженным набором объектов. Если же объекты ранее НЕ были загружены, то лучше выполнить метод count(), для которого не потребуется загружать все объекты из бд.

### Метод aggregate ###
Агрегатные операции позволяют получить одно скалярное значение, подсчитанное на наборе данных по определенному критерию. Для выполнения агрегатных операций применяется метод aggregate, который принимает один из объектов следующих классов:

- Avg: вычисляет среднее значение

- Min: вычисляет минимальное значение

- Max: вычисляет максимальное значение

- Sum: вычисляет сумму

В качестве одного из параметров конструкторы этих классов принимают выражение - обычно свойство, по которому вычисляется значение:
```python
from .models import Person 
from django.db.models import Avg, Min, Max, Sum
 
# средний возраст
avg_age = Person.objects.aggregate(Avg("age"))
print(avg_age)
 
# минимальный возраст
min_age = Person.objects.aggregate(Min("age"))
print(min_age)
 
# максимальный возраст
max_age = Person.objects.aggregate(Max("age"))
print(max_age)
 
# сумма всех возрастов
sum = Person.objects.aggregate(Sum("age"))
print(sum)
```

## Выполнение SQL-выражений ## 
Django автоматически транслирует методы QuerySet в соответствующие SQL-выражения, которые затем выполняются в базе данных. Однако фреймворк также позволяет непосредственно определить SQL-запрос и выполнять его. Для этого применяется метод raw(), в который передается SQL-запрос:
```python
from .models import Person 
 
people = Person.objects.raw("SELECT id, name FROM hello_person")
 
# перебираем полученные строки
for person in people:
    print(person.name)
 
# получаем один объект
print(people[0].name)
```
В данном случае в raw() передается запрос, который получает значения полей id и name из таблицы hello_person. Этот метод возвращает объект django.db.models.query.RawQuerySet, который, подобно QuerySet, также можно перебрать в цикле и извлечь из него данные.

Стоит учитывать, что данный метод должен возвращать набор строк. Также стоит отметить, что метод не учитывает никакие выражения фильтрации, которые идут до его вызова
```python
# здесь filter НЕ окажет никакого влияния
people = Person.objects.filter(age__lt=35).raw("SELECT * FROM hello_person")
```
## Передача параметров ##
С помощью параметра params в метод raw() можно передать значения для параметров в SQL-запросе:
```python
# определяем значение для параметра name
name_for_filter = "Tom"
# определяем значение для параметра age
age_for_filter = 35
 
people = Person.objects.raw("SELECT * FROM hello_person WHERE name = %s OR age > %s", 
[name_for_filter, age_for_filter])
```
В данном случае SQL-запрос использует два параметра, которые определяются через спецсимволы %s. Второй параметр метода raw представляет список аргументов, которые передаются в запрос вместо символов %s. Аргументы передаются по позиции, то есть значение name_for_filter передается на место первого вхождения %s, второе значение - age_for_filter - на место второго вхождения %s и т.д.

## Выполнение команд SQL ##
Слабым местом метода raw() является то, что он позволяет выполнять только команду SELECT, которая возвращает набор строк. Если же мы хотим выполнить другие sql-команды: UPDATE, INSERT или DELETE или другие типы SELECT-запросов, то в этом случае мы можем воспользоваться функционалом django.db.connection.

Объект django.db.connection представляет подключение к базе данных:
```python
from django.db import connection
 
with connection.cursor() as cursor:
        cursor.execute("UPDATE hello_person SET name ='Tomas' WHERE name='Tom' AND age=22")
        cursor.execute("SELECT * FROM hello_person WHERE name = 'Tomas'")
        row = cursor.fetchone()     # получаем одну строку
        print(row)
```
Для использования подключения вначале необходимо получить курсор с помощью метода connection.cursor(). А затем у курсора вызывается метод cursor.execute(), в который передается выполняемый sql-запрос. Для возвращения результата применяются методы cursor.fetchone() и cursor.fetchall().

Также можно использовать параметры:
```python
from django.db import connection
 
old_name = "Tomas"
new_name = "Tom"
with connection.cursor() as cursor:
        cursor.execute("UPDATE hello_person SET name =%s WHERE name=%s", [new_name, old_name])
        cursor.execute("SELECT * FROM hello_person WHERE name = 'Tom'")
        rows = cursor.fetchall()   # получаем все строки
         
        for row in rows:
            print(row)
 ```
## CRUD. Все базовые операции с моделями в веб-приложении ##
Рассмотрим базовые операции с моделями на простейшем примере. создание и вывод объектов модели на примере. Пусть, в файле models.py определена модель Person:
```python
from django.db import models
 
class Person(models.Model):
    name = models.CharField(max_length=20)
    age = models.IntegerField()
```
### Определение представлений ###
В файле views.py пропишем четыре представления для получения, сохранения, редактирования и удаления данных:
```python
from django.shortcuts import render
from django.http import HttpResponseRedirect, HttpResponseNotFound
from .models import Person
 
# получение данных из бд
def index(request):
    people = Person.objects.all()
    return render(request, "index.html", {"people": people})
 
# сохранение данных в бд
def create(request):
    if request.method == "POST":
        person = Person()
        person.name = request.POST.get("name")
        person.age = request.POST.get("age")
        person.save()
    return HttpResponseRedirect("/")
 
# изменение данных в бд
def edit(request, id):
    try:
        person = Person.objects.get(id=id)
 
        if request.method == "POST":
            person.name = request.POST.get("name")
            person.age = request.POST.get("age")
            person.save()
            return HttpResponseRedirect("/")
        else:
            return render(request, "edit.html", {"person": person})
    except Person.DoesNotExist:
        return HttpResponseNotFound("<h2>Person not found</h2>")
     
# удаление данных из бд
def delete(request, id):
    try:
        person = Person.objects.get(id=id)
        person.delete()
        return HttpResponseRedirect("/")
    except Person.DoesNotExist:
        return HttpResponseNotFound("<h2>Person not found</h2>")
```
В функции index() получаем все данные с помощью метода Person.objects.all() и передаем их в шаблон index.html.

В функции create() получаем данные из запроса типа POST, сохраняем данные с помощью метода save() и выполняем переадресацию на корень веб-сайта (то есть на функцию index).

Функция edit выполняет редактирование объекта. Функция в качестве параметра принимает идентификатор объекта в базе данных. И вначале по этому идентификатору мы пытаемся найти объект с помощью метода Person.objects.get(id=id). Поскольку в случае отсутствия объекта мы можем столкнуться с исключением Person.DoesNotExist, то соответственно нам надо обработать подобное исключение, если вдруг будет передан несуществующий идентификатор. И если объект не будет найден, то пользователю возващается ошибка 404 через вызов return HttpResponseNotFound().

Если объект найден, то обработка делится на две ветви. Если запрос POST, то есть если пользователь отправил новые изменненые данные для объекта, то сохраняем эти данные в бд и выполняем переадресацию на корень веб-сайта. Если запрос GET, то отображаем пользователю страницу edit.html с формой для редактирования объекта.

Функция delete аналогичным образом находит объет и выполняет его удаление.

### Определение шаблонов ###
В папке templates определим шаблон index.html, который будет выводить данные на веб-страницу:
```
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>METANIT.COM</title>
</head>
<body>
    <form method="POST" action="create/">
        {% csrf_token %}
        <p>
            <label>Введите имя</label><br>
            <input type="text" name="name" />
        </p>
        <p>
            <label>Введите возраст</label><br>
            <input type="number" name="age" />
        </p>
        <input type="submit" value="Сохранить" >
    </form>
    {% if people.count > 0 %}
    <h2>Список пользователей</h2>
    <table>
        <thead><th>Id</th><th>Имя</th><th>Возраст</th><th></th></thead>
        {% for person in people %}
        <tr>
            <td>{{ person.id }}</td>
            <td>{{ person.name }}</td>
            <td>{{ person.age }}</td>
            <td><a href="edit/{{person.id}}">Изменить</a> | <a href="delete/{{person.id}}">Удалить</a></td>
        </tr>
        {% endfor %}
    </table>
    {% endif %}
</body>
</html>
```
В начале шаблона определена форма для добавления данных, которые потом будет получать функция create в POST-запросе. А ниже определена таблица, в которую выводятся данные из переданного из представления набора people. В каждой строке определены ссылки на редактирование и удаление объекта.

Теперь добавим в папку templates файл edit.html со следующим содержимым:
```
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>METANIT.COM</title>
</head>
<body>
    <form method="POST">
        {% csrf_token %}
        <p>
            <label>Введите имя</label><br>
            <input type="text" name="name" value="{{person.name}}" />
        </p>
        <p>
            <label>Введите возраст</label><br>
            <input type="number" name="age" value="{{person.age}}" />
        </p>
        <input type="submit" value="Сохранить" >
    </form>
</body>
</html>
```
Здесь определена форма для редактирования объекта. По нажатию на кнопку введенные на форму данные будут уходить по тому же адресу в запросе POST.

### Установка маршрутов ###
И также в файле urls.py проекта свяжем маршруты с представлениями:
```python
from django.urls import path
from hello import views
 
urlpatterns = [
    path("", views.index),
    path("create/", views.create),
    path("edit/<int:id>/", views.edit),
    path("delete/<int:id>/", views.delete),
]
```
### CRUD в Django ###
Запустим проект и обратимся к приложению в браузере. Вначале добавим несколько объектов через форму на веб-странице. И после каждого добавления мы увидим, как на веб-странице в таблице появляются новые данные

Нажав на ссылку редактирования, мы перейдем к форме, где мы сможем изменить значения выбранного объекта:

Соответственно нажав на кнопку удаления в таблице объектов, мы удалим выбранный объект.

### Отношение один ко многим (One to Many) ###
ассмотрим организацию связи один ко многим, при которой одна главная сущность может быть связаны с несколькими зависимыми сущностями. Например, одна компания может выпускать несколько товаров:
```python
from django.db import models
 
class Company(models.Model):
    name = models.CharField(max_length=30)
 
class Product(models.Model):
    company = models.ForeignKey(Company, on_delete = models.CASCADE)
    name = models.CharField(max_length=30)
    price = models.IntegerField()
```
В данном случае модель Company представляет производителя и является главной моделью, а модель Product представляет товар компании и является зависимой моделью.

Конструктор типа models.ForeignKey настраивает связь с главной сущностью. Первый параметр указывает, с какой моделью будет создаваться связь - в данном случае это модель Company. Второй параметр - on_delete задает опцию удаления объекта текущей модели при удалении связанного объекта главной модели. Всего для параметра on_delete мы можем использовать следующие значения:

- models.CASCADE: автоматически удаляет строку из зависимой таблицы, если удаляется связанная строка из главной таблицы

- models.PROTECT: блокирует удаление строки из главной таблицы, если с ней связаны какие-либо строки из зависимой таблицы

- models.SET_NULL: устанавливает NULL при удалении связанной строка из главной таблицы

- models.SET_DEFAULT: устанавливает значение по умолчанию для внешнего ключа в зависимой таблице. В этом случае для этого столбца должно быть задано значение по умолчанию

- models.DO_NOTHING: при удалении связанной строки из главной таблицы не производится никаких действий в зависимой таблице

И в результате миграции в базе данных SQLite будут создаваться следующие таблицы:
```python
CREATE TABLE "hello_company" ("id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, "name" varchar(30) NOT NULL)
CREATE TABLE "hello_product" (
    "id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, 
    "name" varchar(30) NOT NULL, 
    "price" integer NOT NULL, 
    "company_id" bigint NOT NULL REFERENCES "hello_company" ("id") DEFERRABLE INITIALLY DEFERRED
)
```
### Операции с моделями ###
Из определения таблиц мы видим, что модель Product связана с таблицей Company через столбец "company_id". Однако в самом определении модели Product есть поле company, через которое можно получить связанную сущность:
```python
# получение id связанной с товаром компании
Product.objects.get(id=1).company.id
 
# получение названия связанной с товаром компании
Product.objects.get(id=1).company.name
 
# получение товаров, которые принадлежат к компании "Apple"
Product.objects.filter(company__name="Apple")
```
С помощью выражения модель__свойство (два подчеркивания) можно использовать свойство главной модели для фильтрации по объектам зависимой модели.

Хотя с точки зрения модели Company она не имеет никаких свойств, которые бы связывали бы ее с моделью Product. Но с помощью синтаксиса
```python
"главная_модель"."зависимая_модель"_set
```
можно изменить направление связи. Например:
```python
from .models import Company, Product
 
apple = Company.objects.get(name="Apple")
 
# получение всех товаров
apple.product_set.all()
 
# получение количества товаров
apple.product_set.count()
 
# получение товаров, название которых начинается на "iPhone"
apple.product_set.filter(name__startwith="iPhone")
```
Причем с помощью выражения _set можно выполнять операции добавления, изменения, удаления объектов зависимой модели из главной модели.
```python
# создаем объект Company
apple = Company.objects.create(name="Apple")
 
 
# создание товара определенной компании
apple.product_set.create(name="iPhone 8", price=67890)
 
# отдельное создание объекта с последующим добавлением
ipad = Product(name="iPad", price=34560)
# при добавлении необходимо указать параметр bulk =False
apple.product_set.add(ipad, bulk =False)
 
# исключает из компании все товары, 
# при этом товары остаются в бд, просто им не назначена компания
# работает, если в зависимой модели ForeignKey(Company, null = True)
# apple.product_set.clear()
 
# то же самое, только в отношении одного объекта
# ipad = Product.objects.get(name="iPad")
# apple.product_set.remove(ipad)
```
Стоит отметить три метода:

- add(): добавляет связь между объектом зависимой модели и объектом главной модели. В своей сути этот метод фактически вызывает для модели метод update() для добавления связи. Однако это требует, чтобы обе модели уже были в базе данных. И чтобы обойти это ограничение, применяется параметр bulk=False, для того, чтобы объект зависимой модели сразу был добавлен и для него была установлена связь.

- clear(): удаляет связь между всеми объектами зависимой модели и объектом главной модели. При этом сами объекты зависимой модели остаются в базе данных, и для их внешнего ключа устанавливается значение NULL. Поэтому данный метод будет работать, если в самой зависимой модели при установки связи использовался параметр null=True: ForeignKey(Company, null = True).

- remove(): также, как и clear() удаляет связь, только между одним объектом зависимой модели и объектом главной модели. При этом также все объекты остаются в бд. И также в самой зависимой модели при установки связи должен использоваться параметр null=True

## Практический пример связи один ко многим ##
Рассмотрим, как связь "один-ко многим" может быть реализована в Django на простейшем примере. Пусть в файле models.py приложения определены следующие модели:
```python
from django.db import models
class Company(models.Model):
    name = models.CharField(max_length=30)
  
class Product(models.Model):
    company = models.ForeignKey(Company, on_delete = models.CASCADE)
    name = models.CharField(max_length=30)
    price = models.IntegerField()
```
здесь определены модели Company и Product, которые связаны связью "один-ко-многим": одна компания может иметь множество товаров.

В файле views.py определим все необходимые представления для работы с объектами Product:
```python
from django.shortcuts import render
from .models import Company, Product
from django.http import HttpResponseRedirect, HttpResponseNotFound
  
# получение данных из бд
def index(request):
    products = Product.objects.all()
    return render(request, "index.html", {"products": products})
 
# добавление данных из бд
def create(request):
    create_companies()  # добавляем начальные данные для компаний
 
    # если запрос POST, сохраняем данные
    if request.method == "POST":
        product = Product()
        product.name = request.POST.get("name")
        product.price = request.POST.get("price")
        product.company_id = request.POST.get("company")
        product.save()
        return HttpResponseRedirect("/")
    # передаем данные в шаблон
    companies = Company.objects.all()
    return render(request, "create.html", {"companies": companies})
 
# изменение данных в бд
def edit(request, id):
    try:
        product = Product.objects.get(id=id)
 
        if request.method == "POST":
            product.name = request.POST.get("name")
            product.price = request.POST.get("price")
            product.company_id = request.POST.get("company")
            product.save()
            return HttpResponseRedirect("/")
        else:
            companies = Company.objects.all()
            return render(request, "edit.html", {"product": product, "companies": companies})
    except Product.DoesNotExist:
        return HttpResponseNotFound("<h2>Product not found</h2>")
     
# удаление данных из бд
def delete(request, id):
    try:
        product = Product.objects.get(id=id)
        product.delete()
        return HttpResponseRedirect("/")
    except Product.DoesNotExist:
        return HttpResponseNotFound("<h2>Product not found</h2>")
 
# добавление начальных данных в таблицу компаний
def create_companies():
      
     if Company.objects.all().count() == 0:
          Company.objects.create(name = "Apple")
          Company.objects.create(name = "Asus")
          Company.objects.create(name = "MSI")
```
Для упрошения добавления данных здесь также определена вспомогательная функция create_companies, которая добавляет данные компаний в бд, чтобы у нас были некоторые начальные данные.

Функция index получает из базы данных все объекты Product и передает их в шаблон.

Функция create, если запрос типа POST, то получает данные из запроса и сохраняет их в бд. Иначе получает набор компаний и передает их в шаблон для добавления.

Функция edit, если запрос типа POST, получает данные запроса и изменяет значения нужного товара. Если запрос типа Get, то передает в шаблон данные редактируемого товара и список компаний (чтобы можно было изменить компанию товара - представим, что мы можем изменить производителя товара)

Функция delete удаляет товар.

В каталоге приложения определим папку templates и добавим в нее три шаблона: index.html, create.html и edit.html

В шаблоне index.html определим логику вывода списка товаров:
```
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>METANIT.COM</title>
</head>
<body>
    <h2>Список товаров</h2>
    <a href="create/">Добавление товара</a>
    <table>
        <thead><th>Название</th><th>Цена</th><th>Компания</th><th></th></thead>
        {% for product in products %}
        <tr>
            <td>{{ product.name }}</td>
            <td>{{ product.price }}</td>
            <td>{{ product.company.name }}</td>
            <td>
                <a href="edit/{{product.id}}">Изменить</a> | <a href="delete/{{product.id}}">Удалить</a>
            </td>
        </tr>
        {% endfor %}
    </table>
</body>
</html>
```
В шаблоне create.html определим поля для добавления товара:
```
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>METANIT.COM</title>
</head>
<body>
    <h2>Добавление товара</h2>
    <form method="POST">
        {% csrf_token %}
        <p>
            <label>Введите название товара</label><br>
            <input type="text" name="name" />
        </p>
        <p>
            <label>Введите цену</label><br>
            <input type="number" name="price" />
        </p>
        <p>
            <label>Введите компанию</label><br>
            <select name="company">
            {% for company in companies %}
                <option value="{{company.id}}">{{company.name}}</option>
            {% endfor %}
            </select>
        </p>
        <input type="submit" value="Сохранить" >
    </form>
</body>
</html>
```
В шаблоне edit.html определим поля для редактирования товара:
```
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>METANIT.COM</title>
</head>
<body>
    <h2>Изменение товара</h2>
    <form method="POST">
        {% csrf_token %}
        <p>
            <label>Введите название товара</label><br>
            <input type="text" name="name" value="{{product.name}}" />
        </p>
        <p>
            <label>Введите цену</label><br>
            <input type="number" name="price" value="{{product.price}}"/>
        </p>
        <p>
            <label>Введите компанию</label><br>
            <select name="company">
            {% for company in companies %}
                <option value="{{company.id}}"
                {%if company.id == product.company_id%}
                  selected
                {%endif%}
            >{{company.name}}</option>
            {% endfor %}
            </select>
        </p>
        <input type="submit" value="Сохранить" >
    </form>
</body>
</html>
```
В файле urls.py пропишем маршруты для представлений:
```python
from django.urls import path
from hello import views
 
urlpatterns = [
    path("", views.index),
    path("create/", views.create),
    path("edit/<int:id>/", views.edit),
    path("delete/<int:id>/", views.delete),
]
```
В итоге получится следующий проект.

При запуске проекта и обращении к главной странице по умолчанию нет никаких товаров. И для этого перейдем к добавлению и добавим какой-нибудь товар:

Подобным образом можно выполнить редактирование товара

