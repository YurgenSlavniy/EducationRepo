# Модели #
## Подключение к базе данных ##

По умолчанию Django в качестве базы данных использует SQLite. Она очень проста в использовании и не требует запущенного сервера. Все файлы базы данных могут легко переноситься с одного компьютера на другой. Однако при необходимости мы можем использовать в Django большинство распространенных СУБД.

Для работы с базами данных в проекте Django в файле settings.py определен параметр DATABASES, который по умолчанию выглядит следующим образом:
```python
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}
```
Переменная DATABASES содержит набор конфигураций подключений к базам данных в виде словаря. Ключи в этом словаре - названия подключений. То есть мы можем определить кучу подключений. Но как минимум одно подключение должно быть определено в переменной DATABASES - подключение с именем default, которое представляет подключение по умолчанию.

Конфигурация каждого подключения может состоять из ряда параметров. По умолчанию указываются только два параметра. Параметр ENGINE указывает на используемый движок для доступа к БД. В данном случае это встроенный пакет django.db.backends.sqlite3.

Второй параметр - NAME указывает на путь к базе данных. По умолчанию база данных называется db.sqlite3. Для установки пути используется каталог из переменной BASE_DIR, которая задана в начале файла:
```python
BASE_DIR = Path(__file__).resolve().parent.parent
```
По умолчанию BASE_DIR указывает на каталог, в котором находится папка проекта. И после первого запуска проекта в указанном каталоге по умолчанию будет создан файл db.sqlite3, который собственно и будет использоваться в качестве базы данных.

## Поддерживаемые субд ##
Чтобы использовать другие системы управления базами данных, необходимо будет установить соответствующий пакет.
```
СУБД              Пакет                Команда установки

PostgreSQL      psycopg2             pip install psycopg2
MySQL           mysql-python         pip install mysql-python
Oracle          cx_Oracle            pip install cx_Oracle
```
## Параметры подключения ##
Выше в настройках по умолчанию применялись только два параметра: ENGINE и NAME. Однако при необходимости можно указать и дополнительные параметры:

- ATOMIC_REQUESTS: при значении True обертывает каждый запрос к бд в транзакцию. По умолчанию равно False

- AUTOCOMMIT: при значении False отключает систему управления транзакциями Django. По умолчанию равно True

- ENGINE: движок бд. Поддерживаются следующие встроенные движки:
```
- django.db.backends.postgresql
- django.db.backends.mysql
- django.db.backends.sqlite3
- django.db.backends.oracle
```
- HOST: хост базы данных

- NAME: имя базы данных, для sqlite - путь к бд

- CONN_MAX_AGE: время жизни подключения в секундах. Значение 0 закрывает подключение сразу после завершения каждого запроса к бд. А значение None указывает на постоянное подключение. По умолчанию равно 0

- CONN_HEALTH_CHECKS: при значении True проверяет активность подключения, и если оно закрыто, заново устанавливает соединение. По умолчанию равно False

- OPTIONS: дополнительный набор параметров, который может потребоваться при подключении к определенных базам данных.

- PASSWORD: пароль. По умолчанию равно '' (пустая строка)

- PORT: порт бд. По умолчанию равно ''

- TIME_ZONE: часовой пояс. По умолчанию равно None

- USER: имя пользователя. По умолчанию равно ''

- TEST: набор настроек в виде словаря для теста подключения

Для разных СУБД может потребоваться разный набор параметров. Например, подключение к БД Postgres в общем случае выглядит так:
```python
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': 'mydatabase',
        'USER': 'mydatabaseuser',
        'PASSWORD': 'mypassword',
        'HOST': '127.0.0.1',
        'PORT': '5432',
    }
}
```
## Миграции базы данных ##
При создании базы данных она еще пуста, не содержит никаких данных. Однако в консоли при запуске проекта мы можем увидеть некоторое сообщение, выделенное красным цветом.

Дело в том, что для ряда приложений, подключенных в проект по умолчанию, требуется база данных для сохранения некоторых своих данных. Так, в в файле settings.py в переменной INSTALLED_APPS по умолчанию указан ряд приложений
```python
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    # остальные приложения ......
    # ................
]
```
Первые четыре приложения так или иначе используют базу данных. Однако, чтобы базы данных создала нужные для этих приложений таблицы, необходимо выполнить миграции - специальные скрипты, которые изменяют стуруктуру базы данных. Для этого выполним в консоли команду
```
python manage.py migrate
```

Если после этого мы откроем базу данных db.sqlite3, которая есть в проекте, в какой-нибудь специальной программе для просмотра БД SQLite, то мы увидим, что она содержит ряд таблиц

Для просмотра и работы с базами данных SQLite можно использовать бесплатную программу DB Browser for SQLite, которая доступна для всех основных операционных систем.

В частности, можно увидеть, что база данных содержит более десятка таблиц и индексов. Все они связанных с системой аутентификации и авторизации, администрирования и сессиями. И даже если мы непосредственно не будем использовать базу данных, но будем использовать системы аутентификации и авторизации, админитсрирования или сессии, то для нормальной работы нам все равно потребуется база данных и необходимо будет выполнить миграции.

## Создание моделей ##
Модели в Django описывают структуру используемых данных. Используемые в программе данные хранятся в базах данных, и с помощью моделей как раз осуществляется взаимодействие с базой данных.

При создании приложения по умолчанию в его каталог добавляется файл models.py, который применяется для определения моделей. Модель представляет класс, унаследованный от django.db.models.Model.

Так, изменим файл models.py следующим образом:
```python
models.py
_______________
from django.db import models
 
class Person(models.Model):
    name = models.CharField(max_length=20)
    age = models.IntegerField()
```

Здесь определена простейшая модель, которая называется Person и которая представляет человека. В модели определены два поля. Поле name представляет тип CharField - текстовое поле, которое хранит последовательность символов. Оно будет хранить имя человека. Для CharField обязательно надо указать параметр max_length, который задает максимальную длину хранящейся строки. И поле age представляет тип IntegerField - числовое поле, которое хранит целые числа. Оно предназначено для хранения возраста человека.

Каждая модель сопоставляется с определенной таблицей в базе данных. Однако пока у нас нет в бд таблицы, которая хранит объекты модели Person. И в этом случае нам надо создать и выполнить миграцию. Миграция преобразует базу данных в соответствии с определением моделей.

Вначале необходимо создать миграцию с помощью команды
```
python manage.py makemigrations
```

После этого в приложении в папке migrations мы обнаружим новый файл, который будет иметь примерно следующее содержимое:
```python
from django.db import migrations, models
 
 
class Migration(migrations.Migration):
 
    initial = True
 
    dependencies = [
    ]
 
    operations = [
        migrations.CreateModel(
            name='Person',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(max_length=20)),
                ('age', models.IntegerField()),
            ],
        ),
    ]
```
Это и есть миграция. Здесь можно заметить, что создается не два, а три поля - поле id, которое будет представлять первичный ключ, добавляется по умолчанию. Поэтому в приниципе в самой модели нам не нужно явным образом определять какой-либо идентификатор.

Теперь надо выполнить данную миграцию. Для этого выполняется команда
```
python manage.py migrate
```
После этого, если мы откроем базу данных db.sqlite3, которая есть в проекте, то мы увидим, что в нее добавлена таблица для хранения данных модели Person:

Стоит учитывать, что в процессе работы над проектом определение модели может меняться - к ней могут добавляться новые поля, либо могут удаляться уже существующие, либо могут добавляться новые модели, данные которых мы также захотим хранить в базе данных. И в этом случае опять надо создавать миграцию и применять ее к базе данных, чтобы база данных была синхронизирована с определением моделей.

## Типы полей моделей ##
Для определения моделей мы можем использовать следующие типы полей:

- BinaryField(): хранит бинарные данные

- BooleanField(): хранит значение True или False (0 или 1)

- NullBooleanField(): хранит значение True или False или Null

- DateField(): хранит дату

- TimeField(): хранит время

- DateTimeField(): хранит дату и время

- DurationField(): хранит период времени

- AutoField(): хранит целочисленное значение, которое автоматически инкрементируется, обычно применяется для первичных ключей

- BigAutoField(): хранит 64-битное целочисленное значение, но в отличие от AutoField гарантирует, что число входит в диапазон от 1 до 9223372036854775807.

- SmallAutoField(): хранит 16-битное целочисленное значение в диапазоне от 1 до 32767

- BigIntegerField(): представляет число - значение типа Number, которое укладывается в диапазон от -9223372036854775808 до 9223372036854775807. В зависимости от выбранной СУБД диапазон может немного отличаться

- DecimalField(decimal_places=X, max_digits=Y): представляет значение типа Number, которое имеет максимум X разрядов и Y знаков после запятой

- FloatField(): хранит, значение типа Number, которое представляет число с плавающей точкой

- IntegerField(): хранит значение типа Number, которое представляет целочисленное значение

- PositiveIntegerField(): хранит значение типа Number, которое представляет положительное целочисленное значение (от 0 до 2147483647)

- PositiveBigIntegerField(): хранит значение типа Number, которое представляет положительное 64-битное целочисленное значение (от 0 до 9223372036854775807)

- PositiveSmallIntegerField(): хранит значение типа Number, которое представляет небольшое положительное целочисленное значение (от 0 до 32767)

- SmallIntegerField(): хранит значение типа Number, которое представляет небольшое целочисленное значение (от -32768 до 32767)

- CharField(max_length=N): хранит строку длиной не более N символов

- TextField(): хранит строку неопределенной длины

- EmailField(): хранит строку, которая представляет email-адрес. Значение автоматически валидируется встроенным валидатором EmailValidator

- FileField(): хранит строку, которая представляет имя файла

- FilePathField(): хранит строку, которая представляет путь к файлу длиной в 100 символов

- ImageField(): хранит строку, которая представляет данные об изображении

- GenericIPAddressField(): хранит строку, которая представляет IP-адрес в формате IP4v или IP6v

- SlugField(): хранит строку, которая может содержать только буквы в нижнем регистре, цифры, дефис и знак подчеркивания

- URLField(): хранит строку, которая представляет валидный URL-адрес

- UUIDField(): хранит строку, которая представляет UUID-идетификатор

- JSONField(): хранит данные в формате JSON, которая представляет UUID-идетификатор

Таблица сопоставления полей с типами в различных СУБД:
```
Тип                         SQLite              MySQL              PostgreSQL                        Oracle

BinaryField()            BLOB NOT NULL     longblob NOT NULL      bytea NOT NULL                      BLOB NULL
BooleanField()           bool NOT NULL     bool NOT NULL          boolean NOT NULL                    NUMBER(1) NOT NULL CHECK("Значение" IN(0,1))
NullBooleanField()       bool NULL         bool NULL              boolean NULL                        NUMBER(1) NOT NULL CHECK(("Значение" IN(0,1)) OR ("Значение" IS NULL))
DateField()              date NULL         date NULL              date NULL                           DATE NOT NULL
TimeField()              time NULL         time NULL              time NULL                           TIMESTAMP NOT NULL
DateTimeField()          datetime NULL     datetime NULL          timestamp NULL                      TIMESTAMP NOT NULL
DurationField()          bigint NOT NULL   bigint NOT NULL        interval NOT NULL                   INTERVAL DAY(9) TO SECOND(6) NOT NULL
AutoField()              integer NOT NULL  AUTOINCREMENT          integer AUTO_INCREMENT NOT NULL     serial NOT NULL NUMBER(11) NOT NULL
BigIntegerField          bigint NOT NULL   bigint NOT NULL        bigint NOT NULL                     NUMBER(19) NOT NULL

DecimalField (decimal_places=X, max_digits=Y)   decimal NOT NULL    numeric(X, Y) NOT NULL   numeric(X, Y) NOT NULL    NUMBER(10, 3) NOT NULL

FloatField            real NOT NULL     double precision NOT NULL   double precision NOT NULL      DOUBLE PRECISION NOT NULL
IntegerField          integer NOT NULL   integer NOT NULL           integer NOT NULL               NUMBER(11) NOT NULL
PositiveIntegerField  integer unsigned NOT NULL    integer UNSIGNED NOT NULL   integer NOT NULL CHECK ("Значение" > 0)   NUMBER NOT NULL CHECK ("Значение" > 0)
PositiveSmallIntegerField   smallint unsigned NOT NULL   smallint UNSIGNED NOT NULL   smallint NOT NULL CHECK ("Значение" > 0)  NUMBER(11) NOT NULL CHECK ("Значение" > 0)

SmallIntegerField        smallint NOT NULL      smallint NOT NULL       smallint NOT NULL         NUMBER(11) NOT NULL
CharField(max_length=N)  varchar(N) NOT NULL    varchar(N) NOT NULL     varchar(N) NOT NULL       NVARCHAR2(N) NULL
TextField()              text NOT NULL           longtext NOT NULL         text NOT NULL           NCLOB NULL
EmailField()           varchar(254) NOT NULL    varchar(254) NOT NULL    varchar(254) NOT NULL    NVARCHAR2(254) NULL
FileField()            varchar(100) NOT NULL    varchar(100) NOT NULL    varchar(100) NOT NULL    NVARCHAR2(100) NULL
FilePathField()        varchar(100) NOT NULL    varchar(100) NOT NULL    varchar(100) NOT NULL    NVARCHAR2(100) NULL
ImageField()           varchar(100) NOT NULL    varchar(100) NOT NULL    varchar(100) NOT NULL    NVARCHAR2(100) NULL
GenericIPAddressField()   char(39) NOT NULL     char(39) NOT NULL        inet NOT NULL            VARCHAR2(39) NULL
SlugField()             varchar(50) NOT NULL    varchar(50) NOT NULL     varchar(50) NOT NULL     NVARCHAR2(50) NULL
URLField()             varchar(200) NOT NULL    varchar(200) NOT NULL    varchar(200) NOT NULL    NVARCHAR2(200) NULL
UUIDField()             char(32) NOT NULL       char(32) NOT NULL        uuid NOT NULL            VARCHAR2(32) NULL
JSONField()                                                              jsonb
```

## QuerySet API ##
В центре работы с моделями и базы данными находится объект QuerySet и его методы. QuerySet представляет набор запросов к базе данных, а его методы создают подобные запросы. А Django позволяет транслировать вызовы методов QuerySet в соответствующие SQL-запросы. Отмечу основые методы, которые можно применять для работы с данными моделей:

- filter(): фильтрует набор данных и возвращает выборку данных, которая соответствует фильтру, также в виде объекта QuerySet

- exclude(): фильтрует набор данных и возвращает выборку, которая НЕ соответствует фильтру, в виде объекта QuerySet

- order_by(): сортирует набор данных и возвращает отсортированную выборку в виде объекта QuerySet

- distinct(): возвращает объект QuerySet, который содержит только уникальные объекты

- values(): возвращает данные объектов в виде словаря

- values_list(): возвращает данные объектов в виде списка

- none(): возвращает пустой набор данных в виде объекта EmptyQuerySet (класс производный от QuerySet)

- all(): возвращает объект QuerySet, который содержит все объекты из таблицы

- union(): объединяет два объекта QuerySet и возвращает объединенный объект QuerySet

- intersection(): возвращает пересечение двух объектов QuerySet в виде другого QuerySet

- difference(): возвращает разность двух объектов QuerySet в виде другого QuerySet

- raw(): выполняет переданный в качестве параметра SQL-запрос

- get(): возвращает один объект модели

- create(): создает один объект модели

- get_or_create(): возвращает один объект модели по указанным параметрам, а если он отсутствует, то создает его

- update_or_create(): обновляет один объект модели по указанным параметрам, а если он отсутствует, то создает его

- bulk_create(): создает набор объектов модели

- save(): сохраняет один объект модели (если он ранее остутствовал в БД, то добавляет его, есть присутствовал, то обновляет его)

- bulk_update(): обновляет набор объектов

- count(): возвращает количество объектов в наборе

- in_bulk(): возвращает словарь объектов, которые имеют определенные идентификаторы

- latest(): возвращает объект с самыми последними изменениями

- earliest(): возвращает объект с самыми ранними изменениями

- first(): возвращает первый объект набора

- last(): возвращает последний объект набора

- aggregate(): выполняет агрегатную функцию (нахождение суммы, среднего, минимального, максимального значения и т.д.) и возвращает результат в виде числа

- exists(): проверяет, есть ли в наборе как минимум один объект. Если есть, то возвращается True, иначе возвращается False

- contains(): проверяет, есть ли в наборе определенный объект. Если есть, то возвращается True, иначе возвращается False

- update(): обновляет один объект модели

- delete(): удаляет один объект модели

Полный список методов можно найти в документации.

Причем выполнение методов QuerySet в базе данных происходит не сразу - при вызове метода, а при получение конкретного результата их QuerySet, например, при переборе набора. Посмотрим выполнение методов на примере. Допустим, в файле models.py определена следующая модель Person:
```python
models.py
_______________
from django.db import models
 
class Person(models.Model):
    name = models.CharField(max_length=20)
    age = models.IntegerField()
```
Для упрощения протестируем код в файле views.py, код которого вызывается при запуске приложения. В частности, определим в нем следующий код:
```python
views.py
_______________
from .models import Person
 
# получаем все объекты
people = Person.objects.all()
print(people.query)
 
# получаем объекты с именем Tom
people = people.filter(name = "Tom")
print(people.query)
 
# получаем объекты с возрастом, равным 31
people = people.filter(age = 31)
print(people.query)
 
# здесь происходит выполнения запроса в БД
for person in people:
    print(f"{person.id}.{person.name} - {person.age}")
```

Сначала идет получение всех данных с помощью метода all():
```python
people = Person.objects.all()
```
Переменная people здесь будет представлять объект QuerySet, который представляет набор из всех объектов таблицы.

С помощью свойства query у результата запроса мы можем получить SQL-запрос и, например, вывести его на консоль:
```
print(people.query)
```
Затем фильтруем набор с помощью метода filter() и выбираем только те объекты, где поле name равно "Tom":
```python
people = people.filter(name = "Tom")
```
Метод filter также возвращает QuerySet, который присваивается той же переменной people.

Затем выбираем только те объекты, где поле name равно "Tom":
```python
people = people.filter(age = 31)
```
Таким образом, к набору QuerySet были применены три метода, однако ни в одном случае не происходит обращения к базе данных. Это происходит, только когда мы непосредственно обращаемся к объектам набора, перебирая их в цикле.
```python
for person in people:
    print(f"{person.id}.{person.name} - {person.age}")
```
А по консольному выводу мы можем увидеть, как у нас создается финальный SQL-запрос, который и будет выполняться в БД при переборе объектов в цикле.

## Создание и получение объектов модели ##
Рассмотрим добавление в базу данных и получение из нее на примере модели Person:
```python
from django.db import models
 
class Person(models.Model):
    name = models.CharField(max_length=20)
    age = models.IntegerField()
```
## Добавление данных ##
### create ###
Для добавления данных применяется метод create():
```
tom = Person.objects.create(name="Tom", age=23)
```
Если добавление пройдет успешно, то объект будет иметь id, который можно получить через tom.id.

Асинхронная версия метода - acreate
```python
from .models import Person
import asyncio
  
async def acreate_person():
    person = await Person.objects.acreate(name="Tim", age=26)
    print(person.name)
 
# запускаем асинхронную функцию acreate_person
asyncio.run(acreate_person())
```
### save ###
Однако в своей сути метод create() использует другой метод - save(), который мы также можем использовать отдельно для добавления объекта:
```python
tom = Person(name="Tom", age=23)
tom.save()
```
После успешного добавления также можно получить идентификатор добавленной записи с помощью tom.id.

### bulk_create() ###
Метод bulk_create() (и его асинхронная версия abulk_create()) позволяет добавить набор объектов, который передается в в метод в качестве параметра:
```python
from .models import Person
  
people = Person.objects.bulk_create([
    Person(name="Kate", age=24),
    Person(name="Ann", age=21),
])
 
for person in people:
    print(f"{person.id}. {person.name}")
```
### Получение из бд ###
- Получение одного объекта
Метод get() возвращает один объект по определенному условию, которое передается в качестве параметра:
```
tom = Person.objects.get(name="Tom")    # получаем запись, где name="Tom"
bob = Person.objects.get(age=23)        # получаем запись, где age=42
```
При использовании этого метода надо учитывать, что он предназначен для выборки таких объектов, которые имеются в единичном числе в базе данных. Если в таблице не окажется подобного объекта, то мы получим ошибку имя_модели.DoesNotExist. Если же в таблице будет несколько объектов, которые соответствуют условию, то будет сгенерированно исключение MultipleObjectsReturned. Поэтому следует применять данный метод с осторожностью, либо применять обработку соответствующих исключений:
```python
from .models import Person
from django.core.exceptions import ObjectDoesNotExist, MultipleObjectsReturned
 
try:
    tom = Person.objects.get(name="Tom")    # MultipleObjectsReturned
    alex = Person.objects.get(name="Alex")  # ObjectDoesNotExist
except ObjectDoesNotExist:
    print("Объект не сушествует")
except MultipleObjectsReturned:
    print("Найдено более одного объекта")
```
- Асинхронная версия метода называется aget:
```python
from .models import Person
import asyncio
  
async def get_person():
    person = await Person.objects.aget(id=1)
    print(person.name)
 
# запускаем асинхронную функцию get_person
asyncio.run(get_person())
```
### get_or_create ###
Метод get_or_create() (и его асинхронная версия aget_or_create) возвращает объект, а если его нет в бд, то добавляет в бд новый объект.
```python
bob, created = Person.objects.get_or_create(name="Bob", age=24)
print(created)
print(bob.name)
print(bob.age)
```
В данном случае, если в таблице нет объекта со значениями name="Bob" и age=24, то он добавляется. Если есть, то он возвращается.

Метод возвращает добавленный объект (в данном случае переменная bob) и булевое значение (created), которое хранит True, если добавление прошло успешно.

Стоит учитывать, что если в таблице уже есть несколько объектов (два и больше) с указанными значениями, то сгенерируется исключение MultipleObjectsReturned.

### all() ###
Если необходимо получить все имеющиеся объекты, то применяется метод all():
```python
people = Person.objects.all()
```
Данный метод возвращает объект типа QuerySet.

### filter() ###
Если надо получить все объекты, которые соответствуют определенному критерию, то применяется метод filter(), который в качестве параметра принимает критерий выборки:
```python
people = Person.objects.filter(age=23)
# использование нескольких критериев
people2 = Person.objects.filter(name="Tom", age=23)
```
Метод filter позволяет определять более сложные условия, но поскольку это отдельная большая тем, то подробнее будет рассмотрена в отдельной статье.

### exclude() ###
Метод exclude() позволяют исключить из выборки записи, которые соответвуют переданному в качестве параметра критерию:
```python
# исключаем пользователей, у которых age=23
people = Person.objects.exclude(age=23)
```
Можно комбинировать два выше рассмотренных метода:
```python
# выбираем всех пользователей, у которых name="Tom" кроме тех, у которых age=23
people = Person.objects.filter(name="Tom").exclude(age=23)
```
### in_bulk() ###
Метод in_bulk() (и его асинхронная версия ain_bulk) является более эффективным способом для чтения большого количества записей. В качестве параметра в него можно передать список идентификаторов объектов, которые надо получить. В качестве результата он возвращает словарь, то есть объект dict:
```python
# получаем все объекты
people = Person.objects.in_bulk()
for id in people:
    print(people[id].name)
    print(people[id].age)
 
# получаем объекты с id=1 и id=3
people2 = Person.objects.in_bulk([1,3])
for id in people2:
    print(people2[id].name)
    print(people2[id].age)
```
Метод in_bulk() возвращает словарь, где ключи представляют id объектов, а значения по этим ключам - собственно эти объекты, то есть в данном случае объекты Person.

### Ограничение количества ###
С помощью синтаксиса списков можно получить определенную порцию данных из QuerySet:
```python
from .models import Person
 
people = Person.objects.all()[:5]
```
В данном случае выбираем первые 5 объектов, что на уровне базы данных транслируется в SQL-выражение LIMIT 5

Первый параметр указывает, сколько объектов надо пропустить:
```python
from .models import Person
 
people = Person.objects.all()[5:10]
for person in people:
    print(f"{person.id}.{person.name} - {person.age}")
```
В данном случае пропускаем первые 5 объектов и выбираем следующие 5 объектов до 10-го индекса, что на уровне базы данных транслируется в выражение OFFSET 5 LIMIT 5

## Редактирование и удаление объектов модели ##
Рассмотрим пример с редактированием и удалением объектов модели на примере модели Person:
```python
from django.db import models
 
class Person(models.Model):
    name = models.CharField(max_length=20)
    age = models.IntegerField()
```
### Обновление ###
### save() ###
Для обновления объекта также применяется метод save():
```python
bob = Person.objects.get(id=2)
bob.name = "Bob"
bob.save()
```
В этом случае Django полностью обновляет объект, все его свойства, даже если мы их не изменяли. Чтобы указать, что нам надо обновить только определенные поля, следует использовать параметр update_fields:
```python
from .models import Person
 
bob = Person.objects.get(id=1)
bob.name = "Robert"
bob.save(update_fields=["name"])
```
Это позволит повысить производительность.

### update() ###
Другой способ обновления объектов представляет метод update() (и его асинхронная версия aupdate()) в сочетании с методом filter, которые вместе выполняют один запрос к базе данных:
```python
from .models import Person
 
number = Person.objects.filter(id=1).update(name="Mike")
print(result) # количество обновленных строк
```
В данном случае у объектов с id = 1 устанавливаем для поля name значение "Mike". Метод возвращает количество обновленных строк.

Если нам не надо получать обновляемый объект, то данный способ позволит нам увеличить производительность взаимодействия с бд.

Также можно установить и большое количество полей:
```python
Person.objects.filter(id=1).update(name="Mike", age = 33)
```
Иногда бывает необходимо изменить значение столбца в бд на основании уже имеющегося значения. В этом случае мы можем использовать функцию F():
```python
from .models import Person
from django.db.models import F
 
Person.objects.all(id=2).update(age = F("age") + 1)
```
В данном случае полю age присваивается уже имеющееся значение, увеличенное на единицу.

При этом важно учитывать, что метод update обновляет все записи в таблице, которые соответствуют условию.

Если надо обновить вообще все записи, вне зависимости от условия, то необходимо комбинировать метод update с методом all():
```python
from .models import Person
from django.db.models import F
 
Person.objects.all().update(name="Mike")
Person.objects.all().update(age = F("age") + 1)
update_or_create()
```
Метод update_or_create (и его асинхронная версия aupdate_or_create()) обновляет запись, а если ее нет, то добавляет ее в таблицу:
```python
values_for_update={"name":"Bob", "age": 31}
bob, created = Person.objects.update_or_create(id=2, defaults = values_for_update)
```
Метод update_or_create() принимает два параметра. Первый параметр представляет критерий выборки объектов, которые будут обновляться. Второй параметр представляет объект со значениями, которые получат выбранные объекты. Если критерию не соответствует никаких объектов, то в таблицу добавляется новый объект, а переменная created будет равна True.

### bulk_update() ###
Метод bulk_update() (и его асинхронная версия abulk_update()) позволяет обновить за один раз набор объектов.
```python
bulk_update(objs, fields, batch_size=None)
```
Первый параметр - obj указывает на обновляемые объекты, а второй параметр - fields представляет обновляемые поля с новыми значениями. Последний параметр - batch_size указывает, сколько объектов обновляется в одном запросе (по умолчанию обновляются все объекты)

```python
from .models import Person
  
first_person = Person.objects.get(id=1)
first_person.name = "Tomas"
 
second_person = Person.objects.get(id=2)
second_person.age = 29
 
number = Person.objects.bulk_update([first_person, second_person], ["name", "age"])
print(number)   # 2
```
В данном случае у первого объекта обновляется значение поля "name", а у второго - значение поля "age". Поэтому в качестве второго параметра передается список с данными полями. Результатом метода является количество обновленных объектов.

Данный метод имеет некоторые ограничения. В частности, мы не можем обновить значение первичного ключа. Также если в обновляемом наборе есть дубли, то только первое вхождение объекта будет использоваться для обновления.

## Удаление ##
Для удаления мы можем вызвать метод delete() (либо его асинхронную версию adelete()) у удаляемого объекта:
```python
person = Person.objects.get(id=2)
person.delete()
```
Если не требуется получение отдельного объекта из базы данных, тогда можно удалить объект с помощью комбинации методов filter() и delete():
```python
Person.objects.filter(id=4).delete()
```
Удаление всех данных из таблицы:
```python
Person.objects.all().delete()
```

## Фильтрация ##
Django предоставляет богатые возможности по фильтрации данных. Для фильтрации данных у объекта QuerySet могут применяться следующие методы:

- get(): получает один объект модели

- filter(): получает набор объектов модели, которые соответствуют условию. Результат метода - объект QuerySet

- exclude(): получает набор объектов модели, которые НЕ соответствуют условию. Результат метода - объект QuerySet

Все три метода в качестве параметра получают условию, по которому идет фильтрация. Рассмотрим, какие условия мы можем определить.

Допустим, в файле models.py определена следующая модель Person:
```python
models.py
_______________
from django.db import models
 
class Person(models.Model):
    name = models.CharField(max_length=20)
    age = models.IntegerField()
```
Самый простый простой тип условия преставляет равенство свойства модели некоторому значению,:
```python

from .models import Person
 
# получаем пользователя по имени
tom = Person.objects.get(name="Tom")
print(f"{tom.name} - {tom.age}")
 
# получаем пользователей, у которых возраст равен 32
people_by_age1 = Person.objects.filter(age=32)
for person in people_by_age1:
    print(f"{person.name} - {person.age}")
 
# получаем пользователей, у которых возраст НЕ равен 32
people_by_age2 = Person.objects.exclude(age=32)
for person in people_by_age2:
    print(f"{person.name} - {person.age}")
```
В первом случае ищем один объект по имени:
```
tom = Person.objects.get(name="Tom")
```
или поиск по возрасту
```
people_by_age1 = Person.objects.filter(age=32)
```
Но кроме обычного равенства свойств модели некоторому значению можно применять и другие условия. Они определяются с помощью спецификатора фильтрации, который указывается в условии после свойства модели через два знака подчеркивания:
```
свойство__спецификатор = значение
```
Рассмотрим спецификаторы, которые можно использовать.

### exact и iexact ###
- exact выбирает все объекты моделей, в которых свойство равно определенному значению. 
- inexact выполняет ту же самую задачу, только выборка значений не зависит от регистра:
```PYTHON
# получаем пользователя по имени Tom
tom = Person.objects.get(name__exact="Tom")
 
# получаем пользователей, у которых возраст равен 32
people_by_age = Person.objects.filter(age__exact=32)
 
# получаем пользователя по имени Tom или tom или TOM
tom = Person.objects.get(name__iexact="Tom")
```
Стоит учитывать, что в некоторых СУБД, например, в MySQL, поиск по строкам регистрозависимый, то есть "Tom" и "tom" - это две разные строки.

Если необходимо найти данные, где поле таблицы имеет значение NULL, то свойству модели передается значение None:
```python
# получаем пользователей, у которых имя равно NULL
people_by_name = Person.objects.filter(name__exact=None)
```
### contains и icontains ###
- contains находит строки, которые содержат некоторую подстроку, причем поиск регистрозависимый. 
- icontains выполняет аналогичную задачу, за тем исключением, что поиск не зависит от регистра:
```python
# получаем пользователей, у которых имя содержит букву o
people1 = Person.objects.filter(name__contains="o")
 
# получаем пользователей, у которых имя содержит букву T или t
people2 = Person.objects.filter(name__icontains="T")
```
### in ###
in находит модели со свойством, значение которого равно одному из значений из списка:
```python
# получаем пользователей, у которых возраст равен или 32, или 35, или 38, 
people = Person.objects.filter(age__in=[32, 35, 38])
```
### gt, gte, lte, lt ###
Ряд спецификаторов позволяют найти объекты, свойства которых больше или меньше определенного значения: gt (больше чем), gte (больше чем или равно), lt (меньше чем), lte (меньше чем или равно):
```python
# получаем пользователей, у которых возраст меньше или равен 32 
people = Person.objects.filter(age__lte=32)

# получаем пользователей, у которых возраст больше 40
people = Person.objects.filter(age__gt=40)
```
### startswith и istartswith ###
startswith выбирает объекты моделей со значениями, которые начинаются на определенную строку. Выборка зависит от регистра.

istartswith выполняет ту же задачу, только выборка не зависит от регистра.
```python
# получаем пользователей, у которых имя начинается с To
people = Person.objects.filter(name__startswith="To") 
 
# получаем пользователей, у которых имя начинается с To или to
people = Person.objects.filter(name__istartswith="To")
```
### endswith и iendswith ###
endswith выбирает объекты моделей со значениями, которые начинаются на определенную строку. Выборка зависит от регистра.

iendswith выполняет ту же задачу, только выборка не зависит от регистра.
```python
# получаем пользователей, у которых имя заканчивается на m
people = Person.objects.filter(name__endswith="m")
 
# получаем пользователей, у которых имя заканчивается на m или M
people = Person.objects.filter(name__iendswith="m")
```
### range ###
range определяет диапазон, в которое должно входить значение свойства модели:
```python
# получаем пользователей, у которых возраст в диапазоне от 28 до 38 включительно
people = Person.objects.filter(age__range=(28, 38))
```
### isnull ###
isnull выбирает объекты моделей, у которых поле в таблице имеет значение NULL (при значении True) или, наоборот, не имеет значение NULL (при значении False)
```python
# получаем пользователей, у которых имя не установлено
people = Person.objects.filter(name__isnull=True)
 
# получаем пользователей, у которых возраст установлен
people = Person.objects.filter(age__isnull=False)
```
### regex и iregex ###
regex и iregex задают регулярное выражение, которому должно соответствовать значение свойства модели. В случае с regex выборка зависит от регистра, а у iregex - не зависит от регистра.
```python
# получаем пользователей, у которых имя заканчивается на am или om
people = Person.objects.filter(name__regex=r"(am|om)$")
```
### спецификаторы дат ###
Целый ряд спецификаторов фильтрации предназначен для работы с датами:

- date: значение поля должно соответствовать определенной дате. Представляет объект datetime.date

- year: год даты должен соответствовать определенному значению.

- month: определяет месяц даты

- day: определяет день даты

- week: определяет номер недели даты (1-52 или 53)

- week_day: определяет день недели даты (от 1 (воскресенье) до 7 (суббота)

- iso_week_day: определяет день недели даты (от 1 (понедельник) до 7 (воскресенье)

- quarter: определяет номер квартала даты

- time: определяет время даты. Представляет объект datetime.time

- hour: определяет час даты (от 0 до 23)

- minute: определяет минуту даты (от 0 до 59)

- second: определяет секунду даты (от 0 до 59)

Все данные спецификаторы кроме date и time принимают целые числа. Допустим, у нас есть следующая модель:
```python
from django.db import models
 
class Order(models.Model):
    datetime = models.DateTimeField()
```
Получим заказы за определенные месяцы:
```python
from .models import Order
from datetime import datetime
 
# добавление начальных данных
if Order.objects.count() == 0:
    Order.objects.create(datetime = datetime(2021, 12, 26, 11, 25, 34))
    Order.objects.create(datetime = datetime(2022, 5, 12, 12, 25, 34))
    Order.objects.create(datetime = datetime(2022, 5, 22, 13, 25, 34))
    Order.objects.create(datetime = datetime(2022, 8, 19, 14, 25, 34))
 
# получаем заказы, сделанные в 5-м месяце
orders = Order.objects.filter(datetime__month=5)
for order in orders:
    print(order.datetime)
 
 
# получаем заказы, сделанные до 5-го месяца
orders = Order.objects.filter(datetime__month__gt=5)
for order in orders:
    print(order.datetime)
```
К спецификаторам дат можно добавлять дополнительные спецификаторы, чтобы конкретизировать условие, как во втором случае: datetime__month__gt=5

Поиск по дате и времени:
```python
from .models import Order
from datetime import datetime, date, time
 
if Order.objects.count() == 0:
    Order.objects.create(datetime = datetime(2021, 12, 26, 11, 25, 34))
    Order.objects.create(datetime = datetime(2022, 5, 12, 12, 25, 34))
    Order.objects.create(datetime = datetime(2022, 5, 22, 13, 25, 34))
    Order.objects.create(datetime = datetime(2022, 8, 19, 14, 25, 34))
 
# получаем заказы, сделанные 22 мая
orders = Order.objects.filter(datetime__date=date(2022, 5, 22))
for order in orders:
    print(order.datetime)
 
 
# получаем заказы, сделанные после 12 часов 
orders = Order.objects.filter(datetime__time__gt=time(12, 20, 0))
for order in orders:
    print(order.datetime)
```
## Логические операторы ##
Логические операторы позволяют скомбинировать две выборки. Имеются следующие логические операторы: AND (&), OR (|) и XOR (^)

Оператор AND (&) указывает, что оба условия должны быть истинными:
```python
people = Person.objects.filter(name="Tom") & Person.objects.filter(age=22)
```
В данном случае в базе данных будет идти поиск строки, в которой одновременно поле name равно "Tom" и поле age равно 22. А на уровне базы данных это будет выражение:
```python
SELECT ... WHERE name='Tom' AND age=22
```
Оператор OR (|) указывает, что достаточно, чтобы одно из двух условий было истинным:
```python
people = Person.objects.filter(name="Tom") | Person.objects.filter(age=22)
```
В данном случае в базе данных будет идти поиск строки, в которой либо поле name равно "Tom", либо поле age равно 22. А на уровне базы данных это будет выражение:
```python
SELECT ... WHERE name='Tom' OR age=22
```
Оператор XOR (^) указывает, что необходимо, чтобы только одно из двух условий было истинно:
```python
people = Person.objects.filter(name="Tom") ^ Person.objects.filter(age=22)
```
В данном случае в базе данных будет идти поиск строки, в которой истинно либо условие name="Tom", либо поле условие age=22, но не одновременно оба условия. На уровне базы данных могут формироваться различные выражения в зависимости от поддержки оператора XOR.
