# Модели #
## Подключение к базе данных ##

По умолчанию Django в качестве базы данных использует SQLite. Она очень проста в использовании и не требует запущенного сервера. Все файлы базы данных могут легко переноситься с одного компьютера на другой. Однако при необходимости мы можем использовать в Django большинство распространенных СУБД.

Для работы с базами данных в проекте Django в файле settings.py определен параметр DATABASES, который по умолчанию выглядит следующим образом:
```python
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}
```
Переменная DATABASES содержит набор конфигураций подключений к базам данных в виде словаря. Ключи в этом словаре - названия подключений. То есть мы можем определить кучу подключений. Но как минимум одно подключение должно быть определено в переменной DATABASES - подключение с именем default, которое представляет подключение по умолчанию.

Конфигурация каждого подключения может состоять из ряда параметров. По умолчанию указываются только два параметра. Параметр ENGINE указывает на используемый движок для доступа к БД. В данном случае это встроенный пакет django.db.backends.sqlite3.

Второй параметр - NAME указывает на путь к базе данных. По умолчанию база данных называется db.sqlite3. Для установки пути используется каталог из переменной BASE_DIR, которая задана в начале файла:
```python
BASE_DIR = Path(__file__).resolve().parent.parent
```
По умолчанию BASE_DIR указывает на каталог, в котором находится папка проекта. И после первого запуска проекта в указанном каталоге по умолчанию будет создан файл db.sqlite3, который собственно и будет использоваться в качестве базы данных.

## Поддерживаемые субд ##
Чтобы использовать другие системы управления базами данных, необходимо будет установить соответствующий пакет.
```
СУБД              Пакет                Команда установки

PostgreSQL      psycopg2             pip install psycopg2
MySQL           mysql-python         pip install mysql-python
Oracle          cx_Oracle            pip install cx_Oracle
```
## Параметры подключения ##
Выше в настройках по умолчанию применялись только два параметра: ENGINE и NAME. Однако при необходимости можно указать и дополнительные параметры:

- ATOMIC_REQUESTS: при значении True обертывает каждый запрос к бд в транзакцию. По умолчанию равно False

- AUTOCOMMIT: при значении False отключает систему управления транзакциями Django. По умолчанию равно True

- ENGINE: движок бд. Поддерживаются следующие встроенные движки:
```
- django.db.backends.postgresql
- django.db.backends.mysql
- django.db.backends.sqlite3
- django.db.backends.oracle
```
- HOST: хост базы данных

- NAME: имя базы данных, для sqlite - путь к бд

- CONN_MAX_AGE: время жизни подключения в секундах. Значение 0 закрывает подключение сразу после завершения каждого запроса к бд. А значение None указывает на постоянное подключение. По умолчанию равно 0

- CONN_HEALTH_CHECKS: при значении True проверяет активность подключения, и если оно закрыто, заново устанавливает соединение. По умолчанию равно False

- OPTIONS: дополнительный набор параметров, который может потребоваться при подключении к определенных базам данных.

- PASSWORD: пароль. По умолчанию равно '' (пустая строка)

- PORT: порт бд. По умолчанию равно ''

- TIME_ZONE: часовой пояс. По умолчанию равно None

- USER: имя пользователя. По умолчанию равно ''

- TEST: набор настроек в виде словаря для теста подключения

Для разных СУБД может потребоваться разный набор параметров. Например, подключение к БД Postgres в общем случае выглядит так:
```python
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': 'mydatabase',
        'USER': 'mydatabaseuser',
        'PASSWORD': 'mypassword',
        'HOST': '127.0.0.1',
        'PORT': '5432',
    }
}
```
## Миграции базы данных ##
При создании базы данных она еще пуста, не содержит никаких данных. Однако в консоли при запуске проекта мы можем увидеть некоторое сообщение, выделенное красным цветом.

Дело в том, что для ряда приложений, подключенных в проект по умолчанию, требуется база данных для сохранения некоторых своих данных. Так, в в файле settings.py в переменной INSTALLED_APPS по умолчанию указан ряд приложений
```python
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    # остальные приложения ......
    # ................
]
```
Первые четыре приложения так или иначе используют базу данных. Однако, чтобы базы данных создала нужные для этих приложений таблицы, необходимо выполнить миграции - специальные скрипты, которые изменяют стуруктуру базы данных. Для этого выполним в консоли команду
```
python manage.py migrate
```

Если после этого мы откроем базу данных db.sqlite3, которая есть в проекте, в какой-нибудь специальной программе для просмотра БД SQLite, то мы увидим, что она содержит ряд таблиц

Для просмотра и работы с базами данных SQLite можно использовать бесплатную программу DB Browser for SQLite, которая доступна для всех основных операционных систем.

В частности, можно увидеть, что база данных содержит более десятка таблиц и индексов. Все они связанных с системой аутентификации и авторизации, администрирования и сессиями. И даже если мы непосредственно не будем использовать базу данных, но будем использовать системы аутентификации и авторизации, админитсрирования или сессии, то для нормальной работы нам все равно потребуется база данных и необходимо будет выполнить миграции.

## Создание моделей ##
Модели в Django описывают структуру используемых данных. Используемые в программе данные хранятся в базах данных, и с помощью моделей как раз осуществляется взаимодействие с базой данных.

При создании приложения по умолчанию в его каталог добавляется файл models.py, который применяется для определения моделей. Модель представляет класс, унаследованный от django.db.models.Model.

Так, изменим файл models.py следующим образом:
```python
models.py
_______________
from django.db import models
 
class Person(models.Model):
    name = models.CharField(max_length=20)
    age = models.IntegerField()
```

Здесь определена простейшая модель, которая называется Person и которая представляет человека. В модели определены два поля. Поле name представляет тип CharField - текстовое поле, которое хранит последовательность символов. Оно будет хранить имя человека. Для CharField обязательно надо указать параметр max_length, который задает максимальную длину хранящейся строки. И поле age представляет тип IntegerField - числовое поле, которое хранит целые числа. Оно предназначено для хранения возраста человека.

Каждая модель сопоставляется с определенной таблицей в базе данных. Однако пока у нас нет в бд таблицы, которая хранит объекты модели Person. И в этом случае нам надо создать и выполнить миграцию. Миграция преобразует базу данных в соответствии с определением моделей.

Вначале необходимо создать миграцию с помощью команды
```
python manage.py makemigrations
```

После этого в приложении в папке migrations мы обнаружим новый файл, который будет иметь примерно следующее содержимое:
```python
from django.db import migrations, models
 
 
class Migration(migrations.Migration):
 
    initial = True
 
    dependencies = [
    ]
 
    operations = [
        migrations.CreateModel(
            name='Person',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(max_length=20)),
                ('age', models.IntegerField()),
            ],
        ),
    ]
```
Это и есть миграция. Здесь можно заметить, что создается не два, а три поля - поле id, которое будет представлять первичный ключ, добавляется по умолчанию. Поэтому в приниципе в самой модели нам не нужно явным образом определять какой-либо идентификатор.

Теперь надо выполнить данную миграцию. Для этого выполняется команда
```
python manage.py migrate
```
После этого, если мы откроем базу данных db.sqlite3, которая есть в проекте, то мы увидим, что в нее добавлена таблица для хранения данных модели Person:

Стоит учитывать, что в процессе работы над проектом определение модели может меняться - к ней могут добавляться новые поля, либо могут удаляться уже существующие, либо могут добавляться новые модели, данные которых мы также захотим хранить в базе данных. И в этом случае опять надо создавать миграцию и применять ее к базе данных, чтобы база данных была синхронизирована с определением моделей.

## Типы полей моделей ##
Для определения моделей мы можем использовать следующие типы полей:

- BinaryField(): хранит бинарные данные

- BooleanField(): хранит значение True или False (0 или 1)

- NullBooleanField(): хранит значение True или False или Null

- DateField(): хранит дату

- TimeField(): хранит время

- DateTimeField(): хранит дату и время

- DurationField(): хранит период времени

- AutoField(): хранит целочисленное значение, которое автоматически инкрементируется, обычно применяется для первичных ключей

- BigAutoField(): хранит 64-битное целочисленное значение, но в отличие от AutoField гарантирует, что число входит в диапазон от 1 до 9223372036854775807.

- SmallAutoField(): хранит 16-битное целочисленное значение в диапазоне от 1 до 32767

- BigIntegerField(): представляет число - значение типа Number, которое укладывается в диапазон от -9223372036854775808 до 9223372036854775807. В зависимости от выбранной СУБД диапазон может немного отличаться

- DecimalField(decimal_places=X, max_digits=Y): представляет значение типа Number, которое имеет максимум X разрядов и Y знаков после запятой

- FloatField(): хранит, значение типа Number, которое представляет число с плавающей точкой

- IntegerField(): хранит значение типа Number, которое представляет целочисленное значение

- PositiveIntegerField(): хранит значение типа Number, которое представляет положительное целочисленное значение (от 0 до 2147483647)

- PositiveBigIntegerField(): хранит значение типа Number, которое представляет положительное 64-битное целочисленное значение (от 0 до 9223372036854775807)

- PositiveSmallIntegerField(): хранит значение типа Number, которое представляет небольшое положительное целочисленное значение (от 0 до 32767)

- SmallIntegerField(): хранит значение типа Number, которое представляет небольшое целочисленное значение (от -32768 до 32767)

- CharField(max_length=N): хранит строку длиной не более N символов

- TextField(): хранит строку неопределенной длины

- EmailField(): хранит строку, которая представляет email-адрес. Значение автоматически валидируется встроенным валидатором EmailValidator

- FileField(): хранит строку, которая представляет имя файла

- FilePathField(): хранит строку, которая представляет путь к файлу длиной в 100 символов

- ImageField(): хранит строку, которая представляет данные об изображении

- GenericIPAddressField(): хранит строку, которая представляет IP-адрес в формате IP4v или IP6v

- SlugField(): хранит строку, которая может содержать только буквы в нижнем регистре, цифры, дефис и знак подчеркивания

- URLField(): хранит строку, которая представляет валидный URL-адрес

- UUIDField(): хранит строку, которая представляет UUID-идетификатор

- JSONField(): хранит данные в формате JSON, которая представляет UUID-идетификатор

Таблица сопоставления полей с типами в различных СУБД:
```
Тип                         SQLite              MySQL              PostgreSQL                        Oracle

BinaryField()            BLOB NOT NULL     longblob NOT NULL      bytea NOT NULL                      BLOB NULL
BooleanField()           bool NOT NULL     bool NOT NULL          boolean NOT NULL                    NUMBER(1) NOT NULL CHECK("Значение" IN(0,1))
NullBooleanField()       bool NULL         bool NULL              boolean NULL                        NUMBER(1) NOT NULL CHECK(("Значение" IN(0,1)) OR ("Значение" IS NULL))
DateField()              date NULL         date NULL              date NULL                           DATE NOT NULL
TimeField()              time NULL         time NULL              time NULL                           TIMESTAMP NOT NULL
DateTimeField()          datetime NULL     datetime NULL          timestamp NULL                      TIMESTAMP NOT NULL
DurationField()          bigint NOT NULL   bigint NOT NULL        interval NOT NULL                   INTERVAL DAY(9) TO SECOND(6) NOT NULL
AutoField()              integer NOT NULL  AUTOINCREMENT          integer AUTO_INCREMENT NOT NULL     serial NOT NULL NUMBER(11) NOT NULL
BigIntegerField          bigint NOT NULL   bigint NOT NULL        bigint NOT NULL                     NUMBER(19) NOT NULL

DecimalField (decimal_places=X, max_digits=Y)   decimal NOT NULL    numeric(X, Y) NOT NULL   numeric(X, Y) NOT NULL    NUMBER(10, 3) NOT NULL

FloatField            real NOT NULL     double precision NOT NULL   double precision NOT NULL      DOUBLE PRECISION NOT NULL
IntegerField          integer NOT NULL   integer NOT NULL           integer NOT NULL               NUMBER(11) NOT NULL
PositiveIntegerField  integer unsigned NOT NULL    integer UNSIGNED NOT NULL   integer NOT NULL CHECK ("Значение" > 0)   NUMBER NOT NULL CHECK ("Значение" > 0)
PositiveSmallIntegerField   smallint unsigned NOT NULL   smallint UNSIGNED NOT NULL   smallint NOT NULL CHECK ("Значение" > 0)  NUMBER(11) NOT NULL CHECK ("Значение" > 0)

SmallIntegerField        smallint NOT NULL      smallint NOT NULL       smallint NOT NULL         NUMBER(11) NOT NULL
CharField(max_length=N)  varchar(N) NOT NULL    varchar(N) NOT NULL     varchar(N) NOT NULL       NVARCHAR2(N) NULL
TextField()              text NOT NULL           longtext NOT NULL         text NOT NULL           NCLOB NULL
EmailField()           varchar(254) NOT NULL    varchar(254) NOT NULL    varchar(254) NOT NULL    NVARCHAR2(254) NULL
FileField()            varchar(100) NOT NULL    varchar(100) NOT NULL    varchar(100) NOT NULL    NVARCHAR2(100) NULL
FilePathField()        varchar(100) NOT NULL    varchar(100) NOT NULL    varchar(100) NOT NULL    NVARCHAR2(100) NULL
ImageField()           varchar(100) NOT NULL    varchar(100) NOT NULL    varchar(100) NOT NULL    NVARCHAR2(100) NULL
GenericIPAddressField()   char(39) NOT NULL     char(39) NOT NULL        inet NOT NULL            VARCHAR2(39) NULL
SlugField()             varchar(50) NOT NULL    varchar(50) NOT NULL     varchar(50) NOT NULL     NVARCHAR2(50) NULL
URLField()             varchar(200) NOT NULL    varchar(200) NOT NULL    varchar(200) NOT NULL    NVARCHAR2(200) NULL
UUIDField()             char(32) NOT NULL       char(32) NOT NULL        uuid NOT NULL            VARCHAR2(32) NULL
JSONField()                                                              jsonb
```

## QuerySet API ##
В центре работы с моделями и базы данными находится объект QuerySet и его методы. QuerySet представляет набор запросов к базе данных, а его методы создают подобные запросы. А Django позволяет транслировать вызовы методов QuerySet в соответствующие SQL-запросы. Отмечу основые методы, которые можно применять для работы с данными моделей:

- filter(): фильтрует набор данных и возвращает выборку данных, которая соответствует фильтру, также в виде объекта QuerySet

- exclude(): фильтрует набор данных и возвращает выборку, которая НЕ соответствует фильтру, в виде объекта QuerySet

- order_by(): сортирует набор данных и возвращает отсортированную выборку в виде объекта QuerySet

- distinct(): возвращает объект QuerySet, который содержит только уникальные объекты

- values(): возвращает данные объектов в виде словаря

- values_list(): возвращает данные объектов в виде списка

- none(): возвращает пустой набор данных в виде объекта EmptyQuerySet (класс производный от QuerySet)

- all(): возвращает объект QuerySet, который содержит все объекты из таблицы

- union(): объединяет два объекта QuerySet и возвращает объединенный объект QuerySet

- intersection(): возвращает пересечение двух объектов QuerySet в виде другого QuerySet

- difference(): возвращает разность двух объектов QuerySet в виде другого QuerySet

- raw(): выполняет переданный в качестве параметра SQL-запрос

- get(): возвращает один объект модели

- create(): создает один объект модели

- get_or_create(): возвращает один объект модели по указанным параметрам, а если он отсутствует, то создает его

- update_or_create(): обновляет один объект модели по указанным параметрам, а если он отсутствует, то создает его

- bulk_create(): создает набор объектов модели

- save(): сохраняет один объект модели (если он ранее остутствовал в БД, то добавляет его, есть присутствовал, то обновляет его)

- bulk_update(): обновляет набор объектов

- count(): возвращает количество объектов в наборе

- in_bulk(): возвращает словарь объектов, которые имеют определенные идентификаторы

- latest(): возвращает объект с самыми последними изменениями

- earliest(): возвращает объект с самыми ранними изменениями

- first(): возвращает первый объект набора

- last(): возвращает последний объект набора

- aggregate(): выполняет агрегатную функцию (нахождение суммы, среднего, минимального, максимального значения и т.д.) и возвращает результат в виде числа

- exists(): проверяет, есть ли в наборе как минимум один объект. Если есть, то возвращается True, иначе возвращается False

- contains(): проверяет, есть ли в наборе определенный объект. Если есть, то возвращается True, иначе возвращается False

- update(): обновляет один объект модели

- delete(): удаляет один объект модели

Полный список методов можно найти в документации.

Причем выполнение методов QuerySet в базе данных происходит не сразу - при вызове метода, а при получение конкретного результата их QuerySet, например, при переборе набора. Посмотрим выполнение методов на примере. Допустим, в файле models.py определена следующая модель Person:
```python
models.py
_______________
from django.db import models
 
class Person(models.Model):
    name = models.CharField(max_length=20)
    age = models.IntegerField()
```
Для упрощения протестируем код в файле views.py, код которого вызывается при запуске приложения. В частности, определим в нем следующий код:
```python
views.py
_______________
from .models import Person
 
# получаем все объекты
people = Person.objects.all()
print(people.query)
 
# получаем объекты с именем Tom
people = people.filter(name = "Tom")
print(people.query)
 
# получаем объекты с возрастом, равным 31
people = people.filter(age = 31)
print(people.query)
 
# здесь происходит выполнения запроса в БД
for person in people:
    print(f"{person.id}.{person.name} - {person.age}")
```

Сначала идет получение всех данных с помощью метода all():
```python
people = Person.objects.all()
```
Переменная people здесь будет представлять объект QuerySet, который представляет набор из всех объектов таблицы.

С помощью свойства query у результата запроса мы можем получить SQL-запрос и, например, вывести его на консоль:
```
print(people.query)
```
Затем фильтруем набор с помощью метода filter() и выбираем только те объекты, где поле name равно "Tom":
```python
people = people.filter(name = "Tom")
```
Метод filter также возвращает QuerySet, который присваивается той же переменной people.

Затем выбираем только те объекты, где поле name равно "Tom":
```python
people = people.filter(age = 31)
```
Таким образом, к набору QuerySet были применены три метода, однако ни в одном случае не происходит обращения к базе данных. Это происходит, только когда мы непосредственно обращаемся к объектам набора, перебирая их в цикле.
```python
for person in people:
    print(f"{person.id}.{person.name} - {person.age}")
```
А по консольному выводу мы можем увидеть, как у нас создается финальный SQL-запрос, который и будет выполняться в БД при переборе объектов в цикле.

## Создание и получение объектов модели ##
Рассмотрим добавление в базу данных и получение из нее на примере модели Person:
```python
from django.db import models
 
class Person(models.Model):
    name = models.CharField(max_length=20)
    age = models.IntegerField()
```
## Добавление данных ##
### create ###
Для добавления данных применяется метод create():
```
tom = Person.objects.create(name="Tom", age=23)
```
Если добавление пройдет успешно, то объект будет иметь id, который можно получить через tom.id.

Асинхронная версия метода - acreate
```python
from .models import Person
import asyncio
  
async def acreate_person():
    person = await Person.objects.acreate(name="Tim", age=26)
    print(person.name)
 
# запускаем асинхронную функцию acreate_person
asyncio.run(acreate_person())
```
### save ###
Однако в своей сути метод create() использует другой метод - save(), который мы также можем использовать отдельно для добавления объекта:
```python
tom = Person(name="Tom", age=23)
tom.save()
```
После успешного добавления также можно получить идентификатор добавленной записи с помощью tom.id.

### bulk_create() ###
Метод bulk_create() (и его асинхронная версия abulk_create()) позволяет добавить набор объектов, который передается в в метод в качестве параметра:
```python
from .models import Person
  
people = Person.objects.bulk_create([
    Person(name="Kate", age=24),
    Person(name="Ann", age=21),
])
 
for person in people:
    print(f"{person.id}. {person.name}")
```
### Получение из бд ###
- Получение одного объекта
Метод get() возвращает один объект по определенному условию, которое передается в качестве параметра:
```
tom = Person.objects.get(name="Tom")    # получаем запись, где name="Tom"
bob = Person.objects.get(age=23)        # получаем запись, где age=42
```
При использовании этого метода надо учитывать, что он предназначен для выборки таких объектов, которые имеются в единичном числе в базе данных. Если в таблице не окажется подобного объекта, то мы получим ошибку имя_модели.DoesNotExist. Если же в таблице будет несколько объектов, которые соответствуют условию, то будет сгенерированно исключение MultipleObjectsReturned. Поэтому следует применять данный метод с осторожностью, либо применять обработку соответствующих исключений:
```python
from .models import Person
from django.core.exceptions import ObjectDoesNotExist, MultipleObjectsReturned
 
try:
    tom = Person.objects.get(name="Tom")    # MultipleObjectsReturned
    alex = Person.objects.get(name="Alex")  # ObjectDoesNotExist
except ObjectDoesNotExist:
    print("Объект не сушествует")
except MultipleObjectsReturned:
    print("Найдено более одного объекта")
```
- Асинхронная версия метода называется aget:
```python
from .models import Person
import asyncio
  
async def get_person():
    person = await Person.objects.aget(id=1)
    print(person.name)
 
# запускаем асинхронную функцию get_person
asyncio.run(get_person())
```
### get_or_create ###
Метод get_or_create() (и его асинхронная версия aget_or_create) возвращает объект, а если его нет в бд, то добавляет в бд новый объект.
```python
bob, created = Person.objects.get_or_create(name="Bob", age=24)
print(created)
print(bob.name)
print(bob.age)
```
В данном случае, если в таблице нет объекта со значениями name="Bob" и age=24, то он добавляется. Если есть, то он возвращается.

Метод возвращает добавленный объект (в данном случае переменная bob) и булевое значение (created), которое хранит True, если добавление прошло успешно.

Стоит учитывать, что если в таблице уже есть несколько объектов (два и больше) с указанными значениями, то сгенерируется исключение MultipleObjectsReturned.

### all() ###
Если необходимо получить все имеющиеся объекты, то применяется метод all():
```python
people = Person.objects.all()
```
Данный метод возвращает объект типа QuerySet.

### filter() ###
Если надо получить все объекты, которые соответствуют определенному критерию, то применяется метод filter(), который в качестве параметра принимает критерий выборки:
```python
people = Person.objects.filter(age=23)
# использование нескольких критериев
people2 = Person.objects.filter(name="Tom", age=23)
```
Метод filter позволяет определять более сложные условия, но поскольку это отдельная большая тем, то подробнее будет рассмотрена в отдельной статье.

### exclude() ###
Метод exclude() позволяют исключить из выборки записи, которые соответвуют переданному в качестве параметра критерию:
```python
# исключаем пользователей, у которых age=23
people = Person.objects.exclude(age=23)
```
Можно комбинировать два выше рассмотренных метода:
```python
# выбираем всех пользователей, у которых name="Tom" кроме тех, у которых age=23
people = Person.objects.filter(name="Tom").exclude(age=23)
```
### in_bulk() ###
Метод in_bulk() (и его асинхронная версия ain_bulk) является более эффективным способом для чтения большого количества записей. В качестве параметра в него можно передать список идентификаторов объектов, которые надо получить. В качестве результата он возвращает словарь, то есть объект dict:
```python
# получаем все объекты
people = Person.objects.in_bulk()
for id in people:
    print(people[id].name)
    print(people[id].age)
 
# получаем объекты с id=1 и id=3
people2 = Person.objects.in_bulk([1,3])
for id in people2:
    print(people2[id].name)
    print(people2[id].age)
```
Метод in_bulk() возвращает словарь, где ключи представляют id объектов, а значения по этим ключам - собственно эти объекты, то есть в данном случае объекты Person.

### Ограничение количества ###
С помощью синтаксиса списков можно получить определенную порцию данных из QuerySet:
```python
from .models import Person
 
people = Person.objects.all()[:5]
```
В данном случае выбираем первые 5 объектов, что на уровне базы данных транслируется в SQL-выражение LIMIT 5

Первый параметр указывает, сколько объектов надо пропустить:
```python
from .models import Person
 
people = Person.objects.all()[5:10]
for person in people:
    print(f"{person.id}.{person.name} - {person.age}")
```
В данном случае пропускаем первые 5 объектов и выбираем следующие 5 объектов до 10-го индекса, что на уровне базы данных транслируется в выражение OFFSET 5 LIMIT 5
