# Запускаем пайчарм, новый проект.
# У нас создался проект и появился файл main.py
# дальше работаю в этом файле.
# Открываем терминал (нижняя панель -> terminal):
# (venv) C:\Users\777\Desktop\практика\python\educationCourseAll.py> | (и мигающий курсор)
# далее пишем
# (venv) C:\Users\777\Desktop\практика\python\educationCourseAll.py>pip install flask
# ентер -> идёт процесс установки.
# Мы установили web framework FLASK
# импортируем его:
from flask import Flask
# создаём экземпляр нашего приложения.
# вебсервер на котором будет находится наше веб приложение
# все запросы от поситителей, пользователей вашего веб приложения
# будет передавать этому объекту через протокол,
# который называется web server getway interface (WSGI)
# экземпляр приложения - это объект класса Flask,
# который обычно создаётся следующим образом:
app = Flask(__name__)
# app = указываем конструктор класса.
# в скобочках передаём туда единственный необходимый обязательный аргумент: (__name__)
# с помощью этой переменной фреймворк flask сможет определить пути к корневому каталогу
# для того чтобы отуда брать файлы ресурсов.
# Только что мы создали наш объект app, который и будет являться нашим вебприложением.
# Пользователи нашего вебприложения через веб браузер отправляют запросы вебсерверу,
# который перенаправляет эти запросы нашему экземпляру приложения.
# Экземпляр приложения должен понять какой же код должен быть выполнен,
# для того чтобы обработать эти обращения по URL адресу.
# Поэтому он должен хранить отображения адресов URL в функции на языке пайтон.
# Ассоциацию между адресом URL и функцией называют маршрутом.
# для того чтобы определить маршрут в приложение, используя Flask
# можно воспользоваться декоратором app.route
# Такой декоратор зарегистрирует декорируемую функцию как маршрут.
# Пример для главной страници нашего вебприложения
# создаём декоратор @
@app.route('/')
def index():
    return '<h1>Hello World!</h1>'
# В скобочках в ковычках мы указываем URL для нашей главной страницы.
# Поэтому там просто слэш / и с помощью декоратора мы с вами определяем функцию def index
# что мы будем возвращять нашему пользователю? вернём ему просто hallo world. выведим это в заголовке h1
# декораторы это стандартная особенность языка пайтон с помощью которых можно изменять поведения функций.
# Обычно декораторы используются для регистрации функций в качестве обработчика событий.
# Мы с вами зарегестрировали обработчик событий - запросов к корневому URL
# т.е к главной странице нашего сайта
# используя декоратор @app.route('/')
# мы зарегестрировали обработчик событий
# def index():
#     return '<h1>Hello World!</h1>'
# при обращении к этой ссылке '/' т.е функция будет выполняться
# когда мы обратимся к главной странице нашего сайта.
# Такую функцию можно называть функцией представления view functions.
# Ответ который возвращается этой функцией предатсавления может быть
# простой строкой с разметкой html и может иметь более сложную форму.

# Ещё одна обработка URL которая будет включать в себя какой то параметр,
# котрый пользователь может вводить и передавать к нам в программу.
# предположим это будет имя пользователя
# делаем новый декоратор
@app.route('/user/<name>')
def user(name):
    return '<h1>PRIVET!, %s! </h1>' % name
# и предположим наша ссылка уже будет вести по такому пути ('/user/<name>')
# будем принимать в качестве аргумента имя пользователя (<name>)
# Это <name> будет передаваться в нашу функцию, в наше пердставление.
# Создаём функцию пердатсавления def user(name):
# возвращать пользователю будем надпись: привет пользователь такой то

# теперь когда мы обратимся по этому url : /user/<name>
# мы с вами получим вывод на экран с помощью этого представления:
# def user(name):
#     return '<h1>PRIVET!, %s! </h1>' % name

# теперь давайте запустим наш сервер
# Экземпляр приложения имеет метод RUN?
# который запускает интегрированный вебсервер,
# который используется только для веб разработки
# т.е это недопродакшн решение
if __name__ == '__main__':
    app.run(debug=True)
# if __name__ == '__main__': - эта часть гарантирует
# что вебсервер для разработки будет запускаться  только тогда,
# когда вы будте непосредственно выполнять этот сценарий.
# когда же он заимпортируется другим сценарием,
# то будет предполагаться что родительский сценарий запустит другой сервер,
# поэтому этот вызов пропустится. т. е эта часть
# if __name__ == '__main__':
#     app.run()
# выполняется только тогда, когда запускаю этот файл Flask_lesson

# метод app.run() имеет несколько необязательных аргументов
# для того чтобы можно было настроить режим работы вебсервера.
# Например можем включить отладчик и перезагрузчик.
# для этого
# app.run(debug=True) тогда у нас включится режим отладки.
# запустим программу run. Получаем:

# * Serving Flask app 'FLASK_Lesson' (lazy loading)
#  * Environment: production
#    WARNING: This is a development server. Do not use it in a production deployment.
#    Use a production WSGI server instead.
#  * Debug mode: on
#  * Restarting with stat
#
#  * Debugger is active!
#  * Debugger PIN: 786-843-214
#  * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)

# наше приложение запустилось и оно продолжает работать.
# обратите внимание: дебагер активен и
# у нас запущено приложение по такому порту: http://127.0.0.1:5000/
# наш айпишник локальный 127.0.0.1 локал хост и порт 5000
# для того чтобы прервать выполнение нашего приложения
# необходимо нажать CTRL+C.
# теперь мы можем с вами проверить работу нашего приложения
# переходим по ссылке http://127.0.0.1:5000/
# - > отображается главная страница нашего сайта
# часть кода которая формируется с помощью декоратора
# @app.route('/') , который обслуживает главную страницу сайта.
# и эта страница генерируется функцией представления,
# возвращая нам Hello world.
# Проверим более сложную ссылку
# наберём в адресной строке браузера: http://127.0.0.1:5000/user/Yurgen
# в логах это тоже всё отобразилось:
# 127.0.0.1 - - [17/Jun/2021 13:56:50] "GET /user/Yurgen HTTP/1.1" 200 -
# запрос "GET /user/Yurgen HTTP/1.1" 200
# ответ сервера 200 т.е мы с вами получили данные
# ПКМ по PRIVET!, YURGEN --> исследовать элемент -- > консоль .
# Наше первое веб приложение работает

