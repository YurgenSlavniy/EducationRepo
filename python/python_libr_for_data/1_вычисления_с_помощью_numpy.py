# -*- coding: utf-8 -*-
"""1. Вычисления с помощью Numpy.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/13raG-UUGjOnwiY7f3ehjgP1IjLlLE3T9

# Вычисления с помощью NumPy

## Многомерные массивы в NumPy

Библиотека `numpy` поддерживает работу с многомерными массивами, в том числе, с матрицами, и очень хороша для научных расчётов. Библиотека написана не только на `Python`, но и на языке `C`, который является более низкоуровневым и работает значительно быстрее, поэтому расчёты в `numpy` производятся во много раз быстрее, чем если бы мы использовали для этого стандартные структуры данных из `Python`.

Установить библиотеку `numpy` можно следующим образом:

* Если вы используете `Python` в составе дистрибутива `Anaconda`, то достаточно в командной строке ввести:   
`conda install numpy`

* Если вы используете `Python` отдельно, то же самое можно сделать с помощью пакетного менеджера `pip`:   
`pip install numpy`
"""

import numpy as np

"""Чтобы задать `numpy`-массив, достаточно задать обычный питоновский список `list`, а затем поместить его внутрь функции `np.array`:"""

a = np.array([1, 2, 3])

print(a)

"""Внутрь этой функции можно подавать также питоновский кортеж `tuple`.

Проверим, к какому типу относится массив `a`:
"""

type(a)

"""`ndarray` - сокращение от $n$-dimensional array ($n$-мерный массив).

В отличие от стандартных питоновских структур данных, в `numpy` массивы предпочитают данные одного типа. Например, если функция `np.array` вызывается от списка, содержащего как целые (`int`), так и дробные (`float`) значения, то в результирующем массиве все значения будут приведены к типу `float`. Аналогично, если в подаваемом списке есть хотя бы одна строка `str`, то в соответствующем массиве все значения будут приведены к типу `str`. Если мы хотим задать свой тип, к которому нужно привести данные, это можно сделать с помощью аргумента `dtype`:
"""

a = np.array([1, 2, 3.6], dtype=str)

print(a)

"""Получить конкретный элемент массива можно теми же способами, что и в стандартных питоновских структурах данных - с помощью квадратных скобок. В `numpy`, как и во всём питоне, индексация начинается с нуля. Например, получить второй элемент из массива `a` (т.е. элемент с индексом $1$) можно так:"""

a[1]

"""Также в `numpy` массивах можно использовать отрицательную индексацию и делать срезы, как и в стандартных списках из питона:"""

a[-1]

a[1:3]

"""### Двумерные массивы

Пока что мы работали лишь с одномерными массивами. Также в `numpy` можно задать и многомерные массивы. Например, двумерный массив - это массив, каждый элемент из которого - это снова массив.

Для `numpy`-массива `a` можно проверить его размерность с помощью атрибута `ndim` и форму с помощью атрибута `shape`:
"""

print("Размерность a: {}".format(a.ndim))

print("Форма a: {}".format(a.shape))

"""В этом случае размерность равна $1$, а `shape` возвращает кортеж из одного элемента. Зададим теперь двумерный массив:"""

A = np.array([[1, 2, 3, 1], 
              [4, 5, 6, 4], 
              [7, 8, 9, 7]])

print(A)

print("Размерность A: {}".format(A.ndim))

print("Форма A: {}".format(A.shape))

"""Атрибут `shape` - это всегда кортеж, размер которого равен размерности массива. Каждый элемент этого кортежа - это размер в каждом измерении. Например, у нашей матрицы $A$, судя по этому атрибуту, $3$ строки и $4$ столбца.

С помощью атрибута `size` можно увидеть общее количество элементов массива:
"""

A.size

"""В случае вложенных друг в друга стандартных питоновских списков `list`, чтобы получить конкретный элемент массива, нужно использовать несколько пар квадратных скобок: `A[0][0]`. В `numpy` массивы также поддерживают такую запись, однако, здесь есть и более удобный вариант - просто писать индексы через запятую:"""

A[0, 0]

"""Это же работает и в случае отрицательной индексации и в случае срезов:"""

A[-1, -2]

A[1:, :3]

"""В случае срезов для `numpy`-массивов важно отметить, что, записывая срез `numpy`-массива, мы ничего нового не создаём, мы лишь получаем _представление_ (_view_) - ссылку на какие-то отдельные элементы оригинального массива. Это означает, что если мы "создали" срез из `numpy`-массива, а затем поменяли в нём что-то - эти изменения коснутся и оригинального массива:"""

print(A)

B = A[1:, :3]

print(B)

B[0, 0] = -4

print(A)

"""Наоборот, если мы меняем значения в оригинальном массиве, они коснутся и всех его представлений, в которых используются эти значения:"""

A[2, 0] = -7

print(B)

b = np.array([[3], 
     [1], 
     [2]])

"""Если мы хотим всего этого избежать и создать действительно новый массив, нужно использовать метод `copy`:"""

C = A[1:3, 2:4].copy()

print(C)

C[0, 0] = -6

print(A)

"""### Типы данных в NumPy

Самыми распространёнными типами в `numpy` являются два целочисленных типа: `np.int32` и `np.int64` и два дробных типа: `np.float32` и `np.float64`. Они применяются для, соответственно, $32$-битных и $64$-битных чисел. Последние требуют вдвое больше памяти, чем первые, однако, если вы знаете, что в вашем массиве, например, используются целые числа, которые по модулю больше, чем $2 \cdot 10^9$, то стоит использовать `np.int64`.

## Применение NumPy в линейной алгебре

### Векторы

Для начала разберёмся с тем, как с помощью `numpy` работать с векторами. Зададим несколько векторов:
"""

a = np.array([0, 1, 2, 3, 4])
b = np.array([5, 6, 7, 8, 9])

"""Сейчас мы ограничимся случаем, когда все векторы имеют одинаковый размер.

Сложение векторов можно выполнять, просто складывая массивы. Отметим, что это поведение отличается от сложения обычных питоновских списков `list`: списки в таком случае просто склеиваются в один.
"""

a_ = [0, 1, 2, 3, 4]
b_ = [5, 6, 7, 8, 9]

c_ = a_ + b_

print(c_)

"""В `numpy` же массивы в результате такой операции складываются поэлементно:"""

c = a + b

print(c)

"""Также массивы `numpy` можно складывать с помощью функции `np.add`:"""

c = np.add(a, b)

print(c)

"""Аналогично, есть два способа вычитать векторы друг из друга:

* `d = a - b`
* `d = np.subtract(a, b)`

Для умножения вектора на скаляр также можно пользоваться достаточно естественной записью:
"""

e = a * 3

print(e)

"""При этом скаляр может быть каким угодно. При умножении на скаляр, каждая координата вектора умножается на этот скаляр.

Это поведение тоже отличается от поведения питоновских списков `list` при умножении на число. Последние при этом дублируются заданное количество раз. Скаляр здесь, кроме того, может быть только положительным целым.
"""

[1, 2, 3] * 3

"""Вот ещё несколько способов умножить вектор на скаляр в `numpy`:

* с помощью функции `np.multiply`: `e = np.multiply(a, 3)`
* с помощью функции `np.dot`: `e = np.dot(a, 3)`
* с помощью метода `a.dot`, который есть у любого `numpy`-массива: `e = a.dot(3)`

Функция `np.dot` (так же, как и метод `a.dot`), кроме того, может вычислять скалярное произведение векторов, а также произведение матриц (об этом чуть позже). 

Посчитаем скалярное произведение векторов `a` и `b`. Напомним, что чтобы вычислить скалярное произведение двух векторов, нужно попарно перемножить их координаты (первую с первой, вторую со второй и т.д.), а затем сложить результаты.
"""

sp = a.dot(b)

print(sp)

"""Также скалярное произведение векторов можно вычислять с помощью оператора `@`:"""

sp = a @ b

print(sp)

"""### Матрицы

Разберёмся теперь, как в `numpy` работать с матрицами. Зададим пару матриц:
"""

A = np.array([[0, 1],
              [2, 3],
              [4, 5]])

B = np.array([[6, 7],
              [8, 9],
              [10, 11]])

"""Матрицы одинакового размера можно складывать и вычитать. Как и с векторами, это можно делать с помощью операторов `+` и `-`, а также с помощью функций `np.add` и `np.subtract`."""

C = A + B

print(C)

D = A - B

print(D)

"""Матрицу любого размера можно умножать на скаляр. Делается это так же, как и в случае векторов:"""

E = A * 3

print(E)

"""### Умножение матриц

Матрицы $A$ и $B$ можно умножить друг на друга, если _число столбцов_ первой матрицы равняется _числу строк_ второй матрицы. То есть если $A$ - матрица размера $n \times k$, то матрица $B$ должна иметь размер $k \times m$ для некоторого $m$.

В таком случае результатом умножения будет матрица $C$ размера $n \times m$ (т.е. у неё будет строк как у первой матрицы, а столбцов - как у второй).

Рассмотрим простейший случай: умножение строки (матрицы размера $1 \times k$) на столбец (матрицу размера $k \times 1$). Как мы уже выяснили, в результате получится матрица размера $1 \times 1$, т.е. число. Что это за число?

Чтобы посчитать это число, нужно элементы из строки и столбца попарно перемножить (первый с первым, второй со вторым и т.д.), а затем сложить результаты. Это очень похоже на скалярное произведение векторов.

Например, 

$$
\left(
\begin{matrix}
    1 & 2 & 3
\end{matrix}
\right)
\cdot
\left(
\begin{matrix}
    1 \\
    0 \\
    -1
\end{matrix}
\right)
= 1 \cdot 1 + 2 \cdot 0 + 3 \cdot (-1)
= -2.
$$

Вернёмся к общему случаю - умножению матрицы размера $n \times k$ на матрицу размера $k \times m$. Мы уже поняли, что это будет матрица размера $n \times m$. Как "заполнить" эту матрицу?

Чтобы получить число, стоящее в этой матрице на позиции $(i, j)$, нужно умножить $i$-ю строку первой матрицы на $j$-й столбец второй матрицы (так, как мы это делали выше).

Например,

$$
\left(
\begin{matrix}
    1 & 0 & -1 \\
    3 & 5 & -4 
\end{matrix}
\right)
\cdot
\left(
\begin{matrix}
    1 & 2 & 3 \\
    4 & 5 & 6 \\
    7 & 8 & 9
\end{matrix}
\right)
=
\left(
\begin{matrix}
    1 \cdot 1 + 0 \cdot 4 + (-1) \cdot 7 & 1 \cdot 2 + 0 \cdot 5 + (-1) \cdot 8 & 1 \cdot 3 + 0 \cdot 6 + (-1) \cdot 9 \\
    3 \cdot 1 + 5 \cdot 4 + (-4) \cdot 7 & 3 \cdot 2 + 5 \cdot 5 + (-4) \cdot 8 & 3 \cdot 3 + 5 \cdot 6 + (-4) \cdot 9
\end{matrix}
\right)
=
$$

$$
=
\left(
\begin{matrix}
    -6 & -6 & -6 \\
    -5 & -1 & 3
\end{matrix}
\right).
$$

Чтобы выполнять умножение матриц в библиотеке `numpy`, будем пользоваться уже знакомой функцией `np.dot`, либо методом `A.dot`:
"""

A = np.array([[1, 0, -1],
              [3, 5, -4]])

B = np.array([[1, 2, 3],
              [4, 5, 6],
              [7, 8, 9]])

C = A.dot(B)

print(C)

"""Если перемножаемые матрицы являются квадратными, то результат их умножения будет снова квадратной матрицей, причём, того же размера. Это означает, что квадратную матрицу можно возводить в степень. В `numpy` это можно делать с помощью функции `matrix_power` из модуля `numpy.linalg`:"""

D = np.linalg.matrix_power(B, 3)

print(D)

"""### Единичная и транспонированная матрица

_Единичной матрицей_ называется квадратная матрица, у которого на главной диагонали стоят $1$, а в остальных местах - $0$. (Под _главной диагональю_ мы понимаем диагональ матрицы, которая начинается в левом верхнем углу и заканчивается в правом нижнем.) Единичную матрицу можно задать с помощью функции `np.eye`:
"""

I = np.eye(3)

print(I)

"""При умножении любой матрицы на единичную матрицу подходящего размера, результатом будет та же самая матрица:"""

print(A)

E = A.dot(I)

print(E)

"""Пусть дана матрица $A$. _Транспонированной матрицей_ называется матрица $A^\top$, полученная "отражением" матрицы $A$ относительно её главной диагонали. Другими словами, столбцы матрицы $A$ становятся строками матрицы $A^\top$, а строки матрицы $A$ - столбцами матрицы $A^\top$.

Вот несколько способов посчитать транспонированную матрицу в `numpy`:

* с помощью функции `np.transpose`: `A_t = np.transpose(A)`
* с помощью метода `A.transpose`: `A_t = A.transpose()`
* с помощью атрибута `A.T`: `A_t = A.T`
"""

A_t = A.T

print(A_t)

"""### Определитель и ранг матрицы

Если матрица квадратная, то мы можем посчитать её _определитель_. Определитель матрицы - это число, которое в каком-то смысле "определяет" её свойства. Например, обратную матрицу можно посчитать только для матрицы, определитель которой не равен $0$ (по аналогии с тем, что делить можно только на числа, не равные $0$).

Посчитать определитель можно с помощью функции `det` из модуля `numpy.linalg`:
"""

d = np.linalg.det(B)

print(d)

"""Также с помощью функции `matrix_rank` из модуля `numpy.linalg` можно посчитать _ранг_ матрицы. Ранг матрицы - это число линейно независимых строк данной матрицы."""

r = np.linalg.matrix_rank(B)

print(r)

"""Если матрица квадратная, то её ранг и определитель связаны следующим образом: определитель матрицы отличен от $0$ тогда и только тогда, когда все её строки являются линейно независимыми. Это, в свою очередь, означает, что её ранг равен её размеру.

Например, ранг матрицы $B$ из примера выше равен $2$, при этом её размер равен $3$. Это значит, что не все её строки являются линейно независимыми, поэтому её определитель равен $0$.

В отличие от определителя, ранг можно считать и для матрицы, которая не является квадратной. Посчитаем ранг матрицы $A$ размера $2 \times 3$, определённой выше:
"""

r1 = np.linalg.matrix_rank(A)

print(r1)

"""Итак, если определитель квадратной матрицы не равен $0$, то мы можем посчитать для неё _обратную матрицу_. Это матрица, которая при умножении на исходную матрицу даёт единичную матрицу:

$$A \cdot A^{-1} = I$$

Обратную матрицу можно посчитать с помощью функции `inv` из модуля `numpy.linalg`:
"""

F = np.array([[7, 4, 5],
              [8, 3, 2],
              [6, 10, 12]])

print(np.linalg.det(F))

F_inv = np.linalg.inv(F)

print(F_inv)

"""Проверим, что условие действительно выполняется:"""

print(F.dot(F_inv))

"""Если определитель матрицы $A$ равен $d$, то определитель обратной матрицы всегда будет равен $1/d$. Именно поэтому матрицы с определителем, равным $0$, обращать нельзя."""

F_d = np.linalg.det(F)

F_inv_d = np.linalg.det(F_inv)

print(F_d * F_inv_d)

"""## Генерирование массивов с заданными свойствами

Здесь мы рассмотрим способы задавать массивы различных размеров.

Функция `np.zeros` позволяет создать массив любой формы, состоящий из нулей:
"""

a = np.zeros((3, 4))

print(a)

"""Аналогично, функция `np.ones` вернёт массив заданной формы, состоящий из единиц:"""

b = np.ones((3, 4))

print(b)

"""Последовательности чисел можно создавать с помощью функции `np.arange`. Вот три способа использовать эту функцию:

* Если задать только один аргумент, то вернётся последовательность чисел от $0$ до этого аргумента невключительно:
"""

ar1 = np.arange(10)

print(ar1)

"""* Если подать два аргумента, то вернётся последовательность чисел от первого аргумента до второго (включая первый, не включая второй):"""

ar2 = np.arange(2, 13)

print(ar2)

"""* Если подать три аргумента, то третий аргумент будет обозначать шаг, с которым берутся числа в последовательности:"""

ar3 = np.arange(2, 13, 2)

print(ar3)

"""Отметим, что шаг в функции `np.arange` может быть дробным:"""

ar4 = np.arange(2, 3, 0.1)

print(ar4)

"""Если шаг отрицательный, то последовательность будет возвращена в обратном порядке:"""

ar5 = np.arange(3, 2, -0.1)

print(ar5)

"""Ещё одна полезная функция здесь - это функция `np.linspace`. Она позволяет вернуть заданное количество значений, равномерно расставленных между заданными началом и концом отрезка. Отметим, что здесь и левый, и првый концы отрезка включаются в массив:"""

c = np.linspace(2, 3, 10)

print(c)

"""Функция `np.logspace` имеет похожий эффект, отличие лишь в том, что в качестве начала и конца отрезка мы подаём не сами числа, а степени числа $10$. Например, в ячейке ниже мы задаём массив, содержащий $4$ значения, расставленных равномерно в пределах от $10^0 = 1$ до $10^3 = 1000$."""

d = np.logspace(0, 3, 4)

print(d)

"""### Массивы случайных значений

Функция `sample` из модуля `numpy.random` возвращает массив заданной формы, состоящий из чисел, взятых из равномерного распределения на отрезке $[0, 1)$.
"""

a = np.random.sample((3, 4))

print(a)

"""Отметим, что в эту и другие представленные ниже функции можно подавать также не кортеж, а какое-то одно целое число. В этом случае вернётся одномерный массив заданного размера. Также в эти функции можно не подавать аргументы вовсе - в этом случае вернётся лишь одно число."""

print("Одно значение: {}".format(np.random.sample()))

print("Три значения: {}".format(np.random.sample(3)))

"""Функция `randn` из модуля `numpy.random` возвращает аналогичный массив, но уже взятый из нормального распределения (со средним $0$ и среднеквадратическим отклонением $1$):"""

b = np.random.randn(3, 4)

print(b)

"""Обратите внимание, что эта функция получает на вход не кортеж `tuple`, а просто последовательность размеров по каждому измерению.

Функция `randint` возвращает массив из целых чисел в указанном диапазоне:
"""

c = np.random.randint(0, 100, (3, 4))

print(c)

"""Функция `choice` возвращает случайно выбранные элементы из заранее заданного массива:"""

A = np.arange(-10, 0)

d = np.random.choice(A, (3, 4))

print(d)

"""### Изменение размеров массива

Библиотека `numpy` предоставляет функционал для удобного изменения размера массивов.

Например, рассмотрим одномерный массив с $12$ элементами:
"""

ar = np.arange(12)

print(ar)

"""Если нам нужно расположить эти значения в двумерном массиве, мы можем сделать это с помощью функции `np.reshape` или метода `ar.reshape`:"""

a = ar.reshape(3, 4)

print(a)

"""Ясно, что при этом число элементов получаемого массива должно совпадать с числом элементов в оригинальном массиве. Например, следующая попытка посчитать функцию закончится ошибкой:"""

b = ar.reshape(3, 5)

"""Если мы знаем количество строк, которое хотим получить, но не знаем количество столбцов, в качестве второго аргумента можно передать число $-1$. Если наоборот мы знаем лишь количество столбцов, можно передать $-1$ в качестве первого аргумента."""

b = ar.reshape(3, -1)

print(b)

"""Метод `ar.reshape` не меняет сам массив `ar`, он лишь возвращает новый. Есть также метод `ar.resize`, который делает то же самое, что и `ar.reshape`, но не возвращает ничего и меняет исходный массив:"""

ar.resize(3, 4)

print(ar)

"""Обратно, чтобы получить из многомерного массива одномерный, можно воспользоваться методом `ar.flatten`:"""

c = ar.flatten()

print(c)

"""### Соединение массивов

Рассмотрим два массива и разберёмся с тем, как их можно соединить в один.
"""

a = np.zeros((2, 3))

b = np.ones((2, 3))

"""Мы можем соединить эти массивы вертикально (т.е. дописать один под другим). Вот несколько способов это сделать:

* с помощью функции `np.vstack`: `c = np.vstack((a, b))` (получает на вход кортеж из массивов)
* с помощью функции `np.concatenate`: `c = np.concatenate((a, b), axis=0)` (тоже получает на вход кортеж, также нужно указать, вдоль какой оси производится конкатенация)
"""

c = np.vstack((a, b))

print(c)

"""Также несколько способов это соединить массивы горизонтально (т.е. дописать один правее другого):

* с помощью функции `np.hstack`: `c = np.hstack((a, b))`
* с помощью функции `np.concatenate`: `c = np.concatenate((a, b), axis=1)` (производится теперь вдоль оси $1$)
"""

d = np.concatenate((a, b), axis=1)

print(d)

"""Наконец, два двумерных массива можно соединить _в глубину_ (т.е. вдоль новой третьей оси) с помощью функции `np.dstack`:"""

e = np.dstack((a, b))

print(e)

"""## Функции для работы с данными

Библиотека `numpy` предлагает удобный функционал для выбора данных из массива. Рассмотрим массив из $10$ случайных целых значений от $0$ до $19$:
"""

a = np.random.randint(0, 20, 10)

print(a)

"""Допустим, мы хотим выбрать все значения этого массива, которые больше $10$. Вот как это можно сделать:"""

b = a[a > 10]

print(b)

"""Свойства можно комбинировать, используя логические операторы "и" (обозначается символом $\&$), "или" (символ $\mid$) и оператор отрицания "не" (символ $\sim$). При этом каждое условие необходимо поставить в круглые скобки:"""

c = a[(a > 0) & (a % 2 == 0)]

print(c)

"""Такая конструкция в `numpy` называется _булевой индексацией_. Разберёмся с ней поподробнее. Что из себя представляет объект `a > 0`?"""

print(a > 10)

"""Как мы видим, это просто `numpy`-массив из булевых значений `True` и `False`. Когда мы подставляем такой массив в качестве _индекса_ массива `a`, нам возвращаются все элементы, на позиции которых в этом массиве стоит значение `True`.

Можно просто создать такой массив вручную и передать его в качестве индекса:
"""

ind = np.array([True, False, True, True, False, False, False, True, True, False])

print(a[ind])

"""Другой способ выбрать значения из массива - с помощью функции `np.where`. Она берёт массив из булевых значений и возвращает _индексы_ истинных значений:"""

ind1 = np.where(a > 10)

print(ind1)

"""Такой список индексов можно также передать в массив `a` чтобы получить конкретные значения:"""

d = a[ind1]

print(d)

"""То же самое можно сделать и вручную: передать в квадратные скобки массива `a` какой-нибудь список из индексов:"""

e = a[[0, 4, 7]]

print(e)

"""Отметим также, что если массив `a` является многомерным, то чтобы выбрать таким образом из него значения, нужно указать внутри квадратных скобок через запятую столько списков, сколько имеется у массива измерений:"""

a.resize((5, 2))

print(a)

f = a[[1, 4], :]

print(f)

"""### Сортировка

Рассмотрим двумерный массив:
"""

a = np.random.randint(0, 6, (3, 4))

print(a)

"""Допустим, мы хотим отсортировать строки этого массива по второму столбцу. Мы можем сделать это вручную, задав индексы строк в нужном нам порядке:"""

b = a[[1, 2, 0], :]

print(b)

"""Этот процесс можно автоматизировать с помощью метода `a.argsort`. Данный метод возвращает массив из индексов массива `a` в порядке их возрастания по заданной оси:"""

ind = a.argsort(axis=0)

print(ind)

"""В каждом столбце этого массива стоят индексы строк массива `a`, расположенные в том порядке, в котором они бы отсортировали данный столбец по возрастанию. Автоматизируем процесс сортировки массива `a` по второму столбцу. Для этого нужно получить второй столбец из массива, полученного с помощью метода `a.argsort`:"""

ind1 = a[:, 1].argsort()

print(ind1)

"""Итоговая конструкция будет выглядеть так:"""

c = a[a[:, 1].argsort(), :]

print(c)

"""### Перемешивание

Иногда оказывается нужно перемешать значения массива. Это можно сделать с помощью функции `shuffle` из модуля `numpy.random`. Эта функция ничего не возвращает, лишь перемешивает случайным образом элементы данного массива. Отметим, что она перемешивает массив только в первом измерении. Другими словами, если массив двумерный, она лишь переставит его строки местами. Содержимое самих строк при этом не изменится:
"""

np.random.shuffle(c)

print(c)

"""### Математические операции над массивами

Некоторые математические операции можно выполнять с массивами целиком. Например, мы уже знаем, что массивы можно умножать на число и что массивы одинаковой формы можно складывать.
"""

a = np.arange(0, 6).reshape(2, 3)
b = np.arange(6, 12).reshape(2, 3)

print(a)
print(b)

print(a + b)

print(a * 2)

"""К массивам можно также прибавлять числа - в этом случае к каждому элементу массива прибавляется число:"""

print(a + 1)

"""Массивы одинакового размера можно поэлементно умножать. (Важно не путать с матричным умножением.)"""

print(a * b)

"""С помощью метода `a.sum` можно посчитать сумму всех значений массива. Если указать в этом методе ось `axis`, сумма будет посчитана только вдоль этой оси:"""

print("Сумма всех элементов: {}".format(a.sum()))

print('Сумма по столбцам ("вдоль" строк): {}'.format(a.sum(axis=0)))

print('Сумма по строкам ("вдоль" столбцов): {}'.format(a.sum(axis=1)))

"""#### Broadcasting

В определённых случаях мы можем выполнять операции сложения и умножения над матрицами разных размеров. Концепция _broadcasting_ заключается в том, что в некоторых случаях интерпретатор "догадывается", что одну массив надо в каком-то измерении "растянуть" до соответствия со вторым массивом. Рассмотрим массив размера $3 \times 2$:
"""

a = np.array([[2, 5],
              [3, 4],
              [6, 1]])

"""а также одномерный массив размера $2$:"""

b = np.array([1, 2])

"""Если мы попытаемся их сложить, интерпретатор заметит, что у них совпадает одно из измерений: у них обоих $2$ столбца. Поэтому интерпретатор как бы "растянет" массив `b` до размера $2 \times 3$ и прибавит его к массиву `a`:"""

c = a + b

print(c)

"""На самом деле здесь строка `b` просто прибавится к каждой строке массива `a`.

Аналогично можно поступить и со столбцами:
"""

d = np.array([[0],
              [1],
              [-1]])

e = a + d

print(e)

"""Интерпретатор заметит, что у этих массивов совпадает число строк, поэтому "растянет" массив `d` до размера массива `a`. Попросту говоря, столбец `b` прибавится к каждому из столбцов массива `a`.

Имеются и более сложные конструкции broadcasting, о них можно почитать [здесь](https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html).

В случае, когда размеры массивов согласовать не удаётся, выпадает ошибка:
"""

f = np.array([0, 1, -1])

a + f

"""#### Статистические функции

Вот несколько методов, позволяющих вычислить различные статистики массива `a`:

* `a.min` - минимальное значение
* `a.max` - максимальное значение
* `a.mean` - среднее значение
* `a.std` - среднее квадратическое отклонение

Все эти значения считаются по всему массиву, либо вдоль определённой оси, если задан параметр `axis`.
"""

print(a)

print("Минимальное значение: {}".format(a.min()))

print("Средние значения строк: {}".format(a.mean(axis=1)))

print("Средние квадратические отклонения столбцов: {}".format(a.mean(axis=0)))

"""### Запись и чтение массивов из файла

Массивы `numpy` можно сохранять в файлы с расширением `.npy` и читать из таких файлов.

Для записи массива в файл используется функция `np.save`:
"""

np.save("a.npy", a)

"""Для чтения из файла используется функция `np.load`:"""

a = np.load("a.npy")