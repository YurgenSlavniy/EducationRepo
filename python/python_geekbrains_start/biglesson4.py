#--------------------------------------------------
# УРОК 1. ОПРЕДЕЛЕНИЕ ФУНКЦИИ. ВСТРОЕННЫЕ ФУНКЦИИ
#--------------------------------------------------
# Определение функции. Встроенные функции.

# - определение функции
# - зачем нужны функции
# - функции, которые мы уже использовали
# - другие полезные встроенные функции
# - примеры
#
# функции - фрагмент программного кода (подпрограмма), к которой можно обратиться из другого места программы
# функции обычно имеют имя
# в пайтон можно создавать функции без имени
#
# зачем нужны функции?
# для повторного использования кода
# для создания более логичной структуры программы
# для объединения нескольких небольших действий в одно
#
# Мы уже знакомы с полезными функциями. Они встроены в стандартную библиотеку пайтона
#
# print, type, range, len, input, int, str ...
# печать - функция с параметрами
print('hello, function')
# функции могут быть без параметров, но возвращают результат
name = input()
# тип переменной - функция с параметрами и возвращаемым значением
t = type(123)
# диапазон - функция с параметрами и возвращаемым значением
r = range(10)
# длина последовательности
len([1, 2, 3, 4])
# преобразование типов
int('10')
str(10)
# Функция может иметь параметры и возвращаемые значения
# мы уже работали с функциями, но не говорили про само понятие функции
#
# В язык пайтон также встроены полезные другие функции
# - abs - модуль числа
# - min, max - минимальное и максимальное значение последовательности
# - round - округление числа
# - sum - сумма элементов последовательности
# - enumerate - нумерация последовательности
#
# примеры:
#
# модуль числа abs
print(abs(-98))
# min, max
numbers = [1, 23, -76, 87, 99, -98]
print(max(numbers))
print(min(numbers))
# round
print(round(3.1415, 2))
# sum
print(sum(numbers))
# enumerate . параметрами указываем саму последовательность, и число с которого будем старотовать (0 по умолчанию)
winners = ['leo', 'king', 'sponge']
for number, winner in enumerate(winners, 1):
    print(number, winner)
# перебираем в цикле 2 элемента: номер элемента и сам элемент
#
# Пример:
# пользователь вводит 3 числа. Найти минимальное из них, максимальное и сумму . вывести результат
numbers = [] # создадим пустой список, где будем хронить эти числа
# после того как у нас есть контейнер, позволим пользователю ввести числа только три раза
for i in range(3):
# далее в цикле мы будем пользоваться функцией input
    number = int(input('Введите число: '))
# после того как пользователь введёт число, мы будем добавлять его в наш список numbers
    numbers.append(number)
# после тог как 3 раза пользователь введёт число, можем работать с помощью встроенных функций
print(max(numbers))
print(min(numbers))
print(sum(numbers))

#--------------------------------------------------
# УРОК 2. ФУНКЦИИ. СОЗДАНИЕ СОБСТВЕННЫХ ФУНКЦИЙ
#--------------------------------------------------
# Функции. создание собственных функций.
#
# - зачем писать свои функции
# - как объявить функцию в коде
# - использование своих функций
# - примеры
#
# зачем писать свои функции?
# для повторного использования своего кода
# для создания функционала которого нет в стандартной библиотеке
#
# функция простой разделитель
print('Моя первая функция')
print('-' * 100)
print('Красивый разделитель')
print('-' * 100)
print('Что если их будет много?')
print('-' * 100)
print('-' * 100)
print('-' * 100)
# У нас есть некоторая программа, в которой есть текст и куда встроен такой вот разделитель
# знак '-' умноженный на 100 раз
# Если мы используем его несколько раз, нам надо всё время копировать его
# А если надо изменить? придётся менять в нескольких местах сразу, везде где я его использовал
# для того чтобы убрать дублирование кода можем воспользоваться функцией
#
# Объявим нашу первую функцию:
# с помощью команды def. далее даём название функции. название должно быть говорящим
# в скобочках идут параметры. Если их нет, всё равно ставим круглые скобки. и двоеточие
# после двоеточия используем отступ. Далее идёт тело функции.
# оно может состоять из одной или сногих строк.
def print_sep():
    print('-' * 50)
# мы пока просто объявили функцию, но чтобы её использовать к ней надо обратиться
# чтобы её использовать мы пишем вызов функции. Обязательно со скобочками, даже если нет параметров
print_sep()

# Функция состоит из трёх основных частей:
# - её название
# - параметры
# - результат
#
# рассмотрим примеры:
# у функции простой разделитель нет ни параметра ни возвращаемого значения
# если мы  знак нашего разделителя, функция будет содержать 1 параметр, но не будет возвращаемого результата
# изменим знак и длину - будет 2 параметра и нет возврата результата
# количество параметров может быть сколько угодно много
# чтобы понять как работает возвращаемое значение, будем использовать функцию в тексте
# вместо того чтобы печатать её сразу в терминал, тогда получится 2 параметра и результат или возвращаемое значение
def print_sep():
    print('-' * 24)
# Есть функция простой разделитель.
# мы можем знак разделителя '-' заменить на какую нибудь переменную
# назовём её sep - это и будет название нашего первого параметра
def print_sep(sep):
    print(sep * 24)
# Параметры указываем в скобках, это те данные которые будут внутри функции изменяться.
# При вызове функции теперь необходимо указывать параметр
print_sep('*')
print_sep('-')
# Заменяем число 24 на параметр и тогда можем управлять 2 умя параметрами функции при её вызове
def print_sep(sep, len):
    print(sep * len)
# Теперь при вызове функции, необходимо указывать 2 параметра.
# возвращаемое значение это результат, который получается  врезультате вызова нашей функции
# если мы объявим переменную и присвоим ей нашу функцию , то попытавшись её распечатать мы получим None
result = print_sep('=', 8)
print(result)
# это потому что принт выводит результаты в терминал, но сама функция не имеет возвращаемого значения
# и пайтон воспринимает это как None
#
# Разберём пример зачем нам пригодится возвращаемое значение.
# например нам нужно использовать нашу функцию в тексте.
# таким образом, чтобы у нас сперва собрался какой то текст,
# а затем мы его напечатаем
# т.е не сразу выводим результат, а встраиваем разделитель в текст.
#
def print_sep(sep, len):
    return sep * len
# используем разделитель в тексте
sep = print_sep('.', 15)
text = 'Hello {} Func {}'.format(sep, sep)
print(text)
# для этого в функции пишем ключевое слово return
# у нас получилось, что функция не выводит значение сразу на экран, а возвращает нам определённый результат умножения
# нашего символа на длину
# после того, как мы это написали, мы вызываем нашу функцию с параметрами
# и результат уже сохраниться как раз в переменную sep
# после этого мы формируем некоторый текст, делаем формат .format(sep)
# и после этого как раз передаём туда нашу переменную sep? чтобы она у нас попала в {}
# Но теперь вывод функции и результата работы через print
print(print_sep('=', 19))
# просто
print_sep('=', 19)
# не выведит результат на экран, как в верхних примерах


#--------------------------------------------------
# УРОК 3. АРГУМЕНТЫ ИЛИ ПАРАМЕТРЫ ФУНКЦИИ
#--------------------------------------------------
# Аргументы или параметры функции
# - параметры (аргументы) функции
# - функции без параметров и с параметрами
# - передача параметров по порядку, по имени
# - значения параметров по умолчанию
# - args, kwargs? (любое количество параметров)
#
# праметры функции определяются в скобочках после её имени
# def my_func(параметр1, параметр2,...)
# параметров может быть много, также параметров может не быть совсем
# например функция для приветствия человека. будет совсем без параметров
def hello_man():
    print('Hello', 'Yurgen')
# когда мы написали функцию её можем использовать сколько угодно раз.
# функция получилась совсем не универсальная, она может выводить только hello yurgen
# чтобы расширить её возможности, сделаем для начала 1 параметр: например имя человека
def hello_name(name):
    print('Hello ', name)
# теперь вызывим наши две функции
hello_man()
hello_name('Kesha')
# Также мы можем ещё расширить нашу функцию. Мы можем передовать уже 2 параметра:
# первый параметр, Name - к кому мы обращаемся,
# второй параметр - что мы будем говорить
def hallo (name, say):
    print(say, name)
# теперь функция становится наиболее общей
hallo('Приветствую', 'Анабэль')

# есть 2 варианта передачи параметров в функцию при её вызове
# - по порядку. мы вызываем функцию и в том порядке в котором у нас объявлены параметры
# передаём значения. (как мы делали выше)
# - по имени. другой метод передачи парамаетра. Тогда нам не важен порядок
# чтобы присвоить значение параметру мы явно указываем его имя
hallo(say = 'Здарова', name = 'Братуха' )
# мы можем менять местами наши параметры при таком вызове
# Например как с анабэль , при перепутанных параметрах
def hallo(name, say):
    print(say, name)
# теперь функция становится наиболее общей
hallo('Приветствую', 'Анабэль')
# мы в терминале получаем: Анабэль Приветствую
# сперва идёт параметр name, потом параметр say
# при перепутанных параметрах функция у нас нормально сработала,
# но не так как нам нужно. Если же мы не хотим зависить от порядка
# передачи параметров мы можем явно указать какой параметр чему равен
hallo(say='Приветствую', name='Анабэль')

# У параметров можно задавать значения по умолчанию.
# это можно сделать, если при объявлении фунуции приравнять параметр к какому нибудь значению
def hi(name, say='Hello'):
    print(say, name)
# Таким образом, если мы не передадим при вызове значение этого параметра
# То функция у нс всё равно отработает и вместо пустого значения, присвоит туда значение по умолчанию
hi('Piter')
# параметр подставляется по умолчанию, если он не задан
hi('Georg', 'Privet')

# Иногда нам нужно реализовать передачу любого количества аргументов
# Например мы будем говорить привет ни одному человеку, а сразу нескольким
# def greeting('Hello', 'Leo', 'Max', 'Kate', ...)
# это можно реализовать с помощью так называемых
# args - передача любого количества по порядку
# kwargs - передача любого кол-ва иминованных параметров
# реализуется с помощью звёздочки  * и двух звёздочек **
# передача параметров по порядку
def greeting(say, *who):
    print(say, who)
# Если попробуем передать 3 параметра, у нас выскочит ошибка и программа работать не будет
# чтобы не возникало ошибки мы можем например во второй параметр поставить звёздочку
# звёздочка означает, что после этого места, мы можем передавать сколько угодно параметров
greeting('Салют', 'Max', 'Artur', 'Kate')
# теперь у нас есть картеж. Вместо одного параметра мы имеем картеж из параметров
# Салют ('Max', 'Artur', 'Kate')
# с помощью звёздочки мы можем в виде картежа передать сколько много параметров
# параметр со свёздочкой принято называть словом args
# это стандартное обозночение . Т.е. мы обычно всегда называем параметр args
def funk(say, *args):
    print(say, args)
# и другой параметр мы всегда будем называть kwargs
def get_person(**kwargs):
    for k, v in kwargs.items():
        print(k, v)
get_person(name='Leo', age=28)
# Здесь аналогично, но мы будем задавать параметры по имени
# т.е  в args мы писали сколько угодно параметров по порядку
# здесь мы будем писать любые параметры по имени
# например используем функцию get_person(name='Leo', age=28)
# и передаём параметры name и age. запускаем функцию и видим в терминале:
# name Leo
# age 28
# Но мы можем передавать любые другие параметры
get_person(name='Leo', age=28, has_car=True)
# просто пишем новый именованный параметр и функция будет их всех отрабатывать
# функция принимает любое количество параметров по имени
# для этого ставим 2 звёздочки и используем слово (**kwargs):
# в первом случае args у нас приходит кортеж
# в случае kwargs у нас приходит словарь
# таким образом мы можем использовать ключ - k и значение - v из этого словаря
# и производить с ними какие то действия, которые нам нужны

#--------------------------------------------------
# УРОК 4. ФУНКЦИИ. ОБЛАСТИ ВИДИМОСТИ
#--------------------------------------------------
# Функции. Области видимости.
# - определение области видимости
# - локальные и глобальные переменные
# - чем плохи глобальные переменные
# - примеры
#
# В программировании обозночает область программы (памяти), в пределах которой идентификатор (имя)
# некоторой переменной продолжает быть связанным с этой переменной и возвращать её значение
#
# за пределами области видимости тот же самый идентификатор может быть
# связан с другой переменной, либо быть свободным (не связанным ни с какой из них)
#
# область видимости объекта
# набор функций или модулей, внутри которых допустимо использование имени этого объекта
# а за пределами которых этого объекта не видно.
#
# пример:
def my_f(my_var):
    my_var = 999
    print('Внутри функции: ', my_var)
a = 1
my_f(a)
print('После выполнения функции: ', a)
# Передача параметра в функцию.
# мы имеем функцию my_f в которую передаётся переменная my_f(my_var)
# внутри функции мы присваиваем переменной my_var значение 999
# и выводим её на экран
# после того как мы это сделали попробуем вызвать функцию.
# у нас за функцией есть переменная a со значением 1
# мы вызываем ф-ю my_f и передаём в неё переменную a
# и проверяем результат после выполнения функции
# запускаем программу и видим:
# внутри функции переменная изменилась и стала равной 999
# это выводит следующий принт  print('Внутри функции: ', my_var)
# снаружи функции после того как ф-я сработала, переменная a не изменилась
#
# переменная которая была у нас внутри функции это не таже самая переменная
# которая у нас была снаружи. И переменная снаружи не изменила своего значения
# новый пример:
def some_f():
    a = 999
    print('Внутри функции: ', a)
a = 1
some_f()
print('После выполнения функции: ', a)
# Есть функция some_f() она не имеет параметров
# внутри функции мы объявляем переменную а и присваиваем ей значение 999
# после этого выводим её на экран
# переменная а будет выведена внутри функции
# после этого снаружи мы объявляем переменную с тем же именем а = 1
# вызываем функцию some_f()
# и посмотрим какое значение получится после её выполнения:
# мы снова получили, что внутри функции значение переменной не изменилось
# но снаружи функции оно осталось неизменным
# потому что переменная а внутри функции это не таже самая переменная
# что и снаружи функции
# Потому что внутри функции у нас своя область видимости и свои переменные
# А в основном коде у нас другая область видимости и свои переменные.
# Хотя названия переменных могут быть одинаковыми

#--------------------------------------------------
# УРОК 5. ЛОКАЛЬНЫЕ И ГЛОБАЛЬНЫЕ ПЕРЕМЕННЫЕ
#--------------------------------------------------
# Локальные и глобальные переменные
# Глобальными называют объекты, объявление которых дано вне функции.
# Они доступны (видимы) во всём файле, в котором они объявлены.
#
# локальными называют объекты, объявление которых дано внутри блокаили функции.
# эти объекты доступны только внутри того блока, в котором они объявлены
# рассмотрим на примере:
global_var = 1
def my_funct():
# есть функция, внутри которой объявляем локальную для этой функции переменную
    local_var = 100
# мы можем использовать эту локальную переменную внутри функции, например напечатать
    print(local_var)
# далее мы можем напечатать и глобальную переменную global_var
# переменная глобальная, если она написана и задана вне функции. В нашем случае выше.
# глобальная переменная, объявлена в модуле
# мы можем вывести эту переменную на экран, но эту переменную мы сейчас не сможем изменить
    print(global_var)
# Но эту переменную сейчас нельзя изменить
    # global_var = 99
my_funct()
# после этого вызовим нашу функцию и проверим значение переменной global_var
print(global_var)
# Мы получим: 100 - это принт локальной переменной
# 1 - принт глобальной переменной из функции
# 1 - принт глобальной переменной внутри модуля
# Можем убедиться, что переменную не удастся изменить.
# если внутри функции мы присвоим какое то значение переменной global_var
# то получим ошибку
# Если же мы попробуем использовать локальную переменную внутри модуля
# print(local_var)
# у нас тоже будет ошибка, потому что локальная переменная у нас доступна
# только внутри функции.

# при желании можно изменить значение глобальной переменной.
# для этого в функции нужно указать, что она является глобальной.
# с помощью ключевого слова global my_var
# Но этот механизм лучше не использовать. Таким образом мы рискуем
# изменить значение переменной в одной функции, после чего получить неверное
# значение в другой функции
global_var = 89
def my_fu():
    global global_var
    local_var = 98
    print(local_var)
    print(global_var)
    global_var = 91
# после этого при вызове функции мы сначала напечатаем глобальную переменную 89
# после мы её изменим на 91
my_fu()
print(global_var)
# и когда мы будем печатать её ещё раз, мы получим 91, а не 89
# рассмотрим пример, почему стоит избегать изменение глобальных переменных:
global_var = 2
# мы имеем переменную global_var, которая = 2
def my_f():
    result = global_var ** 5
    print(result)
# Функция my_f будет брать эту переменную и взводить её в степень
# после этого печатать результат
# если мы просто вызовим функцию my_f , то всё будет хорошо
def my_change_f():
# Но если мы объявим другую функцию my_change_f
# внутри которой дадим доступ на изменение глобальной переменной
# То мы не сможем проконтролировать значение переменной
# и в какой момент она изменится
    global global_var
    global_var = 'какая то строка'
# например ф-я my_change_f может записать в эту переменную какую то строку
# таким образом если функция  my_change_f будет вызвана до функции my_f()
# мы получим ошибку

# my_change_f()
my_f()
# Мы заменили глобальную переменную в одном месте, а ошибку получили совсем в другом.

# Относительность области видимости
# в программе могут встречаться вложенные друг в друга функции.
# тогда мы рассматриваем область видимости относительно какой либо функции

m = 'Меня видно везде'
# у нас есть глобальная переменная m, которая объявлена внутри модуля
def a():
# далее мы видим объявление трёх функций a,b,c
# они вложены друг в друга
# переменная m будет глобальна для всех функций, потому что она объявлена выше
# мы можем получить её значение во всех трёх функциях
    ma = 'Меня видно и в b() и в a()'
# рассмотрим ф-ю а и объявим в ней переменную ma
# То мы получим локальную переменную для ф-ии а ,
# но она будет глобальной для b и с.
# т.к функция а объявлена выше b и с
    def b():
        print(m)
        print(ma)
#  mb - локальная для b, но глобальная для с
# мы уже не сможем еёиспользовать внутри ф-ии а, т.к для неё она будет недоступной
        mb = 'Меня видно в с() и в b(), но не видно в а() '

        def c():
            print(m)
            print(ma)
            print(mb)
# mc - логальная для с, в b() и в а() она недоступна
            mc = 'Mеня видно только в с()'


# если вддруг мы попытемся напечатать mc внутри ранних функций у нас будет ошибка
# т.к переменная mc - локальная для с() и может использоваться только внутри с()

#--------------------------------------------------
# УРОК 6.  ПЕРЕДАЧА ФУНКЦИИ ПАРАМЕТРОМ В ДРУГУЮ ФУНКЦИЮ. lambda функция
#--------------------------------------------------
# ПЕРЕДАЧА ФУНКЦИИ ПАРАМЕТРОМ В ДРУГУЮ ФУНКЦИЮ. лямбда функции
#
# - Функция как объект
# - передача функции как параметра
# - применение
# - lambda функции
#
# Мы уже знаем, как работают функции
def some_f():
    return 10
result = some_f()
print(result)
# функция например просто возвращает число 10.
# мы можем её взять, result = some_f() , поставить круглые скобочки
# это означает, что мы вызываем нашу функцию и
# результат сохраняем в переменную result
# выводим на экран, получаем 10
a = some_f
print(a)
# присвоим переменной a значение. Но этим значением будет функция.
# и попробуем вывести на экран: <function some_f at 0x0000008858D2C310>
# переменная а хронит в себе фунуцию a = some_f по некоторому адресу в памяти.
# если мы посмотрим тип переменной а
print(type(a))
# <class 'function'>
# мы можем обратиться к функции а , вместо того, чтобы обращаться к функции some_f
a()
# и получить тот же самый результат: 10
print(a())
# таким образом мы можем понять, что функция в пайтоне является объектом.
# мы можем записать этот объект в коакую то переменную,
# переменная станет у нас функцией
# и вызывать эту функцию только с другим именем.
#
# Функция - тоже объект
# её можно записать в переменную
# её можно передавать параметром в другие функции
# пример:
def f():
    print('Hello from other f')

def to(f_param):
    # параметром будет функция
    # поэтому в теле функции to мы её вызовим
    f_param()
# проврим
to(f)
# рассмотрим возможность передачи параметра.
# у нас есть функция def f():
# она выводит на экран  print('Hello from other f')
# есть вторая функция def to(f_param)
# у неё есть 1 параметр (f_param)
# параметр f_param() тоже будет являться фунуцией
# попробуем внутри функции to взять параметр и вызвать его как какую то другую функцию
# далёё берём функцию to(f) и передаём в неё параметр f без скобочек
# т. е мы передаём не результат функции f, а саму функцию f
# после чего она должна вызваться и вернуть нам просто текст Hello from other f
#
# Применение
# возможность не только входных данных, но и входных функций
# внутри функции переменными являются
# - алгоритм
# - последовательность действий
# - сами действия внутри функции
#
# функция для фильтрации списка чисел
def my_filter(numbers):
    result = []
    for number in numbers:
        if number % 2 == 0:
            result.append(number)
    return  result

numbers = [1, 2, 3, 4, 5, 6, 7, 8]
print(my_filter(numbers))
# у нас есть набор чисел numbers = [1, 2, 3, 4, 5, 6, 7, 8]
# мы хотим использовать функцию def my_filter(numbers):
# и для начала отфильтровать только чётные числа
# у нас уже есть написанная ф-я my_filter(numbers):, куда заходит набор чисел numbers = [1, 2, 3, 4, 5, 6, 7, 8]
# объявляем переменную резалт - пустой список для результата result = []
#  for number in numbers: - мы перебираем наши числа
# if number % 2 == 0: и если число делится на 2 без остатка, значит оно чётное
# мы сохраняем его в результат  result.append(number)
#  return  result и в конце будем этот результат возвращать
# print(my_filter(numbers)) вызываем функцию и посмотрим что получится:
# [2, 4, 6, 8]
# Как нам быть например если нужны нечётные числа? или числа больше 4 ?
# или числа с каким то другим условием?
# Если будем пользоваться функцией my_filter(numbers) она ничего не даст
# нужно будет постоянно заменять условие внутри этой функции и дделать из неё другие функции
# здесь мы можем сделать универсально и попробывать использовать передачу параметра
# в виде функции
# мы ожем передать в функцию второй параметр, который будет называться function: def my_filter(numbers, function):
def my_filter(numbers, function):
    result = []
    for number in numbers:
        if function(number):
            result.append(number)
    return  result

numbers = [1, 2, 3, 4, 5, 6, 7, 8]

def is_even(number):
    return number % 2 == 0
print(my_filter(numbers, is_even))

# Этот function как раз и будет та функция, которая отвечает за то: положили мы число в список или нет
# после этого делаем условие if function(number):
# таким образом если условие функции вернёт TRUE , то мы будем записывать в результат это число.
# если же функция вернёт FALSE , то это число мы записывать не будем
# дальше разбираемся с чётными числами: нам нужно написать отдельную функцию
# которая будет определять чётное число или нечётное : def is_even(): - для чётности
# функция будет возвращать  return number % 2 == 0
# после того как мы написали эту функцию , можем передать её параметром в нашу функцию my_filter
# проверим универсальность:
def is_not_even(number):
    return number % 2 != 0
print(my_filter(numbers, is_not_even))
# функция будет проверять что число нечётное: return number % 2 != 0
# и после этого передаём функцию в функцию my_filter(numbers, is_not_even)
# попробуем получить числа, которые больше 4
def more_4(number):
    return number > 4
print(my_filter(numbers, more_4))
#
# lambda-функции
# применяются для создания анонимных функций по месту их использования
# записываются: lambda входные параметры: результат
# вернёмся к примеру
def my_filter(numbers, function):
    result = []
    for number in numbers:
        if function(number):
            result.append(number)
    return  result
# мы писали ф-ю is_even(number). которая провверяет делится ли число на 2 без остатка
# чтобы не давать функции имя и не делать грамозскую запись
def is_even(number):
    return number % 2 == 0
# можно сделать в одну строку
print(my_filter(numbers, lambda number: number % 2 == 0))
# аналогичные для is_not_even и  more_4
print(my_filter(numbers, lambda number: number % 2 != 0))
print(my_filter(numbers, lambda number: number > 4))
# когда хотим сделать краткую запись, чтобы передать функцию в другую функцию.


#--------------------------------------------------
# УРОК 7.  ФУНКЦИИ sorted, filter, map
#--------------------------------------------------
# Функции sorted, filter, map
# - sorted
# - filter
# - map
# - примеры использования
#
# функция sorted
# сортировка последовательности
# sorted(iterable,*,key=None, reverse=False)
# для того чтобы ей воспользоваться нам нужно знать параметры.
# основные параметры. Аргументы: последовательность, ключ для сортировки, порядок сортировки
numbers = [1, 5, 3, 5, 3, 45, 5, 6, 11]
# у нас есть набор чисел
print(sorted(numbers))
# сортировка по возрастанию
print(sorted(numbers, reverse=True))
# сортировка по убыванию
# сортировка работает и со строками
# у нас есть набор строк
names = ['max', 'Victor', 'Tato', 'Ibrahim', 'Yurgen']
# сортировка по алфавиту
print(sorted(names))
# Города и показатель радости. в картеже
cities = [('MSK', 1234), ('KEV', 87), ('SPB', 786)]
# такая сортировка сортирует по алфавиту
print(sorted(cities))
# как сортировать по показателю радости?
# воспользуемся параметром key функции сорт.
# для этого надо написать функцию, которая будет показвать функции сортед, как мы хотим отстортировать нашу последовательность
def my_count(city):
    return city[1]
# функция my_count , будет принимать параметр - город def my_count(city):
# в параметр city входит название - это первый элемент кортежа, и входит показатель радости -  2ой элемент кортежа
# таким образом если мы вернём второй элемент кортежа  return city[1]
# мы будем говорить функции sorted о том, что сортировку надо вессти по второму элементу, а не по первому (по умолчанию)
# индексы начинаются с 0, поэтому пишем city[1]
# вызываем снова ф-ю сортед и передаём параметр key
print(sorted(cities,key=my_count))
# key это функция мы её не вызываем, а передаём готовую функцию
# кроме обычной функции параметром можно передать lambda функцию
print(sorted(cities,key=lambda city: city[1]))
# пишем слово lambda, после этого параметр city, после : сразу пишем возвращаемое значение
# в данном случае у нас  city[1]

# функция filter
# фильтрация последовательности
# filter(function, iterable)
# она принимает 2 основных параметра: функция и последовательность
# аргументы: функция фильтрации, последовательность
# функции фильтрации показывают каким образом мы будем выбирать элементы
# а последовательность - тот набор данных из которых мы будем выбирать элементы.
# есть набор чисел: картеж
numbers = (1, 2, 3, 4, 5, 6, 7, 8)
# получить только чётные числа
# пишем функцию, которая будет определять войдёт число в последовательность или нет
def is_in(number):
    return number % 2 == 0
# функция обязательно должна возвращать либо TRUE, либо FALSE
# параметр number - конкретное число нашей последовательности
# number % 2 == 0 означает что TRUE будет только для чётных чисел
result = filter(is_in, numbers)
print(result)
# вызываем функцию фильтер
# первым параметром передаём функцию is, и второй параметр - наша последовательность
# если посмотрим результат увидим: <filter object at 0x0000000D1DC23640> [2, 4, 6, 8]
# фильтер обджект по определённому адресу.
result = list(result)
print(result)
# для вывода в красивом виде приводим к списку
# для другой задачи
# набор строк
name = ['london', 'paris', 'moscow', 'io', 'tul']
# получить строки больше 3 символов
# сразу приведём результат к списку для наглядного вида
print(list(filter(lambda city: len(city) > 3, name)))
# пишем функцию фильтр и в ней первый параметр функция, будем сразу использовать lambda функцию
# далее надо написать условие по которому имя войдёт в наш список
# вторым параметром передаём нашу последовательность name

# функция map
# применение функции к каждому элементу последовательности
# она не фильтрует последовательность, а получает какую то новую
# имеет 2 основных аргумента: функция которая будет применяться к  каждому элементу, сама последовательность
# map(func, iterable, ...)
numbers = [6, 6, 4, 5, 3, 2, 8, 7]
# у нас есть список чисел он состоит из целых чисел
# получить список квадратов из этих чисел
print(list(map(lambda x: x**2, numbers)))
# привести числа к строке
print(list(map(lambda x: str(x), numbers)))
#