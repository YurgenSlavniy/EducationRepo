# ВСТРОЕННЫЕ ТИПЫ И ОПЕРАЦИИ С НИМИ
#----------------------------------
#
#--------------------------------------------------
# УРОК 1. СТРОКИ. ОПРЕДЕЛЕНИЕ. МЕТОДЫ. ФОРМАТИРОВАНИЕ
#--------------------------------------------------
#
# - тип данных строке
# - объявление строк
# - основные действия со строками
# - дополнительные действия со строками
# - форматирование строки
# - Пример использования
#
# для того чтобы объяить переменную строкового типа мы должны поместить текст или символы внутри одинарных ковычек '...'
# иногда можно воспользоваться двойными ковычками.
# главное чтобы одинаковыми ковычками открывалось и закрывалось.
friend = 'Гугл'
print(friend)
# когда ковычки в ковычках, рассмотрим примеры:
say = 'say "Hello"'
#
pont = "say 'Hello'"
print(say, pont)
# Строка str состоит из набора символов.
# Можем получить какой любо символ по его индексу из строки.
# Индекс указывается в квадратных скобках. Все индексы начинаются с 0.
# В пайтон можно использовать отрицательные индексы
friend = 'Поехали!'
first_letter = friend[0]
print('Первая буква в слове ', first_letter)
# Переменная friend . Чтобы найти первую букву этой переменной воспользуемся индексом friend[0]
# [0] - означает первый символ. [5] - 6ой символ. [8] - 9ый символ
# Если проверим тип переменной first_letter - тоже оказывается строковый
# В пайтон нет отдельного типа под символ - всё является строкой.
print(friend[3]) # выведим на экран 4 ый символ переменной friend
# Также доступна индексация с конца нашей строки
print(friend[-1]) # даёт нам последнюю букву. отрицательными индексируемся с конца.
print(friend[-3]) # Третий с конца символ
# помимо индексов при работе со строкой мы можем пользоваться срезами
# - благодоря срезам можно получить несколько символов(часть строки)
# friend[start:end] чтобы записать срез, мы берём 2 индекса - начальный и конечный, и указываем их через двоеточие
print(friend[1:4]) # вывели на экран элементы строки переменной friend со 2 го по 5 ый  символы
print(friend[:5]) # срез с начала строки до какого то элемента
print(friend[3:]) # срез с какого то элемента до конца строки
print(type(friend[2:5])) # тип среза - <class 'str'>

# Функция len и методы строки
# len(friend) - длина строки (сколько в ней символов)
# friend.find('a') - ищем символ "a" в строке
# friend.split() - разбиение строки через пробел
# friend.isdigit() - строка состоит тлько из чисел
# friend.upper() - ПРИВЕДЕНИЕ СТРОКИ К ВЕРХНЕМУ РЕГИСТРУ
# friend.lower() - ПРИВЕДЕНИЕ СТРОКИ К нижнему РЕГИСТРУ
friend = 'лёха игроь танюха маринка семён колян яков'
print(friend) # вывели на экран переменную friend
print('Число символов в верхней строке: ', len(friend)) # выведим на экран число символов в строке, которое подсчитает метод len(friend)
print(friend.find('ма')) # метод файнд удет искать, то что укажем в скобках в строке friend
# МЕТОДЫ МЫВЫЗЫВАЕМ ЧЕРЕЗ ТОЧКУ В ОТЛИЧИИ ОТ ФУНКЦИЙ
# результатом поиска строки будет число - это индекс на который метод .find нашёл заданное в поиске
# если нет потстроки метод .find выдаёт -1
print(friend.split()) # метод сплит без параметров будет разбивать нашу строку на части через пробел.
# мы получили список из 7 строчек. Была одна большая строка, её разбили через пробел и каждое слово сделали элементом списка
# можно использовать другой разделитель в .split. и то что будет между этими разделителями попадёт в список, станет элементом списка
print(friend.split('а')) # разделитель буква а
print(friend.isdigit())# метод проверяет состоит ли строка только из чисел. резултат логическое FALSE - не состоит, TRUE - состоит
number = '108' # числа у нас введены в ковычках, поэтому это строка <str>
print(number.isdigit()) # проверяем эту строчку - тру
print(friend.upper()) # переводим строчку в верхний регистр
print(friend.lower()) # переводим всё в нижний гегистр.

# другие методы строки
# функция help(str) посмотреть все методы
# выпадающая подсказка в пайчарм
# pythonworld.ru
# официальная документация пайтон
# google

# Форматирование строк позволяет взять несколько строчек и склеить их между собой.
# конкатенация (не рекомендуется) когда + слепливаем несколько строчек
# % - оператор
# format - функция строки (рекомендуется)

# форматирование строк
name = 'jon'
age = 34
# конкатенация. минусы: плохо читается код, не забывать про пробелы
hello_str = 'Привет, ' + name + ' тебе ' + str(age) + ' лет '  # конкатенация
print(hello_str)
# %  . с помощью % показываем что сюда поступит строка %s, а туда поступит число %d. потом ставим процент и в скобочках указываем порядок переменных
hello_str = 'Привет %s тебе %d лет'%(name, age)
print(hello_str)
# format похоже на работу %
hello_str = 'Привет {} тебе {} лет'.format(name, age)
print(hello_str)

# Пример
# дана строка первые 5 мест на соревнованиях 1. иванов 2. петров 3. сидоров 4. никодимов 5.сорокин
# результат - поздравляем первые три места: 1ИВАНОВ 2 ПЕТРОВ 3 СИДОРОВ с успехом!"
top5 = 'первые 5 мест на соревнованиях: 1.Иванов 2.Петров 3.Петренко 4.Николаев 5.Жулейко'
# создали переменную и поместили в неё нашу строку.
start = top5.find('1') # сначала найдём индекс с которого мы будем обрезать нашу строку.
# с помощью метода find обратимся к переменной top5, которая содержит строку.
# мы будем искать 1. от этого символа я буду искать 1 место.
end = top5.find('4') # после этого найдём конец строки. ищем 4 - т.к всё что выше 3 места в список не войдёт
# после этого можем воспользоваться срезом и найти top3
top3 = top5[start:end] # берём строчку топ5 и будем с помощью среза её обрезать.
# обрезать от индекса start до индекса end , которые выше нашлись с помощью .find
result = 'Поздравляем {} с успехом!'.format(top3.upper())
# Берём строчку топ3 которую получили и вставляем с помощью .format в переменную резалт
# top3.upper() - делаем все буквы большими в этой переменной, которая содержи обрезок изначальной строки
print(result) # выводим на экран результат
# Поздравляем 1.ИВАНОВ 2.ПЕТРОВ 3.ПЕТРЕНКО  с успехом!

#--------------------------------------------------
# УРОК 2.
#--------------------------------------------------
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#