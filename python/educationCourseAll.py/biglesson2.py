# ВСТРОЕННЫЕ ТИПЫ И ОПЕРАЦИИ С НИМИ
#----------------------------------
#
#--------------------------------------------------
# УРОК 1. СТРОКИ. ОПРЕДЕЛЕНИЕ. МЕТОДЫ. ФОРМАТИРОВАНИЕ
#--------------------------------------------------
#
# - тип данных строке
# - объявление строк
# - основные действия со строками
# - дополнительные действия со строками
# - форматирование строки
# - Пример использования
#
# для того чтобы объяить переменную строкового типа мы должны поместить текст или символы внутри одинарных ковычек '...'
# иногда можно воспользоваться двойными ковычками.
# главное чтобы одинаковыми ковычками открывалось и закрывалось.
friend = 'Гугл'
print(friend)
# когда ковычки в ковычках, рассмотрим примеры:
say = 'say "Hello"'
#
pont = "say 'Hello'"
print(say, pont)
# Строка str состоит из набора символов.
# Можем получить какой любо символ по его индексу из строки.
# Индекс указывается в квадратных скобках. Все индексы начинаются с 0.
# В пайтон можно использовать отрицательные индексы
friend = 'Поехали!'
first_letter = friend[0]
print('Первая буква в слове ', first_letter)
# Переменная friend . Чтобы найти первую букву этой переменной воспользуемся индексом friend[0]
# [0] - означает первый символ. [5] - 6ой символ. [8] - 9ый символ
# Если проверим тип переменной first_letter - тоже оказывается строковый
# В пайтон нет отдельного типа под символ - всё является строкой.
print(friend[3]) # выведим на экран 4 ый символ переменной friend
# Также доступна индексация с конца нашей строки
print(friend[-1]) # даёт нам последнюю букву. отрицательными индексируемся с конца.
print(friend[-3]) # Третий с конца символ
# помимо индексов при работе со строкой мы можем пользоваться срезами
# - благодоря срезам можно получить несколько символов(часть строки)
# friend[start:end] чтобы записать срез, мы берём 2 индекса - начальный и конечный, и указываем их через двоеточие
print(friend[1:4]) # вывели на экран элементы строки переменной friend со 2 го по 5 ый  символы
print(friend[:5]) # срез с начала строки до какого то элемента
print(friend[3:]) # срез с какого то элемента до конца строки
print(type(friend[2:5])) # тип среза - <class 'str'>

# Функция len и методы строки
# len(friend) - длина строки (сколько в ней символов)
# friend.find('a') - ищем символ "a" в строке
# friend.split() - разбиение строки через пробел
# friend.isdigit() - строка состоит тлько из чисел
# friend.upper() - ПРИВЕДЕНИЕ СТРОКИ К ВЕРХНЕМУ РЕГИСТРУ
# friend.lower() - ПРИВЕДЕНИЕ СТРОКИ К нижнему РЕГИСТРУ
friend1 = 'лёха игроь танюха маринка семён колян яков'
print(friend1) # вывели на экран переменную friend
print('Число символов в верхней строке: ', len(friend1)) # выведим на экран число символов в строке, которое подсчитает метод len(friend)
print(friend1.find('ма')) # метод файнд удет искать, то что укажем в скобках в строке friend
# МЕТОДЫ МЫВЫЗЫВАЕМ ЧЕРЕЗ ТОЧКУ В ОТЛИЧИИ ОТ ФУНКЦИЙ
# результатом поиска строки будет число - это индекс на который метод .find нашёл заданное в поиске
# если нет потстроки метод .find выдаёт -1
print(friend1.split()) # метод сплит без параметров будет разбивать нашу строку на части через пробел.
# мы получили список из 7 строчек. Была одна большая строка, её разбили через пробел и каждое слово сделали элементом списка
# можно использовать другой разделитель в .split. и то что будет между этими разделителями попадёт в список, станет элементом списка
print(friend1.split('а')) # разделитель буква а
print(friend1.isdigit())# метод проверяет состоит ли строка только из чисел. резултат логическое FALSE - не состоит, TRUE - состоит
number = '108' # числа у нас введены в ковычках, поэтому это строка <str>
print(number.isdigit()) # проверяем эту строчку - тру
print(friend1.upper()) # переводим строчку в верхний регистр
print(friend1.lower()) # переводим всё в нижний гегистр.

# другие методы строки
# функция help(str) посмотреть все методы
# выпадающая подсказка в пайчарм
# pythonworld.ru
# официальная документация пайтон
# google

# Форматирование строк позволяет взять несколько строчек и склеить их между собой.
# конкатенация (не рекомендуется) когда + слепливаем несколько строчек
# % - оператор
# format - функция строки (рекомендуется)

# форматирование строк
name = 'jon'
age = 34
# конкатенация. минусы: плохо читается код, не забывать про пробелы
hello_str = 'Привет, ' + name + ' тебе ' + str(age) + ' лет '  # конкатенация
print(hello_str)
# %  . с помощью % показываем что сюда поступит строка %s, а туда поступит число %d. потом ставим процент и в скобочках указываем порядок переменных
hello_str = 'Привет %s тебе %d лет'%(name, age)
print(hello_str)
# format похоже на работу %
hello_str = 'Привет {} тебе {} лет'.format(name, age)
print(hello_str)

# Пример
# дана строка первые 5 мест на соревнованиях 1. иванов 2. петров 3. сидоров 4. никодимов 5.сорокин
# результат - поздравляем первые три места: 1ИВАНОВ 2 ПЕТРОВ 3 СИДОРОВ с успехом!"
top5 = 'первые 5 мест на соревнованиях: 1.Иванов 2.Петров 3.Петренко 4.Николаев 5.Жулейко'
# создали переменную и поместили в неё нашу строку.
start = top5.find('1') # сначала найдём индекс с которого мы будем обрезать нашу строку.
# с помощью метода find обратимся к переменной top5, которая содержит строку.
# мы будем искать 1. от этого символа я буду искать 1 место.
end = top5.find('4') # после этого найдём конец строки. ищем 4 - т.к всё что выше 3 места в список не войдёт
# после этого можем воспользоваться срезом и найти top3
top3 = top5[start:end] # берём строчку топ5 и будем с помощью среза её обрезать.
# обрезать от индекса start до индекса end , которые выше нашлись с помощью .find
result = 'Поздравляем {} с успехом!'.format(top3.upper())
# Берём строчку топ3 которую получили и вставляем с помощью .format в переменную резалт
# top3.upper() - делаем все буквы большими в этой переменной, которая содержи обрезок изначальной строки
print(result) # выводим на экран результат
# Поздравляем 1.ИВАНОВ 2.ПЕТРОВ 3.ПЕТРЕНКО  с успехом!

#--------------------------------------------------
# УРОК 2. ВСТРОЕННЫЕ ТИПЫ И ОПЕРАЦИИ С НИМИ. СПИСКИ.
#--------------------------------------------------
#
# Встроенные типы и операции с ними. Списки. Определение.методы. Оператор n. Кортежи
#
# - Тип данных list
# - Объявление списков
# - Основные действия со списками
# - Дополнительные действия со списками
# - оператор in
# - кортежи
#
# Практика ---> Теория
#
# Программа "Победители": поздравить победителей соревнований по Python!
# Программа предлагает ввести число участников. После этого мы вводим кто занял какое место.
# После этого программа делает следующие действия: Выводит всех кто участвовал в соревновании, но сортирует список по имени.
# После этого программа объявляет победителей - три человека которые заняли первые места.
#
# Списки (list). Списки - упорядоченные ИЗМЕНЯЕМЫЕ коллекции объектов ПРОИЗВОЛЬНЫХ типов.
# some_list = ['hello', 123, True] - пример списка, содержащего строку, числовые данные, Истинное значение
# чаще всего содержит элементы одного типа
friends = ['leopold', 'maximus', 'yora'] # например список из 3 строк
# для создания пустого списка оставляем пустые квадратные скобки
# Объявляем пустой список
empty_list = [] # Создаём переменную и присваиваем ей пустой список.
# Объявляем список и сразу пишем его значение? заполняем значениями - 4 строки.
friendes = ['opium', 'valium', 'pentalgin', 'nikotin']
print(friendes)
print(type(friendes))# Проверяем тип списка - получим <class 'list'>
# В списке. как ив  строке работают индексы. Они начинаются с нуля, но возвращают они не символы, а строчки из которых состоит список.
# как и в строке для списка доступныиндексы (начинается с 0)
print('второй элемент по индексу списка: ', friendes[2])
print('первый элемент с конца: ', friendes[-1])
# Также можно применить срезы
print('срез элементов с индексам 1 - start и 2 - end: ', friendes[1:2])
print(' первые элементы списка до второго по индексу элемента: ', friendes[:2])
print('элементы после третьего элемента списка: ', friendes[3:])
# Срезы обязательно возвращают список. Даже если там 1 элемент.
# Список как ис трока обладает некоторыми методами и функциями которые можно к списку применить.
# функция len и методы списка
print('Число элементов в списке', len(friendes)) # показывает длину списку (сколько в нем элементов)
friends.append('mukaltin') # добавление нового элемента в список#
friendes.pop() # удаляем последний элемент и возвращаем его т.е можем вывести на экран
friends.clear() # Очищаем весь список. Остаётся пустой список
friendes.remove('opium') # удаление объекта из списка по его значению
del friendes[0] # удаление элемента по индексу
print(friendes)
print('Число элементов в списке', len(friendes))
friendes.append('valium')
print(friendes)
friendes = ['opium', 'valium', 'pentalgin', 'nikotin','kalcium','zink']
print(friendes)
print(friendes.pop()) # удаляем последний элемент и возвращаем его т.е можем вывести на экран
print(friendes)

# Другие методы list
# - сортировка, копирование
# - выпадающая подсказка в pycharm
# - pythomworld.ru
# - официальная документация пайтон
# - google

# Оператор in очень важный оператор, который работает не только для списков но и для других структур данных
# - позволяет проверить наличие элемента в списке
# 'opium' in friendes - результат True или False
# также оператор работает со строками: 's' in 'superman' проверяем подстроку, входит ли она в какую нибудь строчку
# пример со строкой
hero = 'Superman' # У нас есть строковая переменная hero и присваиваем ей значение superman
if hero.find('man') != -1:# нам нужно проверить есть ли в слове Superman слово man/ Если результат не равен -1 , значит есть это man потому что выдала какой то результат find
    print('Есть слово man')
# можем воспользоваться методом .find.  hero.find('man') ищем в переменной hero слово 'man'
# операция нам возвращает какой нибудь индекс, а если не находит ничего возвращает -1
# .find может получить индекс вхождения подстроки в строку
# Для локоничности записи можно использовать оператор in
hero = 'Ivan Durak'
if 'man' in hero:
    print('Есть слово man')
else:
    print('нет слова man')
# есть список целей и нам надо проверить есть ли в этом списке элемент
goals = ['python', 'растиши', 'гараж', 'семья','учёба','деньги']
if 'здоровье' in goals:
    print('Элемент уже есть')
else:
    print('Добавляем элемент в список')
    goals.append('здоровье')
    print(goals)

# Кроме списков в пайтоне есть Кортеж (tuple) - список, который нельзя менять
# записывается в круглых скобках в отличии от списка
roles = ('user','manager','admin')
# кортежи служат для защиты от изменений

# ПРИМЕР. Программа Winners, интерактивное награждение победителей соревнований по python
# пользователь вводит кол-во участников соревнований по python
# пользователь вводит участников и их места в зависимости от кол-ва
# 1) вывод имён участников по алфавиту
# 2) Получить 3 ёх победителей и поздравить их
# 3) Победители: ... Поздравляем!
print('Соревнования по PYTHON')
count = int(input('Введите число участников: ' )) # сперва пользователь введёт число участников и присвоит этот результат в переменную count
i = count # берём счётчик цикла и присваиваем ему значение count. Количество участников буду вводить с конца
numbers = []  # создадим переменную с пустым списком, куда будем запоминать введёных участников.
while i > 0: # пока счётчик цикла больше 0
    name = input('Кто занял {} место'.format(i)) # нам надо спрашивать у пользователя кто занял такое то место
    numbers.append(name) # записываем новый элемент в созданный пустой список
    i -= 1# после этого не забываем вычесть 1 и снова идём в цикл на проверку, пока i не станет < 0
# можем использовать .format и использовать как раз счётчик цикла
# создадим переменную с пустым списком, куда будем запоминать введёных участников.
# После этого формируется список numbers состоящий из count элементов.
# кто участвовал в соревновании (по алфавиту)
print('В соревнованиях участвовали: ', sorted(numbers))# выводим всех участников по порядку ввода
# sorted - сортируем по алфавиту. Эта функция умеет сортировать последовательности.
# мы записали людей с конца
# нам нужно взять первые 3 места. Помним, что записывали людей с конца, поэтому первые три места - 3 последних введёных
numbers.reverse() # реверсируем список и последние элементы становятся первыми
# нам нужно взять первые 3 места.
result = numbers[:3] # объявим переменную, куда присвоим срез со списка number элементов до 3его по индексу. То. е 0,1,2 ИНДЕКСЫ, А ЭТО  1,2,3 - МЕСТА

result = 'Победители: {}. ПОЗДРАВЛЯЕМ!'.format(result)
print(result)

#
#--------------------------------------------------
# УРОК 3. ПОСЛЕДОВАТЕЛЬНОСТИ. ЦИКЛ for in
#--------------------------------------------------
#
# Что такое последовательности
# Общие действия с последовательностями
# Утиная типизация
# цикл for in

# Для разных типов данных строка, список, кортеж мы можем применять одинаковые функции
# Функция type() - чтобы посмотреть класс данных
print(type(friend)) # "<class 'str'>
print(type(friendes)) # <class 'list'>
print(type(roles)) # <class 'tuple'>
# можем использовать индексацию и брать какой то элемент по индексу
print(friend[1])
print(friendes[1])
print(roles[1])
# срезы
print(friend[1:2])
print(friendes[0:2])
print(roles[1:3])
# длина
print(len(friend))
print(len(friendes))
print(len(roles))
# Таким образом все эти типы данных можно обобщить в одно понятие - Последовательности
# Последовательность - контейнер, элемнты которого представляют собой некую последовательность
# Могут быть как изменяемыми (список), так и неизменяемыми (кортеж, строка)
# реализует определённые методы (доступна индексация, взятие длины, ..., можно использовать цикл for)

# Утиная типизация
# Если это выглядит как утка, плавает как утка и крякает как утка, то это, возможно, и есть утка.
# В ООП-языках - определение факта реализации определенного интерфейса объектом без явного указания или наследования этого интерфейса, а просто по реализации полного набора его методов
# Если объект соержит реализацию методов последовательности - он будет считаться последовательностью
friend_name = 'Simon'
friends = ['Sid','Simon','Kate','Den','Mike','Kurd']
roles = ('admin','guest','user')

if 'Sid' in friends:
    print('У меня есть этот друг')
if 'S' in friend_name:
    print('Буква S нашлась')
# for - основной цикл для последовательностей
# позволяет перебирать элементы последовательности по очереди не применяя для этого цикл while
# перебираем по старинке с циклом while
i = 0 # в первую очередь нам понадобится какой нибудь счётчик.
while i < len(friends): # пока счётчик не привысил длину последовательности friends
    friend = friends[i] # вводим переменную куда записываем значение i ого элемента последовательности
    print(friend) # выводим на экран это значение
    i += 1 # прибавляем счётчик
# В принципе сработал он неплохо. Аналогично можно перебрать строчку и картеж.
# НО ЛУЧШЕ ИСПОЛЬЗОВАТЬ ЦИКЛ for
# позволяет перебирать элементы последовательности по порядку без указания индекса
print('Список выведен с помощью цикла for')
for friend in friends:
    print(friend)
# Закнчивает выполнение когда заканчивается последовательность элементов
# позволяет совершить меньше ошибок при переборе элементов

# сперва пишем for потом пишется переменная, которая будет переменной цикла
# далее пишем in и указываем последовательность которую будем перебирать
# после этого выводим на экран переменную friend и такиим образом выпишем всех друзей из списка
# обязательно делаем отступ, когда пишем условие цикла
# после того как последовательность закончится, программа пойдет дальше., выйдет из этого цикла
# т.к. строка и кортеж также последовательности - к ним также можем применить цикл for
for letter in friend1:
    print(letter)
# перебираем строку по буквам
# перебор кортежа аналогичен
for role in roles:
    print(role)
# Цикл while классический для программирования, но в пайтоне приемущество следует отдавать циклу for
# особенно при переборе последовательности
# и когда нам не нужно манипулировать счётчиком индекса и условием цикла
#
#--------------------------------------------------
# УРОК 4. range И КОГДА ЕГО ПРИМЕНЯТЬ
#--------------------------------------------------
#
# когда применять range
# варианты использования range
# циклы for in range
# циклы while for for in range какой выбрать
#
# когда нам может помочь range
# функция range в пайтон
# позволяет создать последовательность целых чисел
# чаще всего используется с циклом for
numbers = range(10)
print(numbers)
print(type(numbers)) # <class 'range'> это специальный тип ни список ни кортеж
# но вместо чисел нам распечатывается range(0,10) какой то диапозон
print(list(numbers)) # если мы хотим распечатать содержимое диапазона range приводим к типу list
# распечаталcя список  целые числа от 0 до 9 .
# таким образом с помощью функции range с одним параметром можно создать последовательность от 0 и до числа
# последняя цифра параметра в диапазон не включается

#

winners = ['exmo','btc','etz']
# мы имеем список победителей и просто вывести их в цикле по очереди простым перебором
# простой перебор
for winner in winners:
    print(winner)
# Но что делать если нам надо вывести место победителя?
# использовать while?
# или есть способ лучше?
# используем range
for i in range(len(winners)): # у нас счётчик i будет пробегать значения от 0 до длины нашего списка
    print(i)
    print(winners[i])
# вывести нечётные числа от 1 до 7
numbers = [1, 3, 5, 7]
for number in numbers:
    print(number)
# как это сделать если цифр будет 1000 или 1000000
# использовать while?
# или есть способ лучше?
#
# параметры range . имеет 3 параметра
# range(start_or_stop, stop[,step])
# start_or_stop начало или конец последовательности
# stop - конец последовательности
# [,step] - шаг с которым мы идём
## вывести нечётные числа от 1 до 7
numbers = [1, 3, 5, 7]
for number in numbers:
    print(number)

print(list(range(1, 7, 2))) # воспользуемся списком или сформируем список с помощью range
# вызываем функцию range , стартуем с 1, конечное значение 7, и третий параметр = шаг =2 т.к идём по нечётным числам
# тоже самое в цикле for
for number in range(1, 9, 1):
    print(number)
# Мы выведим теже самые цифры но в столбик.
#
# for - перебор последовательности. Индекс не нужен
# for range - перебор последовательности нужен индекс где
# for range - необходимо пропустить некоторые элементы или идти с конца в начало
# while - цикл связан с условием, но не с последовательностью
#
#
#--------------------------------------------------
# УРОК 5. 
#--------------------------------------------------
#
#
#
#
#
#
#
#
#