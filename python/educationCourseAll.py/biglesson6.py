#______________________________
# УРОК 6. Работа с файлами. Кодировки
#______________________________
#
# file
# строки байт, кодировки
# запись и чтение байтов
# pickle
# json
#
# file. функция open. её параметры.
# запись текста в файл
# чтение текста из файла
# закрытие файла
# работа через менеджер контента with
#
# функция open
# открывает файл в указанном нами режиме.
# пример вызова функции open
# f= open('my.txt', 'w')
# основные параметры - file - имя файла
# mode - режим
# encoding - кодировка
#
# режими открытия mode
# - r - режим открытия на чтение
# - w - режим на запись, если файла нет, создаётся новый
# - x - запись, если файла нет, ошибка
# - a - дозапись
# - b - двоичный режим
# - + - открытие на чтение и запись
#
# рассмотрим 2 соновных режима на примере
# открывем файл на запись - файл не существует
f = open('firstOpendFile.txt', 'w')
# если мы запустим данный код, файл будет создан
# если файл уже существует он будет перезаписан
# открываем файл на чтение - файла не существует
# f = open('secondOpendFile.txt', 'r')
# получаем ошибку,  т.к файла не существует
# открываем файл на чтение - файл существует
# f = open('firstOpendFile.txt', 'r')
# ошибки нет, в терминале ничего не произошло,
# но мы смогли открыть файл на чтение
#
# запись текста в файл.
# write - записать одну строку в файл
# writelines - записать список строк в файл
# строки при запись в файл не переносятся
# для новой строки \n - символ конца строки
# откроем файл на запись:
f = open('firstOpendFile.txt', 'w')
# после этого берём переменную файла и используем
# метод write
f.write('Пишем строку с помощью: f.write("Пишем строку с помощью..." ')
f.write('Пишем вторую строку с помощью этого же метода ')
# запускаем код: был создан файл firstOpendFile.txt
# и в этом файле теперь при открытии видим:
# ����� ������ � �������: f.write("����� ������ � �������..." ����� ������ ������ � ������� ����� �� ������
# это потому что написано на русской раскладке, а кодировка не указана
f.write('What the fuck? ')
# это текст видно
f.write('because code not utf-8')
# получаем: What the fuck? because code not utf-8
# склеенные строчки в одну мегастроку
# мы видим наши строки, слепленные друг с другом
f.write('What the fuck? \n ')
f.write('because code not utf-8')
# f.write('What the fuck? \n ') используем \n для переноса строки
# следующий основной метод запись f.writelines()
# он позволяет записать строки сразу несколько строк списком
f.writelines(['python', 'learning', 'time'])
# после запуска получим
# pythonlearningtime
# слепленные между собой строки
f.writelines(['python\n', 'learning\n', 'time\n'])
# теперь записано 3 строчками, они хронятся в файле  firstOpendFile.txt
# а файл находится на диске
#
# чтение из файла
# рассмотрим три основных метода
# - read - чтение всего файла целиком
# - for line in f - цикл for чтение файла псотрочно
# - readlines - чтение файла в список строк . чтение файла и сохранение в список
f = open('firstOpendFile.txt', 'r')
# первый метод прочитать всё и использовать метод read
print(f.read())
# если так сделаем получим содержание файла, как одну строчку
# мы можем очень удобно перебрать содержание файла
# с помощью цикла for
for line in f:
    print(line)
# таким образом переменная цикла line
# будет обозночать каждую строку
# когда стоит символ \n перенос строки будет отдельной строкой
# чтобы его убрать воспользуемся методом replace
for line in f:
    print(line.replace('\n', ''))
# заменим символ '\n' на пустой символ ''
# последний стандартный выриант
print(f.readlines())
# использование функции readlines()
# которая позволяет читать файл и сохранять результат в список
# получим список из всех строчек нашего файла
#
# закрытие файла
# при работе с файлом его необходимо закрывать
# открытые файлы тратят ресурсы системы
# это можно сделать 2-умя способами
# использование метода f.close()
# он закрывает файл
# Но если до close произойдёт исключительная ситуация,
# то файл не будет закрыт
# удобным вместо close() является использование конструкции with
# рассмотрим на прмерах:
# мы поработали с файлом firstOpendFile.txt
# его открыли, добавили содержимое, вывели результат
# после этого надо файл закрыть
# самый простой способ вызвать close метод у файла
f.close()
# если запустим файл, в выводе ничего не изменится, но файл
# будет закрыт и не будет тратить ресурсы системы
# этот метод плох тем, что всегда надо помнить о вызове метода close
# это можно избежать, если использовать конструкцию with
with open('firstOpendFile.txt', 'r') as f:
    for line in f:
        print(line.replace('\n', ''))
# пишем ключевое слово with
# далее идёт функия открытия файла open('firstOpendFile.txt', 'r')
# после этого мы записываем результат в переменную f: as f:
# начинаем писать с отступом
# далее действуем также
# мы например читаем строки из файла и выводим на экран
#    for line in f:
#         print(line.replace('\n', ''))
# но после этого уже не нужно закрывать файл
# он будет автоматически закрыт после того как
# закончится блок with
#
#
# Строки байт. Кодировки.
#
# - строки байт
# - пример работы со строками байт
# - перевод строки в str в байты
# - перевод байт в строку str
# - кодировки
#
# В пайтоне есть несколько типов строк
# - str - обычные строки
# - bytes - строки байт
# - bytearray - изменяемая строка байт
# для создания обычной строки мы записываем символы
# между одинарными или двойными квычками
s = 'Hello world. type str.'
# если посмотрим тип - str
print(type(s))
# чтобы создать строку байт
# перед ковычками ставим b''
sb = b'Hello world. type byte.'
# тип этой строки -<class 'bytes'>
print(type(sb))
# выведим строку в терминал: b'Hello world. type byte.'
print(sb)
# вывод выглядит как у обычной строки но перед строкой b
#  b'Hello world. type byte.'
# два наиболее показательных действия со строкой байт
# - взятие индекса индекс sb[0]
# - взятие среза срез sb[1:3]
# через эти 2 действия увидим отличия от обычной строки
# индекс в обычной строке : e
print(s[1])
# индекс в строке байт : 101
print(sb[1])
# если возьмём индекс в обычной строке - это будет какой то символ
# если возьмём индекс в байт - это будет не сам символ,
# а код этого символа
# срез в обычной строке: el
print(s[1:3])
# срез в строке байт: b'el'
print(sb[1:3])
# на самом деле вместо символов тоже используются коды
# строка просто выводится в красивом, удобном нам виде
# переберём строку байт с помощью цикла for
for item in sb:
    print(item)
# получаем код каждого символа
#
# Как строка хранится в памяти? что такое код символа.
# любая информация в памяти хранится как набор 0 и 1
# строки не являются исключением
# каждому символу ставится в соответствие определённый код (число)
# коды могут быть разные и зависят от кодировки
#
# основные кодировки :
# - ascii - американские символы
# - latin-1 - европейские символы
# - utf-8 - универсальная кодировка для большинства языков
#  чем универсальнее кодировка, тем больше байт требуется
# для кодирования одного символа
# таким образом каждый символ можно закодировать числом,
# а число представить в виде набора 0 и 1
# строка байт, состоящая из 2ух символов A и d
sb = b'Ad'
print(sb[0])
print(sb[1])
# по ascii кодировки из таблицы видим A = 65, d = 100
#
# перевод строки в байты (кодирование)
# процедура перевода называется кодирование
# 'Hello world'.encode('utf-8')
# с помощью метода .encode и указания кодеровки можно переводить
# при переводе строки str в байты bytes указываем кодировку
# эта кодировка должна поддерживать символы нужного нам алфавита
# пример:
# есть обычная строка:
st = 'Nicodim anknown all'
# хотим из неё сделать тип bytes
stb = st.encode('ascii')
# берём нашу строчку st
# вызываем метод .encode: st.encode
# и указываем кодировку ('ascii'): st.encode('ascii')
# посмотрим что получилось:
print(stb)
print(type(stb))
# b'Nicodim anknown all'
# <class 'bytes'>
# попробуем сделать тоже самое, с использованием русскими символами
st = 'Nicodim anknown all. Мир. Дружба. Жвачка'
# stb = st.encode('ascii')
# при запуске программы возникает ошибка, потому что в этой кодировке
# мы не знаем как кодировать русские символы
# чтобы программа стала универсальна используем другую кодировку
stb = st.encode('utf-8')
print(stb)
print(type(stb))
# но русские символы отобразаются закодированными
# b'Nicodim anknown all. \xd0\x9c\xd0\xb8\xd1\x80. \xd0\x94\xd1\x80\xd1\x83\xd0\xb6\xd0\xb1\xd0\xb0. \xd0\x96\xd0\xb2\xd0\xb0\xd1\x87\xd0\xba\xd0\xb0'
# можем провести обратную процедуру декодирование
#
# перевод байт в строку (декодирование)
# выполняется по аналогии с предыдущей к строке байт
# stb.decode('utf-8')
# обязательно указываем кодировку, которой мы кодировали строку
# иначе могут возникнуть ошибки и неточности
s = stb.decode('utf-8')
# метод .decode к строке которая байты
# проверяем выведим нашу строчку
print(s)
print(type(s))

# Запись и чтение байтов
# - работа с файлом в режиме байтов
# - параметр encoding
# - запись байтов в файл
# - чтение байтов из файла
# - примеры использования
#
# Работа с файлом в режиме байтов
# - open('filename','wb') - режим записи байтов
# для того чтобы работать с файлом в режиме байтов
# мы в режим добавляем букву b
# - open('filename','rb')
# когда работаем со строками, переводим их в байты
# мы используем кодировку .
# - параметр encoding определяет кодировку
# и при открытии файла мы указываем
# open('filename', 'w', encoding='utf-8')
# рассмотрим примеры открытия файлов
# открываем файл для записи байтов используем параметр 'wb'
with open('bytes.txt', 'wb') as f:
    pass
# когда мы работаем с байтами указание кодировки нам не требуется,
# потому что байты это итак 0 и 1
# with open('bytes.txt', 'wb') as f: - открываем файл на запись
# ставим пока заглушку pass
# откроем файл на чтение; with open('bytes.txt', 'rb') as f:
with open('bytes.txt', 'rb') as f:
    pass
# после этого, когда уже работаем с обычным текстовым файлом
# нам желательно добавлять кодировку. Потому что будем писать текст
# он будет преобразовываться в пайтоне
# открываем файл в текстовом режиме с указанием кодировки
with open('bytes.txt', 'r', encoding='utf-8') as f:
    pass

# Запись байтов в файл
# первый способ, когда мы реально имеем набор байт
# мы можем через метод .write просто записать в файл
# если файл открыт в режиме wb
# f.write(b'some bytes') - файл открыт в режиме wb
# f.write('some str') - файл открыт в режиме w
# в любом случае информация хранится в виде 0 и 1
# для строкового метода нужно помнить про кодировку
# примеры:
# открываем файл для записи байтов в режиме 'wb'
with open('bytes.txt', 'wb') as f:
    # пишем строку байт
    f.write(b'Hello bytes')
    # с помощью метода .write записываем туда строку байт f.write(b'Hello bytes')
    # символы будут американские

with open('bytes.txt', 'r', encoding='ascii') as f:
    # пишем строку байт
    print(f.read())
    # читаем файл просто как текст в режиме 'r'
    # с указанием кодировки encoding='ascii'
    # мы записали набор байтов в файл, но читаем уже как строку
    # получаем в итоге Hello bytes

# открываем файл для записи байтов в режиме 'wb'
with open('bytes.txt', 'wb') as f:
    # пишем строку байт на русском
    str = 'Привет мир'
    # переводим её в байты, чтобы записать с помощью метода encode
    # и указываем кодировку encode('utf-8')
    f.write(str.encode('utf-8'))

# читам как текст с кодировкой utf-8
with open('bytes.txt', 'r', encoding='utf-8') as f:
    # пишем строку байт
    print(f.read())
# открываем файл в режиме чтения 'r'
# и указываем кодировку encoding='utf-8'
# чтобы прочитать русские символы.
# выводим результат Привет мир   print(f.read())

# Чтение байтов из файла аналогично записи
# когда файл открыт в режиме rb
# f.read() - файл открыт в режиме rb - читаем байты
# мы действительно будем с помощью метода read читать набор байт
# т.е тип <<class 'bytes'>>
# если же открыть файл в режиме r
# f.read() - файл открыт в режиме r - читаем строки
# с помощью того же самого метода .read()
#
# рассмотрим примеры с чтением байтов из файла:
# открываем файл для записи баййтов
with open('betys.txt', 'wb') as f:
    # пишем строку байт
    str = 'Ёрик, бедный Ёрик'
    f.write (str.encode('utf-8'))
# чтобы байты прочитать, их нужно записать
# открываем файл open('betys.txt' в режиме записи байт 'wb'
# пишем туда строку   str = 'Ёрик, бедный Ёрик'
# пердварительно её кодируем f.write (str.encode('utf-8'))
# тогда мы получим байты и с помощью метода write записываем их в файл

# открываем open файл 'bytes.txt' в режиме 'rb' чтения байтов
with open('bytes.txt', 'rb') as f:
    # читаем байты
    # это будет набор байтов
    result = f.read()
    # выведим сам результат: b'\xd0\x9f\xd1\x80\xd0\xb8\xd0\xb2\xd0\xb5\xd1\x82 \xd0\xbc\xd0\xb8\xd1\x80'
    print(result)
    # и тип нашего результата <class 'bytes'>
    print(type(result))
    # декодируем для получения строки
    s = result.decode('utf-8')
    # теперь мы получим наши байты в виде текста: Привет мир
    print(s)

# Рассмотрим ещё один пример :
# откроем файл для записи но уже просто в режиме w
with open('betys.txt', 'w', encoding=('utf-8')) as f:
    # теперь можно просто написать на кирилице
    f.write ('Ёрик, бедный Ёрик')
# НО НУЖНО УКАЗАТЬ КОДИРОВКУ,
# чтобы затем правильно принести всё к строке
#  запускаем пример и получаем тоже самое
with open('bytes.txt', 'rb') as f:
    result = f.read()
    # выведим сам результат: b'\xd0\x9f\xd1\x80\xd0\xb8\xd0\xb2\xd0\xb5\xd1\x82 \xd0\xbc\xd0\xb8\xd1\x80'
    print(result)
    # и тип нашего результата <class 'bytes'>
    print(type(result))
    s = result.decode('utf-8')
    print(s)
# когда мы записываем текст в файл на самом деле в памяти
# файл свё равно хронится в виде набора байт
# поэтому при указании кодировки encoding=('utf-8')
# мы пишем строки в файле f.write ('Ёрик, бедный Ёрик')
# они переводятся в байты и мы можем их читать точно также
# в виде набора байт
# и при получении байтов перевели в строку с помощью декодирования
#  s = result.decode('utf-8') методом decode

# модуль Pickle
# - Сериализация данных
# - запись сложного объекта в файл
# - модуль pickle
# - основные функции
# - примеры применения
#
# сериализация - процесс преобразования объекта
# в поток байтов для сохранения или передачи в память,
# в базу данных или файл
# обратный процесс - десериализация
# применение:
# = сохранение сложного объекта в файл
# = сохранение объекта в базу данных
# = передача объекта по сети
# способы записи объекта в файл. 2 основных:
# - ручной . "создание велосипеда"
# - универсальный pickle
#
# ручной способ:
# например мы имеем объект, который описывает человека
# {'name': 'Jurgen', 'phones': [123,345]}
# у него есть имя и набор телефонов
# как перевести такой объект, который является словарём (dict)
# в байты для сохранения в файл?
# например: 1. придумать способ приведения объекта к более простым
# например к строкам или числам
# 2. придумать свой формат хранения данных
# для того чтобы сохранить объект и была возможность его прочесть
# рассмотрим пример одного из вариантов реализации ручного способа:
print('Пример ручной реализации:')
person = {'name': 'Jurgen', 'phones': [123,345]}
print(type(person))
# мы имеем объект person, он у нас является словарём
# в котором содержится как строка {'name': 'Jurgen'
# так и список из чисел 'phones': [123,345]
#
# откроем файл для записи в режиме байтов
with open('person.dat', 'wb') as f:
# например запишем объект в файл построчно
# сначала возьмём имя и будем записывать его
    name = person['name']
# для этого м берём имя по ключю 'name'
    print(type(name))
# после этого у нас уже имеется тип строка
# добавим перенос строки переведм в байты и запишем
    f.write(f'{name}\n'.encode('utf-8'))
# с помощью метода .write мы эту строку переводим в байты encode('utf-8')
# и записываем в файл.
# также добавим перенос строки \n
# после этого нам надо сохранить телефоны человека
# получим телефоны
    phones = person['phones']
    print(type(phones))
# запишем 1 телефон в новую строку
# мы достаём его по ключу phones : phones = person['phones']
# получаем переменную
# телефоны будем записывать в каждой новой строчке
# перебираем список phones
# телафон является числом, поэтому мы его приведём к строке
# и не забудем добавить для переноса на новую строчку \n
# кодируем это в байты : .encode('utf-8')
    for phone in phones:
        f.write(f'{phone}\n'.encode('utf-8'))
print('Объект записан!')
# запустили программу . нашли новый файл : person.dat
# открываем и видим 3 строки:
# Jurgen
# 123
# 345
#
# Теперь рассмотрим вариант загрузки
# когда мы записали в файл объект person
# нам ещё необходимо записать код, чтобы его загрузить
# код загрузки нашего объекта тоже будет достаточно грамозским:
# давайте рассмотрим построчно:
#
# читаем объект иза файла
# откроем файл на  (with open('person.dat', 'rb') as f:)
# в режиме bytes 'rb':
print('Читаем объект из файла')
with open('person.dat', 'rb') as f:
# с помощью метода readlines() прочитаем каждую строку, как элемент списка
# теперь нам надо знать как мы зписали объект
# прочитаем файл в список
    result = f.readlines()
# теперь воссаздоём исходный объект
# обязательно надо знать в каком порядке записывали элементы
person = {}
# создаём пустой словарь person
# первый элемент это имя
# чтобы записать в него имя
# мы возьмм первую строчку из нашего файла (result[0])
# декодируем байты в утф-8 (decode('utf-8'))
# и заменим символ \n на пустое место (replace('\n', ''))
person['name'] = result[0].decode('utf-8').replace('\n', '')
# далее идут телефоны
phones = []
# перебираем каждый из них - это у нас байты (bphone)
for bphone in result[1:]:
    phones.append(bphone.decode('utf-8').replace('\n', ''))
person['phones'] = phones
# декодируем .decode('utf-8')
# убираем \n . (replace('\n', ''))
# и добавляем всписок телефонов (.append)
# берём наш словарь person
# и добавляем в него телефоны (person['phones'] = phones)
#
# получили исходный объект. Это было достаточно тяжело.
# А что если он немного изменится?
print('выводим результат')
print(person)
#
# На этом примере видны все недостатки ручного способа:
# - не универсальный
# - При небольшом изменении объекта изменится весь алгоритм записи и чтения
# - надо помнить как мы делали сохранение, чтобы потом прочитать
# - как делали сохранение, чтобы потом сделать загрузку?
# - трудоёмкий
#
# модуль pickle
# сохроняет сложные объекты в файл
# пребразует сложные объекты в байты
# модуль встроен в пайтон
#
# pickle. основные функции
# 1) dump - сохранение объекта в файл
# 2) dumps - преобразование объекта в байты
# 3) load - загрузка объекта из файла
# 4) loads - загрузка объекта из набора байт
#
# пример записи того же самого объекта person
# который является словарём
# с помощью модуля picle
import pickle
# импортируем модуль. он встроен в пайтон
person = {'name': 'Abdul', 'phones': [133,3345]}
# открываем файл на запись байт 'wb'
with open ('person.dat', 'wb') as f:
    # сразу пишем объект целиком с помощью picle
    pickle.dump(person, f)
    # берём функцию .dump() встроенную в модуле  picle в пайтон
    # первым параметром передаём сложный объект dump(person,
    # который мы хотим записать
    # вторым параметром передаём файл в который мы сохроняем
print('Объект записан')
# запустим программу и откроем файл
# мы уже не видим в файле что то понятное
# ��&       }�(�name��Abdul��phones�]�(K�M
# eu.
# Потому что pickle в каком то своём формате записал этот объект
# как его прочитать?
import pickle
# Открываем файл на чтение байт 'rb'
with open ('person.dat', 'rb') as f:
    # сразу читаем объект из файла с помощью pickle
    person = pickle.load(f)
print(person)
# универсальность применения данного способа
# можем писать в файл объекты любой сложности
# если захотим, можем расширить объект person и добавить например возраст
person = {'name': 'Fin', 'phones': [13233,334534], 'age': 20}
# код загрузки и выгрузки теперь менять не нужно.
# для ручного способа, пришлось бы дописывать код для манипуляций
# с возрастом
# не нужно заботиться ка корганизована структура объекта

# модуль Json
# - Формат json. применение
# - модуль json в пайтон. применение
# - основные функции
# - примеры
#
# json - расшифровывается
# JavaScript Object Notation
# текстовый формат обмена данными, основанный на JavaScript
# Аналогичен набору словарей, списков, простых типов данных в пайтон
# но является просто текстом (строкой). для пайтона это будет строчка
#
# применение
# - хранение данных
# - передача данных
# - чаще всего используется в web разработке
# - для передачи данных по протоколу http
# там мы передаём текст (строки)
#
# json в пайтон
# т.к основные структуры пайтон схожи с форматом
# и нам требуется только преобразовывать данные в строки и обратно
# модуль json это делает
# для использования импортируем import json
#
# json. Основные функции
# аналогичны функциям pickle
# - dump - сохронение объекта в формате json в файл
# - dumps - преобразование объекта в json (в текст), но не сохраняет файл
# - load - загрузка объекта из файла
# - loads - загрузка объекта из формата json (строки) из строчки получаем объект
# рассмотрим пример преобразования сложного объекта в формат json
# импортируем модуль для использования
import json
print('json')
# есть сложный объект friends - список друзей
# сложный объект, список в который входят словари
# и далее в соварях есть ещё какие то простые типы
friends = [
    {'name': 'Karl', 'age': 23, 'phones': [287, 487]},
    {'name': 'Leo', 'age': 25}
]
# узнаём тип объекта
print(type(friends))
# <class 'list'> - мы имеем дело со списком
# преобразуем список друзей в json
# с помощью функции json.dumps преобразуем наш объект в формат json
json_friends = json.dumps(friends)
# печатаем что получилось
print(json_friends)
# проверим тип
print(type(json_friends))
# <class 'str'>
# после преобразования объект практически не изменился
# но тип поменялся на строку
# сложный объект превратился в строку в нужном нам формате
#
# обратная процедура из json в объект
# friends = json.load(json_friends)
# print(friends)
# print(type(friends))
# если у нас есть строка. т.е объект в формате json
# vs можем с помощью метода .load
# превратить его снова в наш пайтоновский объект
# json.load(json_friends), где json_friends
# строка в формате json
#
# по аналогии с предыдущим примером можем воспользоваться записью формата json в файл
import json
# у нас есть список friends
friends = [
    {'name': 'Kito', 'age': 45, 'phones': [277, 4888]},
    {'name': 'Mike', 'age': 43}
]
# тип данных лист <class 'list'>
print(type(friends))
# открываем файл в режиме записи 'w'
# здесь уже пишем текст, а не байты
with open('friends.jon', 'w') as f:
    # преобразуем список друзей в json и сохраняем в файл f
    json_friends = json.dumps(friends, f)
# обратно из файла в объект открываем фай на чтение 'r'
with open('friends.jon', 'r') as f:
    friends = json.load(f)
print(friends)
print(type(friends))
# практическия задача:
# передать спискок любимых песен и их исполнителей
# своему другу, разработчику c#
import json
favorite_tracks = [
    {'song': 'песня о любви', 'artist': 'Необез'},
    {'song': 'Алифия', 'artist': 'Сектор Ю'},
    {'song': 'шарф', 'artist': 'Трусонг'},
]
# у нас есть список песен - сложный объект
# список из словарей
# делаем импорт json
# далее будем открывать файл
# назовём его songs и формат songs.json
# открываем его на запись 'w'
# также укажем кодировку т.к у нас есть русские символы
with open('songs.json', 'w', encoding='utf-8') as f:
    # с помощью модуля json и функции dump
    json.dump(favorite_tracks, f)
print('Завершено!')
# записываем набор треков в файл
# первый параметр favorite_tracks
# второй параметр f это собственно наш файл
# запускаем программу
# далее мы будем брать этот файл и отсылать другу

